{
  "timestamp": "2025-09-10T11:36:37.653924",
  "overall_status": "failed",
  "test_results": {
    "unit": {
      "success": false,
      "output": "",
      "errors": "ImportError while loading conftest '/Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/conftest.py'.\ntests/conftest.py:38: in <module>\n    from main import app\nmain.py:15: in <module>\n    import psutil\nE   ModuleNotFoundError: No module named 'psutil'\n"
    },
    "integration": {
      "success": false,
      "output": "",
      "errors": "ImportError while loading conftest '/Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/conftest.py'.\ntests/conftest.py:38: in <module>\n    from main import app\nmain.py:15: in <module>\n    import psutil\nE   ModuleNotFoundError: No module named 'psutil'\n"
    },
    "auth": {
      "success": false,
      "output": "",
      "errors": "ImportError while loading conftest '/Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/conftest.py'.\ntests/conftest.py:38: in <module>\n    from main import app\nmain.py:15: in <module>\n    import psutil\nE   ModuleNotFoundError: No module named 'psutil'\n"
    },
    "e2e": {
      "success": false,
      "output": "",
      "errors": "ImportError while loading conftest '/Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/conftest.py'.\ntests/conftest.py:38: in <module>\n    from main import app\nmain.py:15: in <module>\n    import psutil\nE   ModuleNotFoundError: No module named 'psutil'\n"
    },
    "comprehensive": {
      "success": false,
      "output": "",
      "errors": "ImportError while loading conftest '/Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/conftest.py'.\ntests/conftest.py:38: in <module>\n    from main import app\nmain.py:15: in <module>\n    import psutil\nE   ModuleNotFoundError: No module named 'psutil'\n"
    }
  },
  "coverage_results": {},
  "quality_metrics": {
    "linting": {
      "tool": "flake8",
      "success": false,
      "output": "./main.py:218:20: F821 undefined name 'get_db_session'\n        async with get_db_session() as session:\n                   ^\n./main.py:352:20: F821 undefined name 'get_db_session'\n        async with get_db_session() as session:\n                   ^\n./main.py:521:20: F821 undefined name 'get_db_session'\n        async with get_db_session() as session:\n                   ^\n./main.py:583:20: F821 undefined name 'get_db_session'\n        async with get_db_session() as session:\n                   ^\n./main.py:624:16: F821 undefined name 'Dict'\n    variables: Dict[str, Any],\n               ^\n./main.py:624:26: F821 undefined name 'Any'\n    variables: Dict[str, Any],\n                         ^\n./main.py:658:16: F821 undefined name 'Dict'\n    variables: Dict[str, Any],\n               ^\n./main.py:658:26: F821 undefined name 'Any'\n    variables: Dict[str, Any],\n                         ^\n./main.py:692:20: F821 undefined name 'get_db_session'\n        async with get_db_session() as session:\n                   ^\n./tests/integration/test_database_migrations.py:135:30: F821 undefined name 'Column'\n                             Column('priority_level', String(20), default='normal'))\n                             ^\n./tests/integration/test_database_migrations.py:135:55: F821 undefined name 'String'\n                             Column('priority_level', String(20), default='normal'))\n                                                      ^\n./tests/integration/test_database_migrations.py:481:30: F821 undefined name 'Column'\n                             Column('priority_score', Integer, default=0))\n                             ^\n./tests/integration/test_database_migrations.py:481:55: F821 undefined name 'Integer'\n                             Column('priority_score', Integer, default=0))\n                                                      ^\n./tests/performance/test_load_testing.py:528:17: F821 undefined name 'select'\n                select(Notification).where(Notification.organization_id == \"org-1\")\n                ^\n./tests/performance/test_load_testing.py:532:17: F821 undefined name 'select'\n                select(Notification).where(Notification.status == \"delivered\")\n                ^\n./tests/performance/test_load_testing.py:536:17: F821 undefined name 'select'\n                select(Notification).where(Notification.user_id == \"user-10\")\n                ^\n./tests/performance/test_load_testing.py:540:17: F821 undefined name 'select'\n                select(Notification)\n                ^\n17    F821 undefined name 'get_db_session'\n17\n"
    },
    "formatting": {
      "tool": "black",
      "success": false,
      "output": "--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/providers/__init__.py\t2025-09-09 14:19:44.946664+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/providers/__init__.py\t2025-09-10 11:37:00.742613+00:00\n@@ -9,24 +9,20 @@\n from .push import PushProvider, FirebasePushProvider\n from .in_app import InAppProvider\n \n __all__ = [\n     # Base classes\n-    'NotificationProvider',\n-    'NotificationResult', \n-    'NotificationStatus',\n-    \n+    \"NotificationProvider\",\n+    \"NotificationResult\",\n+    \"NotificationStatus\",\n     # Email providers\n-    'EmailProvider',\n-    'SMTPProvider',\n-    \n+    \"EmailProvider\",\n+    \"SMTPProvider\",\n     # SMS providers\n-    'SMSProvider',\n-    'TwilioProvider',\n-    \n+    \"SMSProvider\",\n+    \"TwilioProvider\",\n     # Push providers\n-    'PushProvider',\n-    'FirebasePushProvider',\n-    \n+    \"PushProvider\",\n+    \"FirebasePushProvider\",\n     # In-app provider\n-    'InAppProvider',\n-]\n\\ No newline at end of file\n+    \"InAppProvider\",\n+]\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/alembic/env.py\t2025-09-09 13:28:28.148626+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/alembic/env.py\t2025-09-10 11:37:00.804296+00:00\n@@ -1,6 +1,7 @@\n \"\"\"Alembic environment configuration for Communication Service\"\"\"\n+\n from logging.config import fileConfig\n import os\n import sys\n from sqlalchemy import engine_from_config\n from sqlalchemy import pool\n@@ -28,19 +29,21 @@\n # other values from the config, defined by the needs of env.py,\n # can be acquired:\n # my_important_option = config.get_main_option(\"my_important_option\")\n # ... etc.\n \n+\n def get_database_url():\n     \"\"\"Get database URL from environment or config\"\"\"\n     # Try environment variable first\n     database_url = os.getenv(\"DATABASE_URL\")\n     if database_url:\n         return database_url\n-    \n+\n     # Fall back to config file\n     return config.get_main_option(\"sqlalchemy.url\")\n+\n \n def run_migrations_offline() -> None:\n     \"\"\"Run migrations in 'offline' mode.\n \n     This configures the context with just a URL\n@@ -74,11 +77,11 @@\n \n     \"\"\"\n     # Create engine configuration\n     configuration = config.get_section(config.config_ini_section, {})\n     configuration[\"sqlalchemy.url\"] = get_database_url()\n-    \n+\n     connectable = engine_from_config(\n         configuration,\n         prefix=\"sqlalchemy.\",\n         poolclass=pool.NullPool,\n     )\n@@ -96,6 +99,6 @@\n \n \n if context.is_offline_mode():\n     run_migrations_offline()\n else:\n-    run_migrations_online()\n\\ No newline at end of file\n+    run_migrations_online()\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/create_initial_migration.py\t2025-09-09 13:36:09.997356+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/create_initial_migration.py\t2025-09-10 11:37:00.821906+00:00\n@@ -6,56 +6,65 @@\n import os\n import sys\n import subprocess\n from pathlib import Path\n \n+\n def main():\n     \"\"\"Create initial database migration\"\"\"\n     print(\"\ud83d\udd27 Creating initial database migration for Communication Service...\")\n-    \n+\n     # Ensure we're in the right directory\n     service_dir = Path(__file__).parent\n     os.chdir(service_dir)\n-    \n+\n     try:\n         # Generate initial migration\n         print(\"\ud83d\udcdd Generating initial migration...\")\n-        result = subprocess.run([\n-            \"alembic\", \"revision\", \"--autogenerate\", \n-            \"-m\", \"Initial database schema with all communication models\"\n-        ], capture_output=True, text=True)\n-        \n+        result = subprocess.run(\n+            [\n+                \"alembic\",\n+                \"revision\",\n+                \"--autogenerate\",\n+                \"-m\",\n+                \"Initial database schema with all communication models\",\n+            ],\n+            capture_output=True,\n+            text=True,\n+        )\n+\n         if result.returncode == 0:\n             print(\"\u2705 Initial migration created successfully!\")\n             print(f\"\ud83d\udccb Output: {result.stdout}\")\n-            \n+\n             # List migration files\n             migrations_dir = service_dir / \"alembic\" / \"versions\"\n             if migrations_dir.exists():\n                 migration_files = list(migrations_dir.glob(\"*.py\"))\n                 if migration_files:\n                     print(f\"\ud83d\udcc1 Migration files created: {len(migration_files)}\")\n                     for file in migration_files:\n                         print(f\"   - {file.name}\")\n-            \n+\n             print(\"\\n\ud83d\ude80 Next steps:\")\n             print(\"1. Review the generated migration file in alembic/versions/\")\n             print(\"2. Run 'alembic upgrade head' to apply the migration\")\n             print(\"3. Start the Communication Service with 'python main.py'\")\n-            \n+\n         else:\n             print(\"\u274c Failed to create migration!\")\n             print(f\"Error: {result.stderr}\")\n             return 1\n-            \n+\n     except FileNotFoundError:\n         print(\"\u274c Alembic not found! Please install requirements.txt first:\")\n         print(\"   pip install -r requirements.txt\")\n         return 1\n     except Exception as e:\n         print(f\"\u274c Error creating migration: {e}\")\n         return 1\n-    \n+\n     return 0\n \n+\n if __name__ == \"__main__\":\n-    sys.exit(main())\n\\ No newline at end of file\n+    sys.exit(main())\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tasks/__init__.py\t2025-09-09 14:27:19.776079+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tasks/__init__.py\t2025-09-10 11:37:00.858557+00:00\n@@ -29,26 +29,23 @@\n     generate_daily_report,\n )\n \n __all__ = [\n     # Notification tasks\n-    'send_notification',\n-    'send_bulk_notifications',\n-    'send_scheduled_notification',\n-    'send_urgent_notification',\n-    'process_scheduled_notifications',\n-    \n+    \"send_notification\",\n+    \"send_bulk_notifications\",\n+    \"send_scheduled_notification\",\n+    \"send_urgent_notification\",\n+    \"process_scheduled_notifications\",\n     # Template tasks\n-    'render_template',\n-    'validate_template',\n-    'clear_expired_cache',\n-    \n+    \"render_template\",\n+    \"validate_template\",\n+    \"clear_expired_cache\",\n     # Cleanup tasks\n-    'cleanup_old_notifications',\n-    'cleanup_failed_notifications',\n-    'cleanup_expired_cache',\n-    \n+    \"cleanup_old_notifications\",\n+    \"cleanup_failed_notifications\",\n+    \"cleanup_expired_cache\",\n     # Monitoring tasks\n-    'update_notification_statistics',\n-    'check_provider_health',\n-    'generate_daily_report',\n-]\n\\ No newline at end of file\n+    \"update_notification_statistics\",\n+    \"check_provider_health\",\n+    \"generate_daily_report\",\n+]\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/celery_app.py\t2025-09-09 14:27:09.051920+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/celery_app.py\t2025-09-10 11:37:00.904797+00:00\n@@ -1,9 +1,10 @@\n \"\"\"\n Celery Application Configuration\n Background task processing for notification delivery\n \"\"\"\n+\n import os\n from celery import Celery\n from celery.schedules import crontab\n import logging\n \n@@ -19,106 +20,99 @@\n     include=[\n         \"tasks.notification_tasks\",\n         \"tasks.template_tasks\",\n         \"tasks.cleanup_tasks\",\n         \"tasks.monitoring_tasks\",\n-    ]\n+    ],\n )\n \n # Celery configuration\n celery_app.conf.update(\n     # Task settings\n     task_serializer=\"json\",\n     accept_content=[\"json\"],\n     result_serializer=\"json\",\n     timezone=\"UTC\",\n     enable_utc=True,\n-    \n     # Worker settings\n     worker_prefetch_multiplier=4,\n     worker_max_tasks_per_child=1000,\n     worker_disable_rate_limits=False,\n-    \n     # Task routing and priorities\n     task_routes={\n         \"tasks.notification_tasks.send_notification\": {\"queue\": \"notifications\"},\n         \"tasks.notification_tasks.send_bulk_notifications\": {\"queue\": \"bulk\"},\n         \"tasks.notification_tasks.send_scheduled_notification\": {\"queue\": \"scheduled\"},\n         \"tasks.template_tasks.*\": {\"queue\": \"templates\"},\n         \"tasks.cleanup_tasks.*\": {\"queue\": \"maintenance\"},\n         \"tasks.monitoring_tasks.*\": {\"queue\": \"monitoring\"},\n     },\n-    \n     # Task priorities\n     task_annotations={\n         \"tasks.notification_tasks.send_notification\": {\"priority\": 5},\n         \"tasks.notification_tasks.send_urgent_notification\": {\"priority\": 9},\n         \"tasks.notification_tasks.send_bulk_notifications\": {\"priority\": 2},\n         \"tasks.cleanup_tasks.*\": {\"priority\": 1},\n     },\n-    \n     # Result settings\n     result_expires=3600,  # 1 hour\n     result_backend_transport_options={\n         \"master_name\": \"mymaster\",\n         \"visibility_timeout\": 3600,\n     },\n-    \n     # Retry settings\n     task_acks_late=True,\n     worker_prefetch_multiplier=1,\n     task_reject_on_worker_lost=True,\n-    \n     # Beat schedule for periodic tasks\n     beat_schedule={\n         # Cleanup old notifications every day at 2 AM\n         \"cleanup-old-notifications\": {\n             \"task\": \"tasks.cleanup_tasks.cleanup_old_notifications\",\n             \"schedule\": crontab(hour=2, minute=0),\n         },\n-        \n         # Process scheduled notifications every minute\n         \"process-scheduled-notifications\": {\n             \"task\": \"tasks.notification_tasks.process_scheduled_notifications\",\n             \"schedule\": crontab(minute=\"*\"),\n         },\n-        \n         # Update notification statistics every 15 minutes\n         \"update-notification-stats\": {\n             \"task\": \"tasks.monitoring_tasks.update_notification_statistics\",\n             \"schedule\": crontab(minute=\"*/15\"),\n         },\n-        \n         # Health check for notification providers every 5 minutes\n         \"provider-health-check\": {\n             \"task\": \"tasks.monitoring_tasks.check_provider_health\",\n             \"schedule\": crontab(minute=\"*/5\"),\n         },\n-        \n         # Clear template cache every hour\n         \"clear-template-cache\": {\n             \"task\": \"tasks.template_tasks.clear_expired_cache\",\n             \"schedule\": crontab(minute=0),\n         },\n     },\n )\n \n+\n # Error handling\n @celery_app.task(bind=True)\n def debug_task(self):\n     \"\"\"Debug task for testing Celery configuration\"\"\"\n     print(f\"Request: {self.request!r}\")\n     return \"Celery is working!\"\n \n+\n # Task failure handler\n @celery_app.task(bind=True)\n def handle_task_failure(self, task_id, error, traceback):\n     \"\"\"Handle task failures\"\"\"\n     logger.error(f\"Task {task_id} failed: {error}\")\n     logger.error(f\"Traceback: {traceback}\")\n-    \n+\n     # Could send alert notification here\n     # Could update failure statistics\n     # Could trigger retry logic\n \n+\n if __name__ == \"__main__\":\n-    celery_app.start()\n\\ No newline at end of file\n+    celery_app.start()\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/database.py\t2025-09-09 13:29:10.547932+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/database.py\t2025-09-10 11:37:01.165222+00:00\n@@ -1,9 +1,10 @@\n \"\"\"\n Database configuration and session management for Communication Service\n Sync PostgreSQL pattern using psycopg2-binary\n \"\"\"\n+\n import os\n from contextlib import contextmanager\n from sqlalchemy import create_engine, event\n from sqlalchemy.orm import sessionmaker, Session\n from sqlalchemy.pool import QueuePool\n@@ -11,79 +12,82 @@\n \n from models import Base\n \n logger = logging.getLogger(__name__)\n \n+\n class DatabaseConfig:\n     \"\"\"Database configuration and connection management\"\"\"\n-    \n+\n     def __init__(self):\n         self.database_url = self._get_database_url()\n         self.engine = self._create_engine()\n         self.session_maker = sessionmaker(bind=self.engine)\n-    \n+\n     def _get_database_url(self) -> str:\n         \"\"\"Get database URL from environment variables\"\"\"\n         database_url = os.getenv(\"DATABASE_URL\")\n         if not database_url:\n             # Fallback to component parts\n             host = os.getenv(\"DATABASE_HOST\", \"localhost\")\n             port = os.getenv(\"DATABASE_PORT\", \"5435\")\n             user = os.getenv(\"DATABASE_USER\", \"comm_user\")\n             password = os.getenv(\"DATABASE_PASSWORD\", \"comm_pass\")\n             database = os.getenv(\"DATABASE_NAME\", \"communication_service\")\n-            \n+\n             database_url = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n-        \n+\n         logger.info(f\"Database URL configured: {database_url.split('@')[0]}@...\")\n         return database_url\n-    \n+\n     def _create_engine(self):\n         \"\"\"Create SQLAlchemy engine with connection pooling\"\"\"\n         pool_size = int(os.getenv(\"DATABASE_POOL_SIZE\", \"10\"))\n         max_overflow = int(os.getenv(\"DATABASE_MAX_OVERFLOW\", \"20\"))\n         pool_timeout = int(os.getenv(\"DATABASE_POOL_TIMEOUT\", \"30\"))\n         pool_recycle = int(os.getenv(\"DATABASE_POOL_RECYCLE\", \"3600\"))\n-        \n+\n         engine = create_engine(\n             self.database_url,\n             poolclass=QueuePool,\n             pool_size=pool_size,\n             max_overflow=max_overflow,\n             pool_timeout=pool_timeout,\n             pool_recycle=pool_recycle,\n             pool_pre_ping=True,  # Validate connections before use\n             echo=os.getenv(\"DEBUG\") == \"true\",  # SQL logging in debug mode\n         )\n-        \n+\n         # Add connection event listeners\n         @event.listens_for(engine, \"connect\")\n         def set_sqlite_pragma(dbapi_connection, connection_record):\n             \"\"\"Set connection-level settings (PostgreSQL specific)\"\"\"\n             pass\n-        \n+\n         @event.listens_for(engine, \"checkout\")\n         def receive_checkout(dbapi_connection, connection_record, connection_proxy):\n             \"\"\"Log connection checkout in debug mode\"\"\"\n             if os.getenv(\"DEBUG\") == \"true\":\n                 logger.debug(\"Connection checked out from pool\")\n-        \n-        logger.info(f\"Database engine created with pool_size={pool_size}, max_overflow={max_overflow}\")\n+\n+        logger.info(\n+            f\"Database engine created with pool_size={pool_size}, max_overflow={max_overflow}\"\n+        )\n         return engine\n-    \n+\n     def create_tables(self):\n         \"\"\"Create all database tables\"\"\"\n         logger.info(\"Creating database tables...\")\n         Base.metadata.create_all(bind=self.engine)\n         logger.info(\"Database tables created successfully\")\n-    \n+\n     def drop_tables(self):\n         \"\"\"Drop all database tables (use with caution!)\"\"\"\n         logger.warning(\"Dropping all database tables...\")\n         Base.metadata.drop_all(bind=self.engine)\n         logger.warning(\"Database tables dropped\")\n-    \n+\n     @contextmanager\n     def get_session(self):\n         \"\"\"Get a database session with proper cleanup\"\"\"\n         session = self.session_maker()\n         try:\n@@ -93,15 +97,15 @@\n             logger.error(f\"Database session error: {e}\")\n             session.rollback()\n             raise\n         finally:\n             session.close()\n-    \n+\n     def get_session_direct(self) -> Session:\n         \"\"\"Get a database session for direct use (remember to close!)\"\"\"\n         return self.session_maker()\n-    \n+\n     def health_check(self) -> bool:\n         \"\"\"Check database connectivity\"\"\"\n         try:\n             with self.get_session() as session:\n                 session.execute(\"SELECT 1\")\n@@ -111,10 +115,11 @@\n             return False\n \n \n # Global database configuration instance\n db_config = DatabaseConfig()\n+\n \n # Convenience functions for use in FastAPI dependencies\n def get_db_session():\n     \"\"\"FastAPI dependency to get database session\"\"\"\n     session = db_config.get_session_direct()\n@@ -125,105 +130,119 @@\n         session.rollback()\n         raise\n     finally:\n         session.close()\n \n+\n @contextmanager\n def get_db():\n     \"\"\"Context manager for database sessions\"\"\"\n     with db_config.get_session() as session:\n         yield session\n \n+\n def init_database():\n     \"\"\"Initialize database tables and default data\"\"\"\n     from models import create_default_categories\n-    \n+\n     logger.info(\"Initializing database...\")\n-    \n+\n     # Create tables\n     db_config.create_tables()\n-    \n+\n     # Create default notification categories\n     with get_db() as session:\n         # Check if categories already exist\n         from models import NotificationCategory\n+\n         existing_categories = session.query(NotificationCategory).count()\n-        \n+\n         if existing_categories == 0:\n             logger.info(\"Creating default notification categories...\")\n             default_categories = create_default_categories()\n             for category in default_categories:\n                 session.add(category)\n             session.commit()\n             logger.info(f\"Created {len(default_categories)} default categories\")\n         else:\n-            logger.info(f\"Found {existing_categories} existing categories, skipping creation\")\n-    \n+            logger.info(\n+                f\"Found {existing_categories} existing categories, skipping creation\"\n+            )\n+\n     logger.info(\"Database initialization complete\")\n+\n \n def reset_database():\n     \"\"\"Reset database (drop and recreate all tables)\"\"\"\n     logger.warning(\"Resetting database - all data will be lost!\")\n     db_config.drop_tables()\n     init_database()\n     logger.info(\"Database reset complete\")\n \n+\n # Database utilities\n class DatabaseUtils:\n     \"\"\"Utility functions for database operations\"\"\"\n-    \n+\n     @staticmethod\n     def get_table_counts() -> dict:\n         \"\"\"Get row counts for all tables\"\"\"\n         from models import (\n-            NotificationCategory, NotificationTemplate, Notification,\n-            NotificationPreference, Conversation, ConversationParticipant, Message\n+            NotificationCategory,\n+            NotificationTemplate,\n+            Notification,\n+            NotificationPreference,\n+            Conversation,\n+            ConversationParticipant,\n+            Message,\n         )\n-        \n+\n         models = {\n             \"categories\": NotificationCategory,\n             \"templates\": NotificationTemplate,\n             \"notifications\": Notification,\n             \"preferences\": NotificationPreference,\n             \"conversations\": Conversation,\n             \"participants\": ConversationParticipant,\n             \"messages\": Message,\n         }\n-        \n+\n         counts = {}\n         with get_db() as session:\n             for name, model in models.items():\n                 counts[name] = session.query(model).count()\n-        \n+\n         return counts\n-    \n+\n     @staticmethod\n     def cleanup_old_notifications(days: int = 30):\n         \"\"\"Clean up old notifications older than specified days\"\"\"\n         from datetime import datetime, timedelta\n         from models import Notification\n-        \n+\n         cutoff_date = datetime.utcnow() - timedelta(days=days)\n-        \n+\n         with get_db() as session:\n-            deleted_count = session.query(Notification)\\\n-                .filter(Notification.created_at < cutoff_date)\\\n-                .filter(Notification.status.in_([\"delivered\", \"failed\"]))\\\n+            deleted_count = (\n+                session.query(Notification)\n+                .filter(Notification.created_at < cutoff_date)\n+                .filter(Notification.status.in_([\"delivered\", \"failed\"]))\n                 .delete()\n-            \n+            )\n+\n             session.commit()\n             logger.info(f\"Cleaned up {deleted_count} old notifications\")\n             return deleted_count\n-    \n+\n     @staticmethod\n     def get_database_stats() -> dict:\n         \"\"\"Get comprehensive database statistics\"\"\"\n         stats = {\n             \"table_counts\": DatabaseUtils.get_table_counts(),\n             \"connection_info\": {\n                 \"pool_size\": db_config.engine.pool.size(),\n                 \"checked_out_connections\": db_config.engine.pool.checkedout(),\n                 \"overflow_connections\": db_config.engine.pool.overflow(),\n                 \"checked_in_connections\": db_config.engine.pool.checkedin(),\n-            }\n+            },\n         }\n-        return stats\n\\ No newline at end of file\n+        return stats\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/__init__.py\t2025-09-09 13:31:23.169692+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/__init__.py\t2025-09-10 11:37:01.173017+00:00\n@@ -1 +1 @@\n-# Tests package for Communication Service\n\\ No newline at end of file\n+# Tests package for Communication Service\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/providers/base.py\t2025-09-09 14:20:27.059996+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/providers/base.py\t2025-09-10 11:37:01.189187+00:00\n@@ -1,19 +1,21 @@\n \"\"\"\n Base Notification Provider Classes\n Abstract interfaces for multi-channel notification delivery\n \"\"\"\n+\n from abc import ABC, abstractmethod\n from dataclasses import dataclass\n from datetime import datetime\n from enum import Enum\n from typing import Dict, List, Optional, Any\n import uuid\n \n \n class NotificationStatus(Enum):\n     \"\"\"Notification delivery status\"\"\"\n+\n     PENDING = \"pending\"\n     QUEUED = \"queued\"\n     SENDING = \"sending\"\n     SENT = \"sent\"\n     DELIVERED = \"delivered\"\n@@ -23,10 +25,11 @@\n \n \n @dataclass\n class NotificationResult:\n     \"\"\"Result of notification delivery attempt\"\"\"\n+\n     id: str\n     status: NotificationStatus\n     provider_id: Optional[str] = None\n     provider_response: Optional[Dict[str, Any]] = None\n     error_message: Optional[str] = None\n@@ -43,10 +46,11 @@\n \n \n @dataclass\n class NotificationPayload:\n     \"\"\"Generic notification payload\"\"\"\n+\n     recipient: str\n     subject: Optional[str] = None\n     content: str = \"\"\n     template_id: Optional[str] = None\n     template_data: Optional[Dict[str, Any]] = None\n@@ -63,11 +67,11 @@\n     \"\"\"\n \n     def __init__(self, config: Dict[str, Any]):\n         \"\"\"\n         Initialize provider with configuration\n-        \n+\n         Args:\n             config: Provider-specific configuration dict\n         \"\"\"\n         self.config = config\n         self.provider_name = self.__class__.__name__\n@@ -78,82 +82,82 @@\n \n     @abstractmethod\n     async def send(self, payload: NotificationPayload) -> NotificationResult:\n         \"\"\"\n         Send notification using this provider\n-        \n+\n         Args:\n             payload: Notification data to send\n-            \n+\n         Returns:\n             NotificationResult with delivery status and details\n         \"\"\"\n         pass\n \n     @abstractmethod\n     async def get_delivery_status(self, notification_id: str) -> NotificationStatus:\n         \"\"\"\n         Get current delivery status of a notification\n-        \n+\n         Args:\n             notification_id: ID of notification to check\n-            \n+\n         Returns:\n             Current NotificationStatus\n         \"\"\"\n         pass\n \n     @abstractmethod\n     async def cancel_notification(self, notification_id: str) -> bool:\n         \"\"\"\n         Cancel a pending/scheduled notification\n-        \n+\n         Args:\n             notification_id: ID of notification to cancel\n-            \n+\n         Returns:\n             True if successfully cancelled\n         \"\"\"\n         pass\n \n     async def health_check(self) -> bool:\n         \"\"\"\n         Check if provider is healthy and can send notifications\n-        \n+\n         Returns:\n             True if provider is operational\n         \"\"\"\n         return self.is_enabled\n \n     async def validate_recipient(self, recipient: str) -> bool:\n         \"\"\"\n         Validate if recipient address/number is valid for this provider\n-        \n+\n         Args:\n             recipient: Recipient address to validate\n-            \n+\n         Returns:\n             True if recipient is valid\n         \"\"\"\n         return bool(recipient and recipient.strip())\n \n     async def estimate_cost(self, payload: NotificationPayload) -> Optional[float]:\n         \"\"\"\n         Estimate cost for sending this notification\n-        \n+\n         Args:\n             payload: Notification payload\n-            \n+\n         Returns:\n             Estimated cost in USD, or None if not available\n         \"\"\"\n         return None\n \n     def get_provider_info(self) -> Dict[str, Any]:\n         \"\"\"\n         Get provider information and capabilities\n-        \n+\n         Returns:\n             Dict with provider details\n         \"\"\"\n         return {\n             \"name\": self.provider_name,\n@@ -174,78 +178,86 @@\n     \"\"\"\n \n     def __init__(self, providers: List[NotificationProvider], max_retries: int = 3):\n         \"\"\"\n         Initialize with list of providers in priority order\n-        \n+\n         Args:\n             providers: List of providers to try in order\n             max_retries: Maximum retry attempts across all providers\n         \"\"\"\n         self.providers = providers\n         self.max_retries = max_retries\n \n     async def send(self, payload: NotificationPayload) -> NotificationResult:\n         \"\"\"\n         Send notification with failover logic\n-        \n+\n         Args:\n             payload: Notification payload to send\n-            \n+\n         Returns:\n             NotificationResult from successful provider or last failure\n         \"\"\"\n         last_result = None\n-        \n+\n         for attempt in range(self.max_retries):\n             for provider in self.providers:\n                 if not provider.is_enabled:\n                     continue\n-                    \n+\n                 try:\n                     # Check provider health before sending\n                     if not await provider.health_check():\n                         continue\n-                    \n+\n                     # Validate recipient for this provider\n                     if not await provider.validate_recipient(payload.recipient):\n                         continue\n-                    \n+\n                     # Attempt to send\n                     result = await provider.send(payload)\n-                    \n+\n                     # Return on success\n-                    if result.status in [NotificationStatus.SENT, NotificationStatus.QUEUED]:\n+                    if result.status in [\n+                        NotificationStatus.SENT,\n+                        NotificationStatus.QUEUED,\n+                    ]:\n                         return result\n-                    \n+\n                     last_result = result\n-                    \n+\n                 except Exception as e:\n                     last_result = NotificationResult(\n                         id=str(uuid.uuid4()),\n                         status=NotificationStatus.FAILED,\n                         error_message=f\"{provider.provider_name}: {str(e)}\",\n-                        metadata={\"attempt\": attempt + 1, \"provider\": provider.provider_name}\n+                        metadata={\n+                            \"attempt\": attempt + 1,\n+                            \"provider\": provider.provider_name,\n+                        },\n                     )\n \n         # All providers failed\n         return last_result or NotificationResult(\n             id=str(uuid.uuid4()),\n             status=NotificationStatus.FAILED,\n-            error_message=\"All providers failed\"\n+            error_message=\"All providers failed\",\n         )\n \n \n class LoadBalancingProvider:\n     \"\"\"\n     Load balancing provider that distributes notifications across multiple providers\n     \"\"\"\n \n-    def __init__(self, providers: List[NotificationProvider], strategy: str = \"round_robin\"):\n+    def __init__(\n+        self, providers: List[NotificationProvider], strategy: str = \"round_robin\"\n+    ):\n         \"\"\"\n         Initialize with providers and load balancing strategy\n-        \n+\n         Args:\n             providers: List of providers to distribute load across\n             strategy: Load balancing strategy (round_robin, random, weighted)\n         \"\"\"\n         self.providers = [p for p in providers if p.is_enabled]\n@@ -254,30 +266,31 @@\n \n     def _select_provider(self) -> NotificationProvider:\n         \"\"\"Select next provider based on strategy\"\"\"\n         if not self.providers:\n             raise ValueError(\"No enabled providers available\")\n-        \n+\n         if self.strategy == \"round_robin\":\n             provider = self.providers[self.current_index]\n             self.current_index = (self.current_index + 1) % len(self.providers)\n             return provider\n-        \n+\n         elif self.strategy == \"random\":\n             import random\n+\n             return random.choice(self.providers)\n-        \n+\n         else:  # Default to first available\n             return self.providers[0]\n \n     async def send(self, payload: NotificationPayload) -> NotificationResult:\n         \"\"\"\n         Send notification using load balancing\n-        \n+\n         Args:\n             payload: Notification payload to send\n-            \n+\n         Returns:\n             NotificationResult from selected provider\n         \"\"\"\n         provider = self._select_provider()\n-        return await provider.send(payload)\n\\ No newline at end of file\n+        return await provider.send(payload)\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tasks/template_tasks.py\t2025-09-09 14:28:33.837042+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tasks/template_tasks.py\t2025-09-10 11:37:01.315001+00:00\n@@ -1,9 +1,10 @@\n \"\"\"\n Template Processing Celery Tasks\n Background tasks for template rendering and management\n \"\"\"\n+\n import asyncio\n from datetime import datetime, timedelta\n from typing import Dict, Any, Optional, List\n import uuid\n import logging\n@@ -16,312 +17,306 @@\n logger = logging.getLogger(__name__)\n \n \n @celery_app.task(bind=True, max_retries=2, default_retry_delay=30)\n def render_template(\n-    self,\n-    template_id: str,\n-    variables: Dict[str, Any],\n-    channel: Optional[str] = None\n+    self, template_id: str, variables: Dict[str, Any], channel: Optional[str] = None\n ):\n     \"\"\"\n     Render template with variables in background\n-    \n+\n     Args:\n         template_id: UUID of template to render\n         variables: Template variables\n         channel: Optional notification channel\n-        \n+\n     Returns:\n         Dict with rendered subject and content\n     \"\"\"\n     try:\n         channel_enum = NotificationChannel(channel) if channel else None\n-        \n-        result = asyncio.run(template_engine.render_template(\n-            template_id,\n-            variables,\n-            channel_enum\n-        ))\n-        \n+\n+        result = asyncio.run(\n+            template_engine.render_template(template_id, variables, channel_enum)\n+        )\n+\n         return {\n             \"template_id\": template_id,\n             \"channel\": channel,\n             \"subject\": result[\"subject\"],\n             \"content\": result[\"content\"],\n-            \"rendered_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+            \"rendered_at\": datetime.utcnow().isoformat(),\n+        }\n+\n     except Exception as exc:\n         logger.error(f\"Template rendering failed: {exc}\")\n-        \n+\n         if self.request.retries < self.max_retries:\n             raise self.retry(exc=exc, countdown=30)\n-        \n+\n         raise\n \n \n @celery_app.task\n def validate_template(template_content: str, subject: str = \"\"):\n     \"\"\"\n     Validate template syntax in background\n-    \n+\n     Args:\n         template_content: Template content to validate\n         subject: Subject template to validate\n-        \n+\n     Returns:\n         Dict with validation results\n     \"\"\"\n     try:\n-        result = asyncio.run(template_engine.validate_template_syntax(\n-            template_content,\n-            subject\n-        ))\n-        \n+        result = asyncio.run(\n+            template_engine.validate_template_syntax(template_content, subject)\n+        )\n+\n         return {\n             \"valid\": result[\"valid\"],\n             \"errors\": result[\"errors\"],\n             \"warnings\": result[\"warnings\"],\n-            \"validated_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+            \"validated_at\": datetime.utcnow().isoformat(),\n+        }\n+\n     except Exception as exc:\n         logger.error(f\"Template validation failed: {exc}\")\n         return {\n             \"valid\": False,\n             \"errors\": [str(exc)],\n             \"warnings\": [],\n-            \"validated_at\": datetime.utcnow().isoformat()\n+            \"validated_at\": datetime.utcnow().isoformat(),\n         }\n \n \n @celery_app.task\n def render_template_preview(\n     template_content: str,\n     subject: str,\n     variables: Dict[str, Any],\n-    channel: Optional[str] = None\n+    channel: Optional[str] = None,\n ):\n     \"\"\"\n     Render template preview in background\n-    \n+\n     Args:\n         template_content: Template content string\n         subject: Subject template string\n         variables: Template variables\n         channel: Optional notification channel\n-        \n+\n     Returns:\n         Dict with rendered preview\n     \"\"\"\n     try:\n         channel_enum = NotificationChannel(channel) if channel else None\n-        \n-        result = asyncio.run(template_engine.preview_template(\n-            template_content,\n-            subject,\n-            variables,\n-            channel_enum\n-        ))\n-        \n+\n+        result = asyncio.run(\n+            template_engine.preview_template(\n+                template_content, subject, variables, channel_enum\n+            )\n+        )\n+\n         return {\n             \"subject\": result[\"subject\"],\n             \"content\": result[\"content\"],\n             \"channel\": channel,\n-            \"previewed_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+            \"previewed_at\": datetime.utcnow().isoformat(),\n+        }\n+\n     except Exception as exc:\n         logger.error(f\"Template preview failed: {exc}\")\n         return {\n             \"subject\": \"\",\n             \"content\": f\"Preview failed: {str(exc)}\",\n             \"channel\": channel,\n             \"previewed_at\": datetime.utcnow().isoformat(),\n-            \"error\": str(exc)\n+            \"error\": str(exc),\n         }\n \n \n @celery_app.task\n def batch_render_templates(templates_data: List[Dict[str, Any]]):\n     \"\"\"\n     Render multiple templates in batch\n-    \n+\n     Args:\n         templates_data: List of dicts with keys: template_id, variables, channel\n-        \n+\n     Returns:\n         List of rendered template results\n     \"\"\"\n     try:\n         results = []\n-        \n+\n         for template_data in templates_data:\n             try:\n                 result = render_template.apply_async(\n                     args=(\n                         template_data[\"template_id\"],\n                         template_data.get(\"variables\", {}),\n-                        template_data.get(\"channel\")\n+                        template_data.get(\"channel\"),\n                     )\n                 )\n-                \n-                results.append({\n-                    \"template_id\": template_data[\"template_id\"],\n-                    \"task_id\": result.id,\n-                    \"status\": \"queued\"\n-                })\n-                \n+\n+                results.append(\n+                    {\n+                        \"template_id\": template_data[\"template_id\"],\n+                        \"task_id\": result.id,\n+                        \"status\": \"queued\",\n+                    }\n+                )\n+\n             except Exception as e:\n-                results.append({\n-                    \"template_id\": template_data.get(\"template_id\", \"unknown\"),\n-                    \"status\": \"failed\",\n-                    \"error\": str(e)\n-                })\n-        \n+                results.append(\n+                    {\n+                        \"template_id\": template_data.get(\"template_id\", \"unknown\"),\n+                        \"status\": \"failed\",\n+                        \"error\": str(e),\n+                    }\n+                )\n+\n         return {\n             \"total_templates\": len(templates_data),\n             \"results\": results,\n-            \"batch_created_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+            \"batch_created_at\": datetime.utcnow().isoformat(),\n+        }\n+\n     except Exception as exc:\n         logger.error(f\"Batch template rendering failed: {exc}\")\n         raise\n \n \n @celery_app.task\n def clear_expired_cache():\n     \"\"\"Clear expired template cache entries\"\"\"\n     try:\n         result = asyncio.run(template_engine.clear_cache())\n-        \n-        return {\n-            \"status\": \"completed\",\n-            \"cleared_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+\n+        return {\"status\": \"completed\", \"cleared_at\": datetime.utcnow().isoformat()}\n+\n     except Exception as exc:\n         logger.error(f\"Cache clearing failed: {exc}\")\n         raise\n \n \n @celery_app.task\n def warm_template_cache(template_ids: List[str], sample_variables: Dict[str, Any]):\n     \"\"\"\n     Warm template cache with sample data\n-    \n+\n     Args:\n         template_ids: List of template IDs to warm up\n         sample_variables: Sample variables to use for rendering\n     \"\"\"\n     try:\n         warmed_count = 0\n         errors = []\n-        \n+\n         for template_id in template_ids:\n             try:\n                 # Render template for each channel to warm cache\n                 for channel in [\"email\", \"sms\", \"push\", \"in_app\"]:\n                     render_template.apply_async(\n                         args=(template_id, sample_variables, channel)\n                     )\n-                \n+\n                 warmed_count += 1\n-                \n+\n             except Exception as e:\n-                errors.append({\n-                    \"template_id\": template_id,\n-                    \"error\": str(e)\n-                })\n-        \n+                errors.append({\"template_id\": template_id, \"error\": str(e)})\n+\n         return {\n             \"templates_processed\": warmed_count,\n             \"errors\": errors,\n-            \"warmed_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+            \"warmed_at\": datetime.utcnow().isoformat(),\n+        }\n+\n     except Exception as exc:\n         logger.error(f\"Cache warming failed: {exc}\")\n         raise\n \n \n @celery_app.task\n def extract_template_variables(template_content: str):\n     \"\"\"\n     Extract variables from template content\n-    \n+\n     Args:\n         template_content: Template content to analyze\n-        \n+\n     Returns:\n         List of variable names found in template\n     \"\"\"\n     try:\n-        variables = asyncio.run(template_engine.get_template_variables(template_content))\n-        \n+        variables = asyncio.run(\n+            template_engine.get_template_variables(template_content)\n+        )\n+\n         return {\n             \"variables\": variables,\n             \"variable_count\": len(variables),\n-            \"extracted_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+            \"extracted_at\": datetime.utcnow().isoformat(),\n+        }\n+\n     except Exception as exc:\n         logger.error(f\"Variable extraction failed: {exc}\")\n         return {\n             \"variables\": [],\n             \"variable_count\": 0,\n             \"extracted_at\": datetime.utcnow().isoformat(),\n-            \"error\": str(exc)\n+            \"error\": str(exc),\n         }\n \n \n @celery_app.task\n def optimize_template_performance():\n     \"\"\"Optimize template performance by analyzing usage patterns\"\"\"\n     try:\n         # This would analyze template usage patterns and optimize caching\n         # Placeholder for future implementation\n-        \n+\n         return {\n             \"status\": \"completed\",\n             \"optimizations_applied\": [],\n-            \"optimized_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+            \"optimized_at\": datetime.utcnow().isoformat(),\n+        }\n+\n     except Exception as exc:\n         logger.error(f\"Template optimization failed: {exc}\")\n         raise\n \n \n @celery_app.task\n def generate_template_usage_report():\n     \"\"\"Generate template usage statistics\"\"\"\n     try:\n+\n         async def get_template_stats():\n             try:\n                 redis_client = await get_redis_client()\n-                \n+\n                 # Get cache statistics\n                 cache_keys = await redis_client.keys(\"template_cache:*\")\n                 cache_stats = {\n                     \"total_cached_templates\": len(cache_keys),\n                     \"cache_hit_rate\": 0.0,  # Would need to track hits/misses\n                 }\n-                \n+\n                 return cache_stats\n-                \n+\n             except Exception as e:\n                 logger.error(f\"Failed to get template stats: {e}\")\n                 return {}\n-        \n+\n         stats = asyncio.run(get_template_stats())\n-        \n+\n         return {\n             \"cache_statistics\": stats,\n-            \"report_generated_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+            \"report_generated_at\": datetime.utcnow().isoformat(),\n+        }\n+\n     except Exception as exc:\n         logger.error(f\"Template usage report failed: {exc}\")\n-        raise\n\\ No newline at end of file\n+        raise\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tasks/cleanup_tasks.py\t2025-09-09 14:29:12.014304+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tasks/cleanup_tasks.py\t2025-09-10 11:37:01.382729+00:00\n@@ -1,9 +1,10 @@\n \"\"\"\n Cleanup and Maintenance Celery Tasks\n Background tasks for database and cache maintenance\n \"\"\"\n+\n import asyncio\n from datetime import datetime, timedelta\n from typing import Dict, Any, Optional\n import logging\n \n@@ -16,320 +17,320 @@\n \n @celery_app.task(bind=True)\n def cleanup_old_notifications(self, retention_days: int = 30):\n     \"\"\"\n     Clean up old notifications from database\n-    \n+\n     Args:\n         retention_days: Number of days to retain notifications (default: 30)\n     \"\"\"\n     try:\n         cutoff_date = datetime.utcnow() - timedelta(days=retention_days)\n-        \n+\n         async def perform_cleanup():\n             async with get_db_session() as session:\n                 # Delete old read notifications\n                 read_result = await session.execute(\n                     \"\"\"\n                     DELETE FROM notifications \n                     WHERE created_at < :cutoff_date \n                     AND is_read = true \n                     AND status IN ('delivered', 'sent')\n                     \"\"\",\n-                    {\"cutoff_date\": cutoff_date}\n-                )\n-                \n+                    {\"cutoff_date\": cutoff_date},\n+                )\n+\n                 # Delete very old unread notifications (90 days)\n                 old_cutoff_date = datetime.utcnow() - timedelta(days=90)\n                 unread_result = await session.execute(\n                     \"\"\"\n                     DELETE FROM notifications \n                     WHERE created_at < :old_cutoff_date\n                     \"\"\",\n-                    {\"old_cutoff_date\": old_cutoff_date}\n-                )\n-                \n+                    {\"old_cutoff_date\": old_cutoff_date},\n+                )\n+\n                 await session.commit()\n-                \n+\n                 return {\n                     \"deleted_read\": read_result.rowcount,\n-                    \"deleted_unread\": unread_result.rowcount\n+                    \"deleted_unread\": unread_result.rowcount,\n                 }\n-        \n+\n         result = asyncio.run(perform_cleanup())\n-        \n-        logger.info(f\"Cleaned up {result['deleted_read']} read and {result['deleted_unread']} old unread notifications\")\n-        \n+\n+        logger.info(\n+            f\"Cleaned up {result['deleted_read']} read and {result['deleted_unread']} old unread notifications\"\n+        )\n+\n         return {\n             \"status\": \"completed\",\n             \"deleted_read_notifications\": result[\"deleted_read\"],\n             \"deleted_unread_notifications\": result[\"deleted_unread\"],\n             \"retention_days\": retention_days,\n-            \"cleaned_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+            \"cleaned_at\": datetime.utcnow().isoformat(),\n+        }\n+\n     except Exception as exc:\n         logger.error(f\"Notification cleanup failed: {exc}\")\n         raise\n \n \n @celery_app.task(bind=True)\n def cleanup_failed_notifications(self, max_age_hours: int = 24):\n     \"\"\"\n     Clean up failed notifications older than specified hours\n-    \n+\n     Args:\n         max_age_hours: Maximum age in hours for failed notifications (default: 24)\n     \"\"\"\n     try:\n         cutoff_date = datetime.utcnow() - timedelta(hours=max_age_hours)\n-        \n+\n         async def perform_cleanup():\n             async with get_db_session() as session:\n                 result = await session.execute(\n                     \"\"\"\n                     DELETE FROM notifications \n                     WHERE status = 'failed' \n                     AND updated_at < :cutoff_date\n                     \"\"\",\n-                    {\"cutoff_date\": cutoff_date}\n-                )\n-                \n+                    {\"cutoff_date\": cutoff_date},\n+                )\n+\n                 await session.commit()\n                 return result.rowcount\n-        \n+\n         deleted_count = asyncio.run(perform_cleanup())\n-        \n+\n         logger.info(f\"Cleaned up {deleted_count} failed notifications\")\n-        \n+\n         return {\n             \"status\": \"completed\",\n             \"deleted_failed_notifications\": deleted_count,\n             \"max_age_hours\": max_age_hours,\n-            \"cleaned_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+            \"cleaned_at\": datetime.utcnow().isoformat(),\n+        }\n+\n     except Exception as exc:\n         logger.error(f\"Failed notification cleanup failed: {exc}\")\n         raise\n \n \n @celery_app.task(bind=True)\n def cleanup_expired_cache(self):\n     \"\"\"Clean up expired cache entries\"\"\"\n     try:\n+\n         async def perform_cleanup():\n             redis_client = await get_redis_client()\n-            \n+\n             # Get all cache keys\n             cache_patterns = [\n                 \"template_cache:*\",\n                 \"notification_cache:*\",\n-                \"user_preferences:*\"\n+                \"user_preferences:*\",\n             ]\n-            \n+\n             total_cleaned = 0\n-            \n+\n             for pattern in cache_patterns:\n                 keys = await redis_client.keys(pattern)\n-                \n+\n                 # Check TTL and delete expired keys\n                 for key in keys:\n                     ttl = await redis_client.ttl(key)\n                     if ttl == -2:  # Key doesn't exist\n                         continue\n                     elif ttl == -1:  # Key exists but no expiration\n                         # Set a default expiration (24 hours) for keys without TTL\n                         await redis_client.expire(key, 86400)\n-                \n-                total_cleaned += len([k for k in keys if await redis_client.ttl(k) == -2])\n-            \n+\n+                total_cleaned += len(\n+                    [k for k in keys if await redis_client.ttl(k) == -2]\n+                )\n+\n             return total_cleaned\n-        \n+\n         cleaned_count = asyncio.run(perform_cleanup())\n-        \n+\n         return {\n             \"status\": \"completed\",\n             \"cleaned_cache_entries\": cleaned_count,\n-            \"cleaned_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+            \"cleaned_at\": datetime.utcnow().isoformat(),\n+        }\n+\n     except Exception as exc:\n         logger.error(f\"Cache cleanup failed: {exc}\")\n         raise\n \n \n @celery_app.task(bind=True)\n def cleanup_old_templates(self, retention_days: int = 365):\n     \"\"\"\n     Clean up old inactive template versions\n-    \n+\n     Args:\n         retention_days: Days to retain inactive templates (default: 365)\n     \"\"\"\n     try:\n         cutoff_date = datetime.utcnow() - timedelta(days=retention_days)\n-        \n+\n         async def perform_cleanup():\n             async with get_db_session() as session:\n                 # Delete old inactive template versions\n                 result = await session.execute(\n                     \"\"\"\n                     DELETE FROM notification_templates \n                     WHERE is_active = false \n                     AND updated_at < :cutoff_date\n                     \"\"\",\n-                    {\"cutoff_date\": cutoff_date}\n-                )\n-                \n+                    {\"cutoff_date\": cutoff_date},\n+                )\n+\n                 await session.commit()\n                 return result.rowcount\n-        \n+\n         deleted_count = asyncio.run(perform_cleanup())\n-        \n+\n         logger.info(f\"Cleaned up {deleted_count} old template versions\")\n-        \n+\n         return {\n             \"status\": \"completed\",\n             \"deleted_templates\": deleted_count,\n             \"retention_days\": retention_days,\n-            \"cleaned_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+            \"cleaned_at\": datetime.utcnow().isoformat(),\n+        }\n+\n     except Exception as exc:\n         logger.error(f\"Template cleanup failed: {exc}\")\n         raise\n \n \n @celery_app.task(bind=True)\n def optimize_database(self):\n     \"\"\"Optimize database performance\"\"\"\n     try:\n+\n         async def perform_optimization():\n             async with get_db_session() as session:\n                 # Analyze table statistics\n                 await session.execute(\"ANALYZE notifications\")\n                 await session.execute(\"ANALYZE notification_templates\")\n                 await session.execute(\"ANALYZE notification_categories\")\n-                \n+\n                 # Vacuum if using PostgreSQL\n                 # Note: VACUUM cannot run inside a transaction\n                 # This would need to be handled differently in production\n-                \n+\n                 return True\n-        \n+\n         asyncio.run(perform_optimization())\n-        \n-        return {\n-            \"status\": \"completed\",\n-            \"optimized_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+\n+        return {\"status\": \"completed\", \"optimized_at\": datetime.utcnow().isoformat()}\n+\n     except Exception as exc:\n         logger.error(f\"Database optimization failed: {exc}\")\n         raise\n \n \n @celery_app.task(bind=True)\n def cleanup_celery_results(self, max_age_hours: int = 24):\n     \"\"\"\n     Clean up old Celery task results\n-    \n+\n     Args:\n         max_age_hours: Maximum age in hours for task results (default: 24)\n     \"\"\"\n     try:\n+\n         async def perform_cleanup():\n             redis_client = await get_redis_client()\n-            \n+\n             # Get all celery result keys\n             result_keys = await redis_client.keys(\"celery-task-meta-*\")\n-            \n+\n             cleaned_count = 0\n-            cutoff_timestamp = (datetime.utcnow() - timedelta(hours=max_age_hours)).timestamp()\n-            \n+            cutoff_timestamp = (\n+                datetime.utcnow() - timedelta(hours=max_age_hours)\n+            ).timestamp()\n+\n             for key in result_keys:\n                 # Check if result is old\n                 result_data = await redis_client.get(key)\n                 if result_data:\n                     try:\n                         import json\n+\n                         data = json.loads(result_data)\n-                        \n+\n                         # Check date_done timestamp\n                         if data.get(\"date_done\"):\n-                            date_done = datetime.fromisoformat(data[\"date_done\"].replace(\"Z\", \"+00:00\"))\n+                            date_done = datetime.fromisoformat(\n+                                data[\"date_done\"].replace(\"Z\", \"+00:00\")\n+                            )\n                             if date_done.timestamp() < cutoff_timestamp:\n                                 await redis_client.delete(key)\n                                 cleaned_count += 1\n                     except (json.JSONDecodeError, ValueError):\n                         # Delete malformed results\n                         await redis_client.delete(key)\n                         cleaned_count += 1\n-            \n+\n             return cleaned_count\n-        \n+\n         cleaned_count = asyncio.run(perform_cleanup())\n-        \n+\n         return {\n             \"status\": \"completed\",\n             \"cleaned_results\": cleaned_count,\n             \"max_age_hours\": max_age_hours,\n-            \"cleaned_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+            \"cleaned_at\": datetime.utcnow().isoformat(),\n+        }\n+\n     except Exception as exc:\n         logger.error(f\"Celery results cleanup failed: {exc}\")\n         raise\n \n \n @celery_app.task(bind=True)\n def comprehensive_cleanup(self):\n     \"\"\"Run all cleanup tasks in sequence\"\"\"\n     try:\n         results = {}\n-        \n+\n         # Run individual cleanup tasks\n         tasks = [\n             (\"notifications\", cleanup_old_notifications.apply_async()),\n             (\"failed_notifications\", cleanup_failed_notifications.apply_async()),\n             (\"expired_cache\", cleanup_expired_cache.apply_async()),\n             (\"old_templates\", cleanup_old_templates.apply_async()),\n             (\"celery_results\", cleanup_celery_results.apply_async()),\n         ]\n-        \n+\n         # Wait for all tasks to complete\n         for task_name, task_result in tasks:\n             try:\n                 result = task_result.get(timeout=300)  # 5 minute timeout\n-                results[task_name] = {\n-                    \"status\": \"completed\",\n-                    \"result\": result\n-                }\n+                results[task_name] = {\"status\": \"completed\", \"result\": result}\n             except Exception as e:\n-                results[task_name] = {\n-                    \"status\": \"failed\",\n-                    \"error\": str(e)\n-                }\n-        \n+                results[task_name] = {\"status\": \"failed\", \"error\": str(e)}\n+\n         # Run database optimization last\n         try:\n             optimization_result = optimize_database.apply_async().get(timeout=300)\n             results[\"database_optimization\"] = {\n                 \"status\": \"completed\",\n-                \"result\": optimization_result\n+                \"result\": optimization_result,\n             }\n         except Exception as e:\n-            results[\"database_optimization\"] = {\n-                \"status\": \"failed\",\n-                \"error\": str(e)\n-            }\n-        \n+            results[\"database_optimization\"] = {\"status\": \"failed\", \"error\": str(e)}\n+\n         return {\n             \"status\": \"completed\",\n             \"individual_results\": results,\n-            \"completed_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+            \"completed_at\": datetime.utcnow().isoformat(),\n+        }\n+\n     except Exception as exc:\n         logger.error(f\"Comprehensive cleanup failed: {exc}\")\n-        raise\n\\ No newline at end of file\n+        raise\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/providers/sms.py\t2025-09-09 14:22:47.310684+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/providers/sms.py\t2025-09-10 11:37:01.377540+00:00\n@@ -1,285 +1,297 @@\n \"\"\"\n SMS Notification Providers\n Twilio and other SMS delivery implementations\n \"\"\"\n+\n import asyncio\n import re\n from datetime import datetime\n from typing import Dict, Any, Optional\n import httpx\n import logging\n \n-from .base import NotificationProvider, NotificationPayload, NotificationResult, NotificationStatus\n+from .base import (\n+    NotificationProvider,\n+    NotificationPayload,\n+    NotificationResult,\n+    NotificationStatus,\n+)\n \n logger = logging.getLogger(__name__)\n \n \n class SMSProvider(NotificationProvider):\n     \"\"\"Base class for SMS notification providers\"\"\"\n-    \n+\n     def __init__(self, config: Dict[str, Any]):\n         super().__init__(config)\n         self.from_number = config.get(\"from_number\", \"+1234567890\")\n         self.max_message_length = config.get(\"max_message_length\", 160)\n         self.enable_unicode = config.get(\"enable_unicode\", True)\n-        \n+\n     def get_provider_info(self) -> Dict[str, Any]:\n         info = super().get_provider_info()\n-        info.update({\n-            \"supports_unicode\": self.enable_unicode,\n-            \"max_content_length\": self.max_message_length,\n-            \"from_number\": self.from_number,\n-        })\n+        info.update(\n+            {\n+                \"supports_unicode\": self.enable_unicode,\n+                \"max_content_length\": self.max_message_length,\n+                \"from_number\": self.from_number,\n+            }\n+        )\n         return info\n-    \n+\n     async def validate_recipient(self, recipient: str) -> bool:\n         \"\"\"Validate phone number format\"\"\"\n         # Basic phone number validation (E.164 format)\n-        phone_pattern = r'^\\+[1-9]\\d{1,14}$'\n+        phone_pattern = r\"^\\+[1-9]\\d{1,14}$\"\n         return bool(re.match(phone_pattern, recipient))\n-    \n+\n     def format_phone_number(self, phone: str) -> str:\n         \"\"\"Format phone number to E.164 format\"\"\"\n         # Remove all non-digit characters except +\n-        cleaned = re.sub(r'[^\\d+]', '', phone)\n-        \n+        cleaned = re.sub(r\"[^\\d+]\", \"\", phone)\n+\n         # Add + if not present\n-        if not cleaned.startswith('+'):\n-            cleaned = '+' + cleaned\n-            \n+        if not cleaned.startswith(\"+\"):\n+            cleaned = \"+\" + cleaned\n+\n         return cleaned\n-    \n+\n     def truncate_message(self, content: str, max_length: int = None) -> str:\n         \"\"\"Truncate message to fit SMS length limits\"\"\"\n         max_len = max_length or self.max_message_length\n-        \n+\n         if len(content) <= max_len:\n             return content\n-            \n+\n         # Truncate and add ellipsis\n-        return content[:max_len-3] + \"...\"\n+        return content[: max_len - 3] + \"...\"\n \n \n class TwilioProvider(SMSProvider):\n     \"\"\"Twilio SMS provider\"\"\"\n-    \n+\n     def __init__(self, config: Dict[str, Any]):\n         super().__init__(config)\n         self.account_sid = config.get(\"account_sid\")\n         self.auth_token = config.get(\"auth_token\")\n         self.base_url = f\"https://api.twilio.com/2010-04-01/Accounts/{self.account_sid}\"\n-        \n+\n         if not self.account_sid or not self.auth_token:\n             raise ValueError(\"Twilio account_sid and auth_token are required\")\n-    \n+\n     async def send(self, payload: NotificationPayload) -> NotificationResult:\n         \"\"\"Send SMS via Twilio API\"\"\"\n         try:\n             # Format and validate phone number\n             recipient = self.format_phone_number(payload.recipient)\n             if not await self.validate_recipient(recipient):\n                 return NotificationResult(\n                     id=\"\",\n                     status=NotificationStatus.REJECTED,\n-                    error_message=f\"Invalid phone number: {payload.recipient}\"\n+                    error_message=f\"Invalid phone number: {payload.recipient}\",\n                 )\n-            \n+\n             # Prepare message content\n             content = self.truncate_message(payload.content)\n-            \n+\n             # Twilio API request\n             url = f\"{self.base_url}/Messages.json\"\n-            data = {\n-                \"From\": self.from_number,\n-                \"To\": recipient,\n-                \"Body\": content\n-            }\n-            \n+            data = {\"From\": self.from_number, \"To\": recipient, \"Body\": content}\n+\n             # Add media URLs if present (MMS)\n             media_urls = []\n             if payload.metadata:\n                 media_urls = payload.metadata.get(\"media_urls\", [])\n                 if media_urls:\n                     data[\"MediaUrl\"] = media_urls\n-            \n+\n             # Make API request\n             async with httpx.AsyncClient(timeout=self.timeout_seconds) as client:\n                 auth = (self.account_sid, self.auth_token)\n                 response = await client.post(url, data=data, auth=auth)\n-                \n+\n                 if response.status_code == 201:\n                     response_data = response.json()\n                     return NotificationResult(\n                         id=response_data.get(\"sid\", \"\"),\n                         status=NotificationStatus.QUEUED,\n                         provider_id=self.provider_name,\n                         provider_response=response_data,\n                         sent_at=datetime.utcnow(),\n-                        cost=float(response_data.get(\"price\", 0)) if response_data.get(\"price\") else None,\n+                        cost=(\n+                            float(response_data.get(\"price\", 0))\n+                            if response_data.get(\"price\")\n+                            else None\n+                        ),\n                         metadata={\n                             \"twilio_sid\": response_data.get(\"sid\"),\n                             \"to\": recipient,\n                             \"from\": self.from_number,\n                             \"body\": content,\n-                            \"num_segments\": response_data.get(\"num_segments\", 1)\n-                        }\n+                            \"num_segments\": response_data.get(\"num_segments\", 1),\n+                        },\n                     )\n                 else:\n-                    error_data = response.json() if response.headers.get(\"content-type\", \"\").startswith(\"application/json\") else {\"error\": response.text}\n+                    error_data = (\n+                        response.json()\n+                        if response.headers.get(\"content-type\", \"\").startswith(\n+                            \"application/json\"\n+                        )\n+                        else {\"error\": response.text}\n+                    )\n                     return NotificationResult(\n                         id=\"\",\n                         status=NotificationStatus.FAILED,\n-                        error_message=error_data.get(\"message\", f\"HTTP {response.status_code}\"),\n-                        provider_response=error_data\n+                        error_message=error_data.get(\n+                            \"message\", f\"HTTP {response.status_code}\"\n+                        ),\n+                        provider_response=error_data,\n                     )\n-                    \n+\n         except httpx.TimeoutException:\n             return NotificationResult(\n-                id=\"\",\n-                status=NotificationStatus.FAILED,\n-                error_message=\"Request timeout\"\n+                id=\"\", status=NotificationStatus.FAILED, error_message=\"Request timeout\"\n             )\n         except Exception as e:\n             logger.error(f\"Twilio send failed: {str(e)}\")\n             return NotificationResult(\n-                id=\"\",\n-                status=NotificationStatus.FAILED,\n-                error_message=str(e)\n+                id=\"\", status=NotificationStatus.FAILED, error_message=str(e)\n             )\n-    \n+\n     async def get_delivery_status(self, notification_id: str) -> NotificationStatus:\n         \"\"\"Get SMS delivery status from Twilio\"\"\"\n         try:\n             url = f\"{self.base_url}/Messages/{notification_id}.json\"\n-            \n+\n             async with httpx.AsyncClient(timeout=10) as client:\n                 auth = (self.account_sid, self.auth_token)\n                 response = await client.get(url, auth=auth)\n-                \n+\n                 if response.status_code == 200:\n                     data = response.json()\n                     twilio_status = data.get(\"status\", \"unknown\")\n-                    \n+\n                     # Map Twilio statuses to our enum\n                     status_mapping = {\n                         \"queued\": NotificationStatus.QUEUED,\n                         \"sending\": NotificationStatus.SENDING,\n                         \"sent\": NotificationStatus.SENT,\n                         \"delivered\": NotificationStatus.DELIVERED,\n                         \"failed\": NotificationStatus.FAILED,\n                         \"undelivered\": NotificationStatus.FAILED,\n                         \"canceled\": NotificationStatus.CANCELLED,\n                     }\n-                    \n+\n                     return status_mapping.get(twilio_status, NotificationStatus.FAILED)\n                 else:\n                     return NotificationStatus.FAILED\n-                    \n+\n         except Exception as e:\n             logger.error(f\"Failed to get Twilio status for {notification_id}: {e}\")\n             return NotificationStatus.FAILED\n-    \n+\n     async def cancel_notification(self, notification_id: str) -> bool:\n         \"\"\"Cancel SMS in Twilio (only works for scheduled messages)\"\"\"\n         try:\n             url = f\"{self.base_url}/Messages/{notification_id}.json\"\n             data = {\"Status\": \"canceled\"}\n-            \n+\n             async with httpx.AsyncClient(timeout=10) as client:\n                 auth = (self.account_sid, self.auth_token)\n                 response = await client.post(url, data=data, auth=auth)\n                 return response.status_code == 200\n-                \n+\n         except Exception as e:\n             logger.error(f\"Failed to cancel Twilio message {notification_id}: {e}\")\n             return False\n-    \n+\n     async def health_check(self) -> bool:\n         \"\"\"Check Twilio API connectivity\"\"\"\n         if not self.is_enabled:\n             return False\n-            \n+\n         try:\n             # Test API connectivity by fetching account info\n             url = f\"https://api.twilio.com/2010-04-01/Accounts/{self.account_sid}.json\"\n-            \n+\n             async with httpx.AsyncClient(timeout=5) as client:\n                 auth = (self.account_sid, self.auth_token)\n                 response = await client.get(url, auth=auth)\n                 return response.status_code == 200\n-                \n+\n         except Exception as e:\n             logger.warning(f\"Twilio health check failed: {e}\")\n             return False\n-    \n+\n     async def estimate_cost(self, payload: NotificationPayload) -> Optional[float]:\n         \"\"\"Estimate SMS cost based on content length and destination\"\"\"\n         # Basic cost estimation (would need to be more sophisticated in production)\n         content_length = len(payload.content)\n         segments = (content_length // 160) + (1 if content_length % 160 > 0 else 0)\n-        \n+\n         # Basic US SMS pricing (actual pricing varies by destination)\n         base_cost_per_segment = 0.0075  # $0.0075 per segment\n-        \n+\n         return segments * base_cost_per_segment\n \n \n class AWSSNSProvider(SMSProvider):\n     \"\"\"AWS SNS SMS provider (placeholder for future implementation)\"\"\"\n-    \n+\n     def __init__(self, config: Dict[str, Any]):\n         super().__init__(config)\n         self.aws_access_key = config.get(\"aws_access_key_id\")\n         self.aws_secret_key = config.get(\"aws_secret_access_key\")\n         self.region = config.get(\"region\", \"us-east-1\")\n-    \n+\n     async def send(self, payload: NotificationPayload) -> NotificationResult:\n         \"\"\"Send SMS via AWS SNS\"\"\"\n         # TODO: Implement AWS SNS integration\n         return NotificationResult(\n             id=\"\",\n             status=NotificationStatus.FAILED,\n-            error_message=\"AWS SNS provider not implemented yet\"\n+            error_message=\"AWS SNS provider not implemented yet\",\n         )\n-    \n+\n     async def get_delivery_status(self, notification_id: str) -> NotificationStatus:\n         \"\"\"Get delivery status from AWS SNS\"\"\"\n         # TODO: Implement SNS delivery status\n         return NotificationStatus.SENT\n-    \n+\n     async def cancel_notification(self, notification_id: str) -> bool:\n         \"\"\"Cancel SMS in AWS SNS\"\"\"\n         # TODO: Implement SNS cancellation\n         return False\n \n \n class OVHSMSProvider(SMSProvider):\n     \"\"\"OVH SMS provider for European markets (placeholder)\"\"\"\n-    \n+\n     def __init__(self, config: Dict[str, Any]):\n         super().__init__(config)\n         self.application_key = config.get(\"application_key\")\n         self.application_secret = config.get(\"application_secret\")\n         self.consumer_key = config.get(\"consumer_key\")\n         self.service_name = config.get(\"service_name\")\n         self.endpoint = config.get(\"endpoint\", \"ovh-eu\")\n-    \n+\n     async def send(self, payload: NotificationPayload) -> NotificationResult:\n         \"\"\"Send SMS via OVH API\"\"\"\n         # TODO: Implement OVH SMS API integration\n         return NotificationResult(\n             id=\"\",\n             status=NotificationStatus.FAILED,\n-            error_message=\"OVH SMS provider not implemented yet\"\n+            error_message=\"OVH SMS provider not implemented yet\",\n         )\n-    \n+\n     async def get_delivery_status(self, notification_id: str) -> NotificationStatus:\n         \"\"\"Get delivery status from OVH\"\"\"\n         # TODO: Implement OVH delivery status\n         return NotificationStatus.SENT\n-    \n+\n     async def cancel_notification(self, notification_id: str) -> bool:\n         \"\"\"Cancel SMS in OVH\"\"\"\n         # TODO: Implement OVH cancellation\n         return False\n \n@@ -290,11 +302,11 @@\n     providers = {\n         \"twilio\": TwilioProvider,\n         \"aws_sns\": AWSSNSProvider,\n         \"ovh\": OVHSMSProvider,\n     }\n-    \n+\n     provider_class = providers.get(provider_type.lower())\n     if not provider_class:\n         raise ValueError(f\"Unknown SMS provider type: {provider_type}\")\n-    \n-    return provider_class(config)\n\\ No newline at end of file\n+\n+    return provider_class(config)\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/providers/email.py\t2025-09-09 14:21:43.848438+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/providers/email.py\t2025-09-10 11:37:01.386115+00:00\n@@ -1,9 +1,10 @@\n \"\"\"\n Email Notification Providers\n SMTP and email delivery implementations\n \"\"\"\n+\n import asyncio\n import smtplib\n import ssl\n from email.mime.text import MIMEText\n from email.mime.multipart import MIMEMultipart\n@@ -12,282 +13,295 @@\n from datetime import datetime\n from typing import Dict, Any, Optional, List\n import aiosmtplib\n import logging\n \n-from .base import NotificationProvider, NotificationPayload, NotificationResult, NotificationStatus\n+from .base import (\n+    NotificationProvider,\n+    NotificationPayload,\n+    NotificationResult,\n+    NotificationStatus,\n+)\n \n logger = logging.getLogger(__name__)\n \n \n class EmailProvider(NotificationProvider):\n     \"\"\"Base class for email notification providers\"\"\"\n-    \n+\n     def __init__(self, config: Dict[str, Any]):\n         super().__init__(config)\n         self.from_email = config.get(\"from_email\", \"noreply@example.com\")\n         self.from_name = config.get(\"from_name\", \"Communication Service\")\n         self.reply_to = config.get(\"reply_to\")\n         self.max_content_length = config.get(\"max_content_length\", 1000000)  # 1MB\n-        \n+\n     def get_provider_info(self) -> Dict[str, Any]:\n         info = super().get_provider_info()\n-        info.update({\n-            \"supports_html\": True,\n-            \"supports_attachments\": True,\n-            \"supports_delivery_receipts\": True,\n-            \"max_content_length\": self.max_content_length,\n-            \"from_email\": self.from_email,\n-        })\n+        info.update(\n+            {\n+                \"supports_html\": True,\n+                \"supports_attachments\": True,\n+                \"supports_delivery_receipts\": True,\n+                \"max_content_length\": self.max_content_length,\n+                \"from_email\": self.from_email,\n+            }\n+        )\n         return info\n-    \n+\n     async def validate_recipient(self, recipient: str) -> bool:\n         \"\"\"Validate email address format\"\"\"\n         import re\n-        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n+\n+        email_pattern = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n         return bool(re.match(email_pattern, recipient))\n \n \n class SMTPProvider(EmailProvider):\n     \"\"\"SMTP-based email provider\"\"\"\n-    \n+\n     def __init__(self, config: Dict[str, Any]):\n         super().__init__(config)\n         self.smtp_host = config.get(\"smtp_host\", \"localhost\")\n         self.smtp_port = config.get(\"smtp_port\", 587)\n         self.smtp_username = config.get(\"smtp_username\")\n         self.smtp_password = config.get(\"smtp_password\")\n         self.use_tls = config.get(\"use_tls\", True)\n         self.use_ssl = config.get(\"use_ssl\", False)\n-        \n+\n     async def send(self, payload: NotificationPayload) -> NotificationResult:\n         \"\"\"Send email via SMTP\"\"\"\n         try:\n             # Validate recipient\n             if not await self.validate_recipient(payload.recipient):\n                 return NotificationResult(\n                     id=\"\",\n                     status=NotificationStatus.REJECTED,\n-                    error_message=f\"Invalid email address: {payload.recipient}\"\n+                    error_message=f\"Invalid email address: {payload.recipient}\",\n                 )\n-            \n+\n             # Create email message\n             message = await self._create_message(payload)\n-            \n+\n             # Send email\n             result = await self._send_smtp(message, payload.recipient)\n             return result\n-            \n+\n         except Exception as e:\n             logger.error(f\"SMTP send failed: {str(e)}\")\n             return NotificationResult(\n-                id=\"\",\n-                status=NotificationStatus.FAILED,\n-                error_message=str(e)\n-            )\n-    \n+                id=\"\", status=NotificationStatus.FAILED, error_message=str(e)\n+            )\n+\n     async def _create_message(self, payload: NotificationPayload) -> MIMEMultipart:\n         \"\"\"Create email message from payload\"\"\"\n         message = MIMEMultipart(\"alternative\")\n-        \n+\n         # Headers\n         message[\"From\"] = f\"{self.from_name} <{self.from_email}>\"\n         message[\"To\"] = payload.recipient\n         message[\"Subject\"] = payload.subject or \"Notification\"\n-        \n+\n         if self.reply_to:\n             message[\"Reply-To\"] = self.reply_to\n-            \n+\n         # Add message ID for tracking\n         message_id = f\"<{payload.metadata.get('id', 'unknown')}@{self.smtp_host}>\"\n         message[\"Message-ID\"] = message_id\n-        \n+\n         # Content - support both plain text and HTML\n         if payload.metadata and payload.metadata.get(\"content_type\") == \"html\":\n             # HTML content\n             html_part = MIMEText(payload.content, \"html\", \"utf-8\")\n             message.attach(html_part)\n-            \n+\n             # Also include plain text version\n             plain_content = self._html_to_text(payload.content)\n             text_part = MIMEText(plain_content, \"plain\", \"utf-8\")\n             message.attach(text_part)\n         else:\n             # Plain text content\n             text_part = MIMEText(payload.content, \"plain\", \"utf-8\")\n             message.attach(text_part)\n-        \n+\n         # Add attachments if present\n-        attachments = payload.metadata.get(\"attachments\", []) if payload.metadata else []\n+        attachments = (\n+            payload.metadata.get(\"attachments\", []) if payload.metadata else []\n+        )\n         for attachment in attachments:\n             await self._add_attachment(message, attachment)\n-        \n+\n         return message\n-    \n+\n     def _html_to_text(self, html_content: str) -> str:\n         \"\"\"Convert HTML to plain text (basic implementation)\"\"\"\n         import re\n+\n         # Remove HTML tags\n-        text = re.sub(r'<[^>]+>', '', html_content)\n+        text = re.sub(r\"<[^>]+>\", \"\", html_content)\n         # Decode HTML entities\n-        text = text.replace('&nbsp;', ' ').replace('&amp;', '&').replace('&lt;', '<').replace('&gt;', '>')\n+        text = (\n+            text.replace(\"&nbsp;\", \" \")\n+            .replace(\"&amp;\", \"&\")\n+            .replace(\"&lt;\", \"<\")\n+            .replace(\"&gt;\", \">\")\n+        )\n         return text.strip()\n-    \n+\n     async def _add_attachment(self, message: MIMEMultipart, attachment: Dict[str, Any]):\n         \"\"\"Add attachment to email message\"\"\"\n         try:\n             filename = attachment.get(\"filename\", \"attachment\")\n             content = attachment.get(\"content\", b\"\")\n             content_type = attachment.get(\"content_type\", \"application/octet-stream\")\n-            \n+\n             part = MIMEBase(*content_type.split(\"/\"))\n             part.set_payload(content)\n             encoders.encode_base64(part)\n-            part.add_header(\n-                \"Content-Disposition\",\n-                f\"attachment; filename= {filename}\"\n-            )\n+            part.add_header(\"Content-Disposition\", f\"attachment; filename= {filename}\")\n             message.attach(part)\n         except Exception as e:\n-            logger.warning(f\"Failed to add attachment {attachment.get('filename', 'unknown')}: {e}\")\n-    \n-    async def _send_smtp(self, message: MIMEMultipart, recipient: str) -> NotificationResult:\n+            logger.warning(\n+                f\"Failed to add attachment {attachment.get('filename', 'unknown')}: {e}\"\n+            )\n+\n+    async def _send_smtp(\n+        self, message: MIMEMultipart, recipient: str\n+    ) -> NotificationResult:\n         \"\"\"Send email via SMTP using aiosmtplib\"\"\"\n         try:\n             # Configure SMTP connection\n             smtp_kwargs = {\n                 \"hostname\": self.smtp_host,\n                 \"port\": self.smtp_port,\n                 \"timeout\": self.timeout_seconds,\n             }\n-            \n+\n             if self.use_ssl:\n                 smtp_kwargs[\"use_tls\"] = True\n                 smtp_kwargs[\"tls_context\"] = ssl.create_default_context()\n             elif self.use_tls:\n                 smtp_kwargs[\"start_tls\"] = True\n                 smtp_kwargs[\"tls_context\"] = ssl.create_default_context()\n-            \n+\n             # Send email\n             async with aiosmtplib.SMTP(**smtp_kwargs) as smtp:\n                 if self.smtp_username and self.smtp_password:\n                     await smtp.login(self.smtp_username, self.smtp_password)\n-                \n+\n                 await smtp.send_message(message, recipients=[recipient])\n-            \n+\n             return NotificationResult(\n                 id=message[\"Message-ID\"].strip(\"<>\"),\n                 status=NotificationStatus.SENT,\n                 provider_id=self.provider_name,\n                 sent_at=datetime.utcnow(),\n                 metadata={\n                     \"smtp_host\": self.smtp_host,\n                     \"recipient\": recipient,\n-                    \"subject\": message[\"Subject\"]\n-                }\n-            )\n-            \n+                    \"subject\": message[\"Subject\"],\n+                },\n+            )\n+\n         except aiosmtplib.SMTPException as e:\n             logger.error(f\"SMTP error sending to {recipient}: {e}\")\n             return NotificationResult(\n                 id=\"\",\n                 status=NotificationStatus.FAILED,\n-                error_message=f\"SMTP error: {str(e)}\"\n+                error_message=f\"SMTP error: {str(e)}\",\n             )\n         except Exception as e:\n             logger.error(f\"Unexpected error sending email to {recipient}: {e}\")\n             return NotificationResult(\n-                id=\"\",\n-                status=NotificationStatus.FAILED,\n-                error_message=str(e)\n-            )\n-    \n+                id=\"\", status=NotificationStatus.FAILED, error_message=str(e)\n+            )\n+\n     async def get_delivery_status(self, notification_id: str) -> NotificationStatus:\n         \"\"\"Get delivery status (basic implementation - SMTP doesn't provide detailed tracking)\"\"\"\n         # SMTP doesn't provide delivery receipts by default\n         # This would need to be implemented with bounce handling or external services\n         return NotificationStatus.SENT\n-    \n+\n     async def cancel_notification(self, notification_id: str) -> bool:\n         \"\"\"Cancel notification (not supported for SMTP after sending)\"\"\"\n         return False\n-    \n+\n     async def health_check(self) -> bool:\n         \"\"\"Check SMTP server connectivity\"\"\"\n         if not self.is_enabled:\n             return False\n-            \n+\n         try:\n             # Quick connection test\n             smtp_kwargs = {\n                 \"hostname\": self.smtp_host,\n                 \"port\": self.smtp_port,\n                 \"timeout\": 5,  # Short timeout for health check\n             }\n-            \n+\n             async with aiosmtplib.SMTP(**smtp_kwargs) as smtp:\n                 # Just test connection, don't authenticate\n                 pass\n-            \n+\n             return True\n-            \n+\n         except Exception as e:\n             logger.warning(f\"SMTP health check failed: {e}\")\n             return False\n \n \n class SendGridProvider(EmailProvider):\n     \"\"\"SendGrid email provider (placeholder for future implementation)\"\"\"\n-    \n+\n     def __init__(self, config: Dict[str, Any]):\n         super().__init__(config)\n         self.api_key = config.get(\"api_key\")\n         self.base_url = \"https://api.sendgrid.com/v3\"\n-    \n+\n     async def send(self, payload: NotificationPayload) -> NotificationResult:\n         \"\"\"Send email via SendGrid API\"\"\"\n         # TODO: Implement SendGrid API integration\n         return NotificationResult(\n             id=\"\",\n             status=NotificationStatus.FAILED,\n-            error_message=\"SendGrid provider not implemented yet\"\n-        )\n-    \n+            error_message=\"SendGrid provider not implemented yet\",\n+        )\n+\n     async def get_delivery_status(self, notification_id: str) -> NotificationStatus:\n         \"\"\"Get delivery status from SendGrid\"\"\"\n         # TODO: Implement SendGrid webhook handling\n         return NotificationStatus.SENT\n-    \n+\n     async def cancel_notification(self, notification_id: str) -> bool:\n         \"\"\"Cancel scheduled email in SendGrid\"\"\"\n         # TODO: Implement SendGrid cancellation\n         return False\n \n \n class MailgunProvider(EmailProvider):\n     \"\"\"Mailgun email provider (placeholder for future implementation)\"\"\"\n-    \n+\n     def __init__(self, config: Dict[str, Any]):\n         super().__init__(config)\n         self.api_key = config.get(\"api_key\")\n         self.domain = config.get(\"domain\")\n         self.base_url = f\"https://api.mailgun.net/v3/{self.domain}\"\n-    \n+\n     async def send(self, payload: NotificationPayload) -> NotificationResult:\n         \"\"\"Send email via Mailgun API\"\"\"\n         # TODO: Implement Mailgun API integration\n         return NotificationResult(\n             id=\"\",\n             status=NotificationStatus.FAILED,\n-            error_message=\"Mailgun provider not implemented yet\"\n-        )\n-    \n+            error_message=\"Mailgun provider not implemented yet\",\n+        )\n+\n     async def get_delivery_status(self, notification_id: str) -> NotificationStatus:\n         \"\"\"Get delivery status from Mailgun\"\"\"\n         # TODO: Implement Mailgun event tracking\n         return NotificationStatus.SENT\n-    \n+\n     async def cancel_notification(self, notification_id: str) -> bool:\n         \"\"\"Cancel scheduled email in Mailgun\"\"\"\n         # TODO: Implement Mailgun cancellation\n         return False\n \n@@ -298,11 +312,11 @@\n     providers = {\n         \"smtp\": SMTPProvider,\n         \"sendgrid\": SendGridProvider,\n         \"mailgun\": MailgunProvider,\n     }\n-    \n+\n     provider_class = providers.get(provider_type.lower())\n     if not provider_class:\n         raise ValueError(f\"Unknown email provider type: {provider_type}\")\n-    \n-    return provider_class(config)\n\\ No newline at end of file\n+\n+    return provider_class(config)\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/identity_client.py\t2025-09-09 13:30:58.984007+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/identity_client.py\t2025-09-10 11:37:01.443181+00:00\n@@ -1,9 +1,10 @@\n \"\"\"\n Identity Service client for Communication Service\n Handles authentication, user data retrieval, and service-to-service communication\n \"\"\"\n+\n import os\n import uuid\n from typing import Optional, Dict, Any, List\n from datetime import datetime, timedelta\n import httpx\n@@ -15,359 +16,378 @@\n \n from redis_client import cache_manager\n \n logger = logging.getLogger(__name__)\n \n+\n class IdentityServiceError(Exception):\n     \"\"\"Custom exception for Identity Service errors\"\"\"\n+\n     pass\n+\n \n class IdentityServiceClient:\n     \"\"\"Client for communicating with Identity Service\"\"\"\n-    \n+\n     def __init__(self):\n         self.base_url = os.getenv(\"IDENTITY_SERVICE_URL\", \"http://localhost:8001\")\n         self.service_name = \"communication-service\"\n         self.timeout = int(os.getenv(\"IDENTITY_SERVICE_TIMEOUT\", \"30\"))\n         self.retry_count = int(os.getenv(\"IDENTITY_SERVICE_RETRY_COUNT\", \"3\"))\n         self.cache_ttl = int(os.getenv(\"IDENTITY_CACHE_TTL\", \"300\"))  # 5 minutes\n-        \n+\n         # JWT configuration\n         self.jwt_secret = os.getenv(\"JWT_SECRET_KEY\")\n         self.jwt_algorithm = os.getenv(\"JWT_ALGORITHM\", \"HS256\")\n-        \n+\n         if not self.jwt_secret:\n             logger.warning(\"JWT_SECRET_KEY not set, JWT validation will fail\")\n-    \n+\n     async def _make_request(\n-        self, \n-        method: str, \n-        endpoint: str, \n+        self,\n+        method: str,\n+        endpoint: str,\n         data: Optional[Dict[str, Any]] = None,\n         headers: Optional[Dict[str, str]] = None,\n-        auth_token: Optional[str] = None\n+        auth_token: Optional[str] = None,\n     ) -> Dict[str, Any]:\n         \"\"\"Make HTTP request to Identity Service with retry logic\"\"\"\n         url = f\"{self.base_url}{endpoint}\"\n-        \n+\n         default_headers = {\n             \"Content-Type\": \"application/json\",\n             \"X-Service-Name\": self.service_name,\n-            \"X-Trace-ID\": str(uuid.uuid4())\n+            \"X-Trace-ID\": str(uuid.uuid4()),\n         }\n-        \n+\n         if headers:\n             default_headers.update(headers)\n-        \n+\n         if auth_token:\n             default_headers[\"Authorization\"] = f\"Bearer {auth_token}\"\n-        \n+\n         timeout = httpx.Timeout(self.timeout, connect=5.0)\n-        \n+\n         for attempt in range(self.retry_count):\n             try:\n                 async with httpx.AsyncClient(timeout=timeout) as client:\n                     response = await client.request(\n-                        method=method,\n-                        url=url,\n-                        json=data,\n-                        headers=default_headers\n+                        method=method, url=url, json=data, headers=default_headers\n                     )\n-                    \n+\n                     if response.status_code == 200:\n                         return response.json()\n                     elif response.status_code == 404:\n                         raise IdentityServiceError(f\"Resource not found: {endpoint}\")\n                     elif response.status_code == 401:\n                         raise IdentityServiceError(\"Authentication failed\")\n                     elif response.status_code == 403:\n                         raise IdentityServiceError(\"Authorization failed\")\n                     else:\n                         response.raise_for_status()\n-                        \n+\n             except httpx.TimeoutException:\n                 logger.warning(f\"Identity service timeout on attempt {attempt + 1}\")\n                 if attempt == self.retry_count - 1:\n                     raise IdentityServiceError(\"Identity service timeout\")\n-                await asyncio.sleep(2 ** attempt)  # Exponential backoff\n-                \n+                await asyncio.sleep(2**attempt)  # Exponential backoff\n+\n             except httpx.HTTPStatusError as e:\n                 logger.error(f\"Identity service HTTP error: {e.response.status_code}\")\n                 if e.response.status_code >= 400 and e.response.status_code < 500:\n                     # Client errors shouldn't be retried\n-                    raise IdentityServiceError(f\"Client error: {e.response.status_code}\")\n+                    raise IdentityServiceError(\n+                        f\"Client error: {e.response.status_code}\"\n+                    )\n                 elif attempt == self.retry_count - 1:\n-                    raise IdentityServiceError(f\"Server error: {e.response.status_code}\")\n-                await asyncio.sleep(2 ** attempt)\n-                \n+                    raise IdentityServiceError(\n+                        f\"Server error: {e.response.status_code}\"\n+                    )\n+                await asyncio.sleep(2**attempt)\n+\n             except Exception as e:\n                 logger.error(f\"Identity service request error: {e}\")\n                 if attempt == self.retry_count - 1:\n                     raise IdentityServiceError(f\"Request failed: {str(e)}\")\n-                await asyncio.sleep(2 ** attempt)\n-    \n+                await asyncio.sleep(2**attempt)\n+\n     def validate_jwt_token(self, token: str) -> Dict[str, Any]:\n         \"\"\"Validate JWT token locally (fast path)\"\"\"\n         try:\n             if not self.jwt_secret:\n                 raise IdentityServiceError(\"JWT secret not configured\")\n-            \n-            payload = jwt.decode(token, self.jwt_secret, algorithms=[self.jwt_algorithm])\n-            \n+\n+            payload = jwt.decode(\n+                token, self.jwt_secret, algorithms=[self.jwt_algorithm]\n+            )\n+\n             # Check expiration\n-            if payload.get('exp') and datetime.utcfromtimestamp(payload['exp']) < datetime.utcnow():\n+            if (\n+                payload.get(\"exp\")\n+                and datetime.utcfromtimestamp(payload[\"exp\"]) < datetime.utcnow()\n+            ):\n                 raise IdentityServiceError(\"Token expired\")\n-            \n+\n             return payload\n         except jwt.ExpiredSignatureError:\n             raise IdentityServiceError(\"Token expired\")\n         except jwt.InvalidTokenError:\n             raise IdentityServiceError(\"Invalid token\")\n-    \n+\n     async def validate_token(self, token: str) -> Dict[str, Any]:\n         \"\"\"Validate token with Identity Service (authoritative)\"\"\"\n         cache_key = f\"token:{token[:20]}\"  # Use token prefix as cache key\n-        \n+\n         # Try cache first\n         cached_user = cache_manager.get(cache_key)\n         if cached_user:\n             return cached_user\n-        \n+\n         try:\n             # Try local JWT validation first for speed\n             local_payload = self.validate_jwt_token(token)\n             user_data = {\n                 \"user_id\": local_payload.get(\"sub\"),\n                 \"email\": local_payload.get(\"email\"),\n                 \"roles\": local_payload.get(\"roles\", []),\n                 \"permissions\": local_payload.get(\"permissions\", []),\n                 \"organization_id\": local_payload.get(\"organization_id\"),\n-                \"validated_at\": datetime.utcnow().isoformat()\n+                \"validated_at\": datetime.utcnow().isoformat(),\n             }\n-            \n+\n             # Cache for short time\n             cache_manager.set(cache_key, user_data, ttl=self.cache_ttl)\n             return user_data\n-            \n+\n         except IdentityServiceError:\n             # Fall back to service validation\n             user_data = await self._make_request(\n-                \"POST\",\n-                \"/auth/validate\",\n-                headers={\"Authorization\": f\"Bearer {token}\"}\n-            )\n-            \n+                \"POST\", \"/auth/validate\", headers={\"Authorization\": f\"Bearer {token}\"}\n+            )\n+\n             # Cache validated user data\n             cache_manager.set(cache_key, user_data, ttl=self.cache_ttl)\n             return user_data\n-    \n+\n     async def get_user_profile(self, user_id: str, auth_token: str) -> Dict[str, Any]:\n         \"\"\"Get user profile information\"\"\"\n         cache_key = f\"profile:{user_id}\"\n-        \n+\n         # Try cache first\n         cached_profile = cache_manager.get(cache_key)\n         if cached_profile:\n             return cached_profile\n-        \n+\n         profile_data = await self._make_request(\n-            \"GET\",\n-            f\"/users/{user_id}/profile\",\n-            auth_token=auth_token\n+            \"GET\", f\"/users/{user_id}/profile\", auth_token=auth_token\n         )\n-        \n+\n         # Cache profile data\n-        cache_manager.set(cache_key, profile_data, ttl=self.cache_ttl * 2)  # Cache longer\n+        cache_manager.set(\n+            cache_key, profile_data, ttl=self.cache_ttl * 2\n+        )  # Cache longer\n         return profile_data\n-    \n-    async def get_user_contact_info(self, user_id: str, auth_token: str) -> Dict[str, Any]:\n+\n+    async def get_user_contact_info(\n+        self, user_id: str, auth_token: str\n+    ) -> Dict[str, Any]:\n         \"\"\"Get user contact information (email, phone)\"\"\"\n         cache_key = f\"contact:{user_id}\"\n-        \n+\n         cached_contact = cache_manager.get(cache_key)\n         if cached_contact:\n             return cached_contact\n-        \n+\n         contact_data = await self._make_request(\n-            \"GET\",\n-            f\"/users/{user_id}/contact\",\n-            auth_token=auth_token\n+            \"GET\", f\"/users/{user_id}/contact\", auth_token=auth_token\n         )\n-        \n+\n         cache_manager.set(cache_key, contact_data, ttl=self.cache_ttl)\n         return contact_data\n-    \n-    async def get_organization_users(self, organization_id: str, auth_token: str) -> List[Dict[str, Any]]:\n+\n+    async def get_organization_users(\n+        self, organization_id: str, auth_token: str\n+    ) -> List[Dict[str, Any]]:\n         \"\"\"Get all users in an organization\"\"\"\n         cache_key = f\"org_users:{organization_id}\"\n-        \n+\n         cached_users = cache_manager.get(cache_key)\n         if cached_users:\n             return cached_users\n-        \n+\n         users_data = await self._make_request(\n-            \"GET\",\n-            f\"/organizations/{organization_id}/users\",\n-            auth_token=auth_token\n+            \"GET\", f\"/organizations/{organization_id}/users\", auth_token=auth_token\n         )\n-        \n+\n         cache_manager.set(cache_key, users_data, ttl=self.cache_ttl)\n         return users_data\n-    \n+\n     async def check_user_permissions(\n-        self, \n-        user_id: str, \n-        required_permissions: List[str], \n-        auth_token: str\n+        self, user_id: str, required_permissions: List[str], auth_token: str\n     ) -> bool:\n         \"\"\"Check if user has required permissions\"\"\"\n         try:\n             user_data = await self.validate_token(auth_token)\n             user_permissions = user_data.get(\"permissions\", [])\n-            \n+\n             # Check if user has all required permissions\n             return all(perm in user_permissions for perm in required_permissions)\n         except Exception as e:\n             logger.error(f\"Permission check failed: {e}\")\n             return False\n-    \n+\n     async def get_user_roles(self, user_id: str, auth_token: str) -> List[str]:\n         \"\"\"Get user roles\"\"\"\n         try:\n             user_data = await self.validate_token(auth_token)\n             return user_data.get(\"roles\", [])\n         except Exception as e:\n             logger.error(f\"Failed to get user roles: {e}\")\n             return []\n-    \n+\n     async def invalidate_user_cache(self, user_id: str):\n         \"\"\"Invalidate all cached data for a user\"\"\"\n         cache_patterns = [\n             f\"profile:{user_id}\",\n             f\"contact:{user_id}\",\n-            f\"token:*\"  # This is broad but necessary for token cache invalidation\n+            f\"token:*\",  # This is broad but necessary for token cache invalidation\n         ]\n-        \n+\n         for pattern in cache_patterns:\n             if \"*\" in pattern:\n                 cache_manager.clear_pattern(pattern)\n             else:\n                 cache_manager.delete(pattern)\n-    \n+\n     async def health_check(self) -> bool:\n         \"\"\"Check if Identity Service is healthy\"\"\"\n         try:\n             await self._make_request(\"GET\", \"/health\")\n             return True\n         except Exception as e:\n             logger.error(f\"Identity service health check failed: {e}\")\n             return False\n \n+\n # Global identity service client\n identity_client = IdentityServiceClient()\n \n # FastAPI Security\n security = HTTPBearer()\n+\n \n async def get_current_user(token: str = Depends(security)) -> Dict[str, Any]:\n     \"\"\"FastAPI dependency to get current authenticated user\"\"\"\n     try:\n         user_data = await identity_client.validate_token(token.credentials)\n         return user_data\n     except IdentityServiceError as e:\n         raise HTTPException(status_code=401, detail=str(e))\n     except Exception as e:\n         logger.error(f\"Authentication error: {e}\")\n-        raise HTTPException(status_code=500, detail=\"Authentication service unavailable\")\n+        raise HTTPException(\n+            status_code=500, detail=\"Authentication service unavailable\"\n+        )\n+\n \n async def require_permissions(required_permissions: List[str]):\n     \"\"\"FastAPI dependency to require specific permissions\"\"\"\n+\n     def permission_checker(current_user: Dict[str, Any] = Depends(get_current_user)):\n         user_permissions = current_user.get(\"permissions\", [])\n-        \n-        missing_permissions = [perm for perm in required_permissions if perm not in user_permissions]\n+\n+        missing_permissions = [\n+            perm for perm in required_permissions if perm not in user_permissions\n+        ]\n         if missing_permissions:\n             raise HTTPException(\n-                status_code=403, \n-                detail=f\"Missing required permissions: {', '.join(missing_permissions)}\"\n-            )\n-        \n+                status_code=403,\n+                detail=f\"Missing required permissions: {', '.join(missing_permissions)}\",\n+            )\n+\n         return current_user\n-    \n+\n     return permission_checker\n+\n \n async def require_roles(required_roles: List[str]):\n     \"\"\"FastAPI dependency to require specific roles\"\"\"\n+\n     def role_checker(current_user: Dict[str, Any] = Depends(get_current_user)):\n         user_roles = current_user.get(\"roles\", [])\n-        \n+\n         # User needs at least one of the required roles\n         if not any(role in user_roles for role in required_roles):\n             raise HTTPException(\n                 status_code=403,\n-                detail=f\"Missing required roles: {', '.join(required_roles)}\"\n-            )\n-        \n+                detail=f\"Missing required roles: {', '.join(required_roles)}\",\n+            )\n+\n         return current_user\n-    \n+\n     return role_checker\n+\n \n class UserContactResolver:\n     \"\"\"Resolve user contact information for notifications\"\"\"\n-    \n+\n     def __init__(self, identity_client: IdentityServiceClient):\n         self.identity_client = identity_client\n-    \n+\n     async def get_email_address(self, user_id: str, auth_token: str) -> Optional[str]:\n         \"\"\"Get user's email address\"\"\"\n         try:\n-            contact_info = await self.identity_client.get_user_contact_info(user_id, auth_token)\n+            contact_info = await self.identity_client.get_user_contact_info(\n+                user_id, auth_token\n+            )\n             return contact_info.get(\"email\")\n         except Exception as e:\n             logger.error(f\"Failed to get email for user {user_id}: {e}\")\n             return None\n-    \n+\n     async def get_phone_number(self, user_id: str, auth_token: str) -> Optional[str]:\n         \"\"\"Get user's phone number\"\"\"\n         try:\n-            contact_info = await self.identity_client.get_user_contact_info(user_id, auth_token)\n+            contact_info = await self.identity_client.get_user_contact_info(\n+                user_id, auth_token\n+            )\n             return contact_info.get(\"phone\")\n         except Exception as e:\n             logger.error(f\"Failed to get phone for user {user_id}: {e}\")\n             return None\n-    \n+\n     async def get_push_tokens(self, user_id: str, auth_token: str) -> List[str]:\n         \"\"\"Get user's push notification tokens\"\"\"\n         try:\n-            contact_info = await self.identity_client.get_user_contact_info(user_id, auth_token)\n+            contact_info = await self.identity_client.get_user_contact_info(\n+                user_id, auth_token\n+            )\n             return contact_info.get(\"push_tokens\", [])\n         except Exception as e:\n             logger.error(f\"Failed to get push tokens for user {user_id}: {e}\")\n             return []\n-    \n+\n     async def resolve_recipients(\n-        self, \n-        user_ids: List[str], \n-        channel: str, \n-        auth_token: str\n+        self, user_ids: List[str], channel: str, auth_token: str\n     ) -> Dict[str, str]:\n         \"\"\"Resolve contact information for multiple users\"\"\"\n         recipients = {}\n-        \n+\n         for user_id in user_ids:\n             try:\n                 if channel == \"email\":\n                     contact = await self.get_email_address(user_id, auth_token)\n                 elif channel == \"sms\":\n                     contact = await self.get_phone_number(user_id, auth_token)\n                 else:\n                     contact = user_id  # For in-app notifications\n-                \n+\n                 if contact:\n                     recipients[user_id] = contact\n             except Exception as e:\n                 logger.error(f\"Failed to resolve contact for user {user_id}: {e}\")\n-        \n+\n         return recipients\n \n+\n # Global user contact resolver\n-user_contact_resolver = UserContactResolver(identity_client)\n\\ No newline at end of file\n+user_contact_resolver = UserContactResolver(identity_client)\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/providers/push.py\t2025-09-09 14:24:06.780436+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/providers/push.py\t2025-09-10 11:37:01.452669+00:00\n@@ -1,137 +1,151 @@\n \"\"\"\n Push Notification Providers\n Firebase, Apple Push Notification Service (APNS), and other push delivery implementations\n \"\"\"\n+\n import asyncio\n import json\n from datetime import datetime\n from typing import Dict, Any, Optional, List\n import httpx\n import jwt\n import time\n import logging\n \n-from .base import NotificationProvider, NotificationPayload, NotificationResult, NotificationStatus\n+from .base import (\n+    NotificationProvider,\n+    NotificationPayload,\n+    NotificationResult,\n+    NotificationStatus,\n+)\n \n logger = logging.getLogger(__name__)\n \n \n class PushProvider(NotificationProvider):\n     \"\"\"Base class for push notification providers\"\"\"\n-    \n+\n     def __init__(self, config: Dict[str, Any]):\n         super().__init__(config)\n         self.max_payload_size = config.get(\"max_payload_size\", 4096)  # 4KB default\n         self.supports_batching = config.get(\"supports_batching\", True)\n         self.max_batch_size = config.get(\"max_batch_size\", 500)\n-        \n+\n     def get_provider_info(self) -> Dict[str, Any]:\n         info = super().get_provider_info()\n-        info.update({\n-            \"supports_rich_content\": True,\n-            \"supports_actions\": True,\n-            \"supports_scheduling\": True,\n-            \"max_payload_size\": self.max_payload_size,\n-            \"supports_batching\": self.supports_batching,\n-            \"max_batch_size\": self.max_batch_size,\n-        })\n+        info.update(\n+            {\n+                \"supports_rich_content\": True,\n+                \"supports_actions\": True,\n+                \"supports_scheduling\": True,\n+                \"max_payload_size\": self.max_payload_size,\n+                \"supports_batching\": self.supports_batching,\n+                \"max_batch_size\": self.max_batch_size,\n+            }\n+        )\n         return info\n-    \n+\n     async def validate_recipient(self, recipient: str) -> bool:\n         \"\"\"Validate push token format\"\"\"\n         # Basic validation - token should be non-empty string\n         return bool(recipient and len(recipient.strip()) > 10)\n \n \n class FirebasePushProvider(PushProvider):\n     \"\"\"Firebase Cloud Messaging (FCM) push notification provider\"\"\"\n-    \n+\n     def __init__(self, config: Dict[str, Any]):\n         super().__init__(config)\n         self.project_id = config.get(\"project_id\")\n         self.private_key_id = config.get(\"private_key_id\")\n         self.private_key = config.get(\"private_key\", \"\").replace(\"\\\\n\", \"\\n\")\n         self.client_email = config.get(\"client_email\")\n         self.client_id = config.get(\"client_id\")\n-        self.auth_uri = config.get(\"auth_uri\", \"https://accounts.google.com/o/oauth2/auth\")\n+        self.auth_uri = config.get(\n+            \"auth_uri\", \"https://accounts.google.com/o/oauth2/auth\"\n+        )\n         self.token_uri = config.get(\"token_uri\", \"https://oauth2.googleapis.com/token\")\n-        \n-        self.fcm_endpoint = f\"https://fcm.googleapis.com/v1/projects/{self.project_id}/messages:send\"\n+\n+        self.fcm_endpoint = (\n+            f\"https://fcm.googleapis.com/v1/projects/{self.project_id}/messages:send\"\n+        )\n         self._access_token = None\n         self._token_expires_at = 0\n-        \n+\n         if not all([self.project_id, self.private_key, self.client_email]):\n-            raise ValueError(\"Firebase project_id, private_key, and client_email are required\")\n-    \n+            raise ValueError(\n+                \"Firebase project_id, private_key, and client_email are required\"\n+            )\n+\n     async def _get_access_token(self) -> str:\n         \"\"\"Get OAuth2 access token for FCM API\"\"\"\n         # Check if current token is still valid\n         if self._access_token and time.time() < self._token_expires_at - 60:\n             return self._access_token\n-        \n+\n         # Generate JWT for token request\n         now = int(time.time())\n         payload = {\n             \"iss\": self.client_email,\n             \"scope\": \"https://www.googleapis.com/auth/firebase.messaging\",\n             \"aud\": self.token_uri,\n             \"iat\": now,\n             \"exp\": now + 3600,\n         }\n-        \n+\n         # Create JWT\n         token = jwt.encode(payload, self.private_key, algorithm=\"RS256\")\n-        \n+\n         # Request access token\n         data = {\n             \"grant_type\": \"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n-            \"assertion\": token\n+            \"assertion\": token,\n         }\n-        \n+\n         async with httpx.AsyncClient(timeout=30) as client:\n             response = await client.post(self.token_uri, data=data)\n-            \n+\n             if response.status_code == 200:\n                 token_data = response.json()\n                 self._access_token = token_data[\"access_token\"]\n                 expires_in = token_data.get(\"expires_in\", 3600)\n                 self._token_expires_at = time.time() + expires_in\n                 return self._access_token\n             else:\n-                raise Exception(f\"Failed to get FCM access token: {response.status_code} {response.text}\")\n-    \n+                raise Exception(\n+                    f\"Failed to get FCM access token: {response.status_code} {response.text}\"\n+                )\n+\n     async def send(self, payload: NotificationPayload) -> NotificationResult:\n         \"\"\"Send push notification via FCM\"\"\"\n         try:\n             # Validate push token\n             if not await self.validate_recipient(payload.recipient):\n                 return NotificationResult(\n                     id=\"\",\n                     status=NotificationStatus.REJECTED,\n-                    error_message=f\"Invalid push token: {payload.recipient}\"\n+                    error_message=f\"Invalid push token: {payload.recipient}\",\n                 )\n-            \n+\n             # Get access token\n             access_token = await self._get_access_token()\n-            \n+\n             # Build FCM message\n             message = await self._build_fcm_message(payload)\n-            \n+\n             # Send to FCM\n             headers = {\n                 \"Authorization\": f\"Bearer {access_token}\",\n-                \"Content-Type\": \"application/json\"\n+                \"Content-Type\": \"application/json\",\n             }\n-            \n+\n             async with httpx.AsyncClient(timeout=self.timeout_seconds) as client:\n                 response = await client.post(\n-                    self.fcm_endpoint,\n-                    json={\"message\": message},\n-                    headers=headers\n+                    self.fcm_endpoint, json={\"message\": message}, headers=headers\n                 )\n-                \n+\n                 if response.status_code == 200:\n                     response_data = response.json()\n                     return NotificationResult(\n                         id=response_data.get(\"name\", \"\").split(\"/\")[-1],\n                         status=NotificationStatus.SENT,\n@@ -140,163 +154,175 @@\n                         sent_at=datetime.utcnow(),\n                         metadata={\n                             \"fcm_message_id\": response_data.get(\"name\"),\n                             \"token\": payload.recipient,\n                             \"title\": payload.subject,\n-                            \"body\": payload.content[:100]  # Truncate for logging\n-                        }\n+                            \"body\": payload.content[:100],  # Truncate for logging\n+                        },\n                     )\n                 else:\n-                    error_data = response.json() if response.headers.get(\"content-type\", \"\").startswith(\"application/json\") else {\"error\": response.text}\n+                    error_data = (\n+                        response.json()\n+                        if response.headers.get(\"content-type\", \"\").startswith(\n+                            \"application/json\"\n+                        )\n+                        else {\"error\": response.text}\n+                    )\n                     return NotificationResult(\n                         id=\"\",\n                         status=NotificationStatus.FAILED,\n-                        error_message=error_data.get(\"error\", {}).get(\"message\", f\"HTTP {response.status_code}\"),\n-                        provider_response=error_data\n+                        error_message=error_data.get(\"error\", {}).get(\n+                            \"message\", f\"HTTP {response.status_code}\"\n+                        ),\n+                        provider_response=error_data,\n                     )\n-                    \n+\n         except Exception as e:\n             logger.error(f\"FCM send failed: {str(e)}\")\n             return NotificationResult(\n-                id=\"\",\n-                status=NotificationStatus.FAILED,\n-                error_message=str(e)\n+                id=\"\", status=NotificationStatus.FAILED, error_message=str(e)\n             )\n-    \n+\n     async def _build_fcm_message(self, payload: NotificationPayload) -> Dict[str, Any]:\n         \"\"\"Build FCM message payload\"\"\"\n         message = {\n             \"token\": payload.recipient,\n             \"notification\": {\n                 \"title\": payload.subject or \"Notification\",\n-                \"body\": payload.content[:4000]  # FCM body limit\n-            }\n+                \"body\": payload.content[:4000],  # FCM body limit\n+            },\n         }\n-        \n+\n         # Add data payload if present\n         if payload.metadata:\n             data = payload.metadata.get(\"data\", {})\n             if data:\n                 # Convert all values to strings (FCM requirement)\n                 message[\"data\"] = {k: str(v) for k, v in data.items()}\n-            \n+\n             # Add Android-specific settings\n             android_config = payload.metadata.get(\"android\", {})\n             if android_config:\n                 message[\"android\"] = android_config\n-            \n+\n             # Add iOS-specific settings\n             apns_config = payload.metadata.get(\"apns\", {})\n             if apns_config:\n                 message[\"apns\"] = apns_config\n-            \n+\n             # Add web push settings\n             webpush_config = payload.metadata.get(\"webpush\", {})\n             if webpush_config:\n                 message[\"webpush\"] = webpush_config\n-        \n+\n         return message\n-    \n-    async def send_batch(self, payloads: List[NotificationPayload]) -> List[NotificationResult]:\n+\n+    async def send_batch(\n+        self, payloads: List[NotificationPayload]\n+    ) -> List[NotificationResult]:\n         \"\"\"Send multiple push notifications in batch\"\"\"\n         # FCM doesn't have a native batch API, so we'll send individually but concurrently\n-        tasks = [self.send(payload) for payload in payloads[:self.max_batch_size]]\n+        tasks = [self.send(payload) for payload in payloads[: self.max_batch_size]]\n         results = await asyncio.gather(*tasks, return_exceptions=True)\n-        \n+\n         # Convert exceptions to failed results\n         processed_results = []\n         for i, result in enumerate(results):\n             if isinstance(result, Exception):\n-                processed_results.append(NotificationResult(\n-                    id=\"\",\n-                    status=NotificationStatus.FAILED,\n-                    error_message=str(result),\n-                    metadata={\"batch_index\": i}\n-                ))\n+                processed_results.append(\n+                    NotificationResult(\n+                        id=\"\",\n+                        status=NotificationStatus.FAILED,\n+                        error_message=str(result),\n+                        metadata={\"batch_index\": i},\n+                    )\n+                )\n             else:\n                 processed_results.append(result)\n-        \n+\n         return processed_results\n-    \n+\n     async def get_delivery_status(self, notification_id: str) -> NotificationStatus:\n         \"\"\"Get push notification delivery status\"\"\"\n         # FCM doesn't provide detailed delivery tracking by default\n         # This would require implementing FCM analytics or delivery receipts\n         return NotificationStatus.SENT\n-    \n+\n     async def cancel_notification(self, notification_id: str) -> bool:\n         \"\"\"Cancel push notification (not supported by FCM after sending)\"\"\"\n         return False\n-    \n+\n     async def health_check(self) -> bool:\n         \"\"\"Check FCM connectivity\"\"\"\n         if not self.is_enabled:\n             return False\n-            \n+\n         try:\n             # Try to get access token as health check\n             await self._get_access_token()\n             return True\n-            \n+\n         except Exception as e:\n             logger.warning(f\"FCM health check failed: {e}\")\n             return False\n \n \n class APNSProvider(PushProvider):\n     \"\"\"Apple Push Notification Service provider (placeholder)\"\"\"\n-    \n+\n     def __init__(self, config: Dict[str, Any]):\n         super().__init__(config)\n         self.team_id = config.get(\"team_id\")\n         self.key_id = config.get(\"key_id\")\n         self.private_key = config.get(\"private_key\")\n         self.bundle_id = config.get(\"bundle_id\")\n         self.use_sandbox = config.get(\"use_sandbox\", False)\n-        \n-        self.apns_endpoint = \"api.sandbox.push.apple.com\" if self.use_sandbox else \"api.push.apple.com\"\n-    \n+\n+        self.apns_endpoint = (\n+            \"api.sandbox.push.apple.com\" if self.use_sandbox else \"api.push.apple.com\"\n+        )\n+\n     async def send(self, payload: NotificationPayload) -> NotificationResult:\n         \"\"\"Send push notification via APNS\"\"\"\n         # TODO: Implement APNS HTTP/2 integration\n         return NotificationResult(\n             id=\"\",\n             status=NotificationStatus.FAILED,\n-            error_message=\"APNS provider not implemented yet\"\n-        )\n-    \n+            error_message=\"APNS provider not implemented yet\",\n+        )\n+\n     async def get_delivery_status(self, notification_id: str) -> NotificationStatus:\n         \"\"\"Get delivery status from APNS\"\"\"\n         return NotificationStatus.SENT\n-    \n+\n     async def cancel_notification(self, notification_id: str) -> bool:\n         \"\"\"Cancel push notification in APNS\"\"\"\n         return False\n \n \n class WebPushProvider(PushProvider):\n     \"\"\"Web Push protocol provider (placeholder)\"\"\"\n-    \n+\n     def __init__(self, config: Dict[str, Any]):\n         super().__init__(config)\n         self.vapid_public_key = config.get(\"vapid_public_key\")\n         self.vapid_private_key = config.get(\"vapid_private_key\")\n         self.vapid_subject = config.get(\"vapid_subject\")\n-    \n+\n     async def send(self, payload: NotificationPayload) -> NotificationResult:\n         \"\"\"Send web push notification\"\"\"\n         # TODO: Implement Web Push protocol\n         return NotificationResult(\n             id=\"\",\n             status=NotificationStatus.FAILED,\n-            error_message=\"Web Push provider not implemented yet\"\n-        )\n-    \n+            error_message=\"Web Push provider not implemented yet\",\n+        )\n+\n     async def get_delivery_status(self, notification_id: str) -> NotificationStatus:\n         \"\"\"Get web push delivery status\"\"\"\n         return NotificationStatus.SENT\n-    \n+\n     async def cancel_notification(self, notification_id: str) -> bool:\n         \"\"\"Cancel web push notification\"\"\"\n         return False\n \n \n@@ -307,11 +333,11 @@\n         \"firebase\": FirebasePushProvider,\n         \"fcm\": FirebasePushProvider,  # Alias\n         \"apns\": APNSProvider,\n         \"webpush\": WebPushProvider,\n     }\n-    \n+\n     provider_class = providers.get(provider_type.lower())\n     if not provider_class:\n         raise ValueError(f\"Unknown push provider type: {provider_type}\")\n-    \n-    return provider_class(config)\n\\ No newline at end of file\n+\n+    return provider_class(config)\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/providers/in_app.py\t2025-09-09 14:25:27.134331+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/providers/in_app.py\t2025-09-10 11:37:01.477768+00:00\n@@ -1,101 +1,115 @@\n \"\"\"\n In-App Notification Provider\n WebSocket and database-based real-time notification delivery\n \"\"\"\n+\n import asyncio\n import json\n from datetime import datetime, timedelta\n from typing import Dict, Any, Optional, List, Set\n import uuid\n import logging\n from sqlalchemy.orm import Session\n from sqlalchemy import and_\n \n-from .base import NotificationProvider, NotificationPayload, NotificationResult, NotificationStatus\n+from .base import (\n+    NotificationProvider,\n+    NotificationPayload,\n+    NotificationResult,\n+    NotificationStatus,\n+)\n from ..database import get_db_session\n-from ..models import Notification, NotificationChannel, NotificationStatus as DBNotificationStatus\n+from ..models import (\n+    Notification,\n+    NotificationChannel,\n+    NotificationStatus as DBNotificationStatus,\n+)\n from ..redis_client import get_redis_client\n \n logger = logging.getLogger(__name__)\n \n \n class InAppProvider(NotificationProvider):\n     \"\"\"In-app notification provider using WebSocket and database storage\"\"\"\n-    \n+\n     def __init__(self, config: Dict[str, Any]):\n         super().__init__(config)\n         self.redis_client = None\n-        self.websocket_connections: Dict[str, Set[Any]] = {}  # user_id -> set of websocket connections\n-        self.notification_ttl_hours = config.get(\"notification_ttl_hours\", 720)  # 30 days\n+        self.websocket_connections: Dict[str, Set[Any]] = (\n+            {}\n+        )  # user_id -> set of websocket connections\n+        self.notification_ttl_hours = config.get(\n+            \"notification_ttl_hours\", 720\n+        )  # 30 days\n         self.max_unread_notifications = config.get(\"max_unread_notifications\", 100)\n-        \n+\n     async def _get_redis_client(self):\n         \"\"\"Get Redis client for pub/sub\"\"\"\n         if not self.redis_client:\n             self.redis_client = await get_redis_client()\n         return self.redis_client\n-    \n+\n     def get_provider_info(self) -> Dict[str, Any]:\n         info = super().get_provider_info()\n-        info.update({\n-            \"supports_real_time\": True,\n-            \"supports_persistence\": True,\n-            \"supports_read_status\": True,\n-            \"supports_rich_content\": True,\n-            \"notification_ttl_hours\": self.notification_ttl_hours,\n-            \"max_unread_notifications\": self.max_unread_notifications,\n-        })\n+        info.update(\n+            {\n+                \"supports_real_time\": True,\n+                \"supports_persistence\": True,\n+                \"supports_read_status\": True,\n+                \"supports_rich_content\": True,\n+                \"notification_ttl_hours\": self.notification_ttl_hours,\n+                \"max_unread_notifications\": self.max_unread_notifications,\n+            }\n+        )\n         return info\n-    \n+\n     async def validate_recipient(self, recipient: str) -> bool:\n         \"\"\"Validate user ID format (UUID)\"\"\"\n         try:\n             uuid.UUID(recipient)\n             return True\n         except ValueError:\n             return False\n-    \n+\n     async def send(self, payload: NotificationPayload) -> NotificationResult:\n         \"\"\"Send in-app notification\"\"\"\n         try:\n             # Validate recipient (user_id)\n             if not await self.validate_recipient(payload.recipient):\n                 return NotificationResult(\n                     id=\"\",\n                     status=NotificationStatus.REJECTED,\n-                    error_message=f\"Invalid user ID: {payload.recipient}\"\n-                )\n-            \n+                    error_message=f\"Invalid user ID: {payload.recipient}\",\n+                )\n+\n             # Store notification in database\n             notification_id = await self._store_notification(payload)\n-            \n+\n             # Send real-time notification via WebSocket/Redis\n             await self._send_realtime_notification(payload, notification_id)\n-            \n+\n             return NotificationResult(\n                 id=notification_id,\n                 status=NotificationStatus.DELIVERED,\n                 provider_id=self.provider_name,\n                 sent_at=datetime.utcnow(),\n                 delivered_at=datetime.utcnow(),\n                 metadata={\n                     \"user_id\": payload.recipient,\n                     \"title\": payload.subject,\n                     \"stored_in_db\": True,\n-                    \"sent_realtime\": True\n-                }\n+                    \"sent_realtime\": True,\n+                },\n             )\n-            \n+\n         except Exception as e:\n             logger.error(f\"In-app notification failed: {str(e)}\")\n             return NotificationResult(\n-                id=\"\",\n-                status=NotificationStatus.FAILED,\n-                error_message=str(e)\n+                id=\"\", status=NotificationStatus.FAILED, error_message=str(e)\n             )\n-    \n+\n     async def _store_notification(self, payload: NotificationPayload) -> str:\n         \"\"\"Store notification in database\"\"\"\n         try:\n             async with get_db_session() as session:\n                 # Create notification record\n@@ -106,43 +120,46 @@\n                     content=payload.content,\n                     data=payload.template_data or {},\n                     status=DBNotificationStatus.DELIVERED,\n                     recipient=payload.recipient,\n                     scheduled_at=payload.scheduled_at,\n-                    expires_at=payload.expires_at or datetime.utcnow() + timedelta(hours=self.notification_ttl_hours),\n+                    expires_at=payload.expires_at\n+                    or datetime.utcnow() + timedelta(hours=self.notification_ttl_hours),\n                     priority=payload.priority,\n-                    template_id=uuid.UUID(payload.template_id) if payload.template_id else None,\n+                    template_id=(\n+                        uuid.UUID(payload.template_id) if payload.template_id else None\n+                    ),\n                     is_read=False,\n-                    read_at=None\n-                )\n-                \n+                    read_at=None,\n+                )\n+\n                 session.add(notification)\n                 await session.commit()\n                 await session.refresh(notification)\n-                \n+\n                 # Clean up old notifications for this user\n                 await self._cleanup_old_notifications(session, payload.recipient)\n-                \n+\n                 return str(notification.id)\n-                \n+\n         except Exception as e:\n             logger.error(f\"Failed to store in-app notification: {e}\")\n             raise\n-    \n+\n     async def _cleanup_old_notifications(self, session: Session, user_id: str):\n         \"\"\"Clean up old notifications to prevent inbox overflow\"\"\"\n         try:\n             # Count unread notifications for user\n             unread_count = await session.execute(\n                 \"\"\"\n                 SELECT COUNT(*) FROM notifications \n                 WHERE user_id = :user_id AND channel = 'in_app' AND is_read = false\n                 \"\"\",\n-                {\"user_id\": user_id}\n+                {\"user_id\": user_id},\n             )\n             count = unread_count.scalar()\n-            \n+\n             if count > self.max_unread_notifications:\n                 # Mark oldest notifications as read\n                 overflow = count - self.max_unread_notifications\n                 await session.execute(\n                     \"\"\"\n@@ -156,62 +173,63 @@\n                     )\n                     \"\"\",\n                     {\n                         \"user_id\": user_id,\n                         \"read_at\": datetime.utcnow(),\n-                        \"limit\": overflow\n-                    }\n-                )\n-            \n+                        \"limit\": overflow,\n+                    },\n+                )\n+\n             # Delete expired notifications\n             await session.execute(\n                 \"\"\"\n                 DELETE FROM notifications \n                 WHERE user_id = :user_id AND channel = 'in_app' \n                 AND expires_at < :now AND is_read = true\n                 \"\"\",\n-                {\n-                    \"user_id\": user_id,\n-                    \"now\": datetime.utcnow()\n-                }\n+                {\"user_id\": user_id, \"now\": datetime.utcnow()},\n             )\n-            \n+\n             await session.commit()\n-            \n+\n         except Exception as e:\n             logger.warning(f\"Failed to cleanup notifications for user {user_id}: {e}\")\n-    \n-    async def _send_realtime_notification(self, payload: NotificationPayload, notification_id: str):\n+\n+    async def _send_realtime_notification(\n+        self, payload: NotificationPayload, notification_id: str\n+    ):\n         \"\"\"Send real-time notification via Redis pub/sub\"\"\"\n         try:\n             redis_client = await self._get_redis_client()\n-            \n+\n             # Prepare notification message\n             message = {\n                 \"id\": notification_id,\n                 \"user_id\": payload.recipient,\n                 \"type\": \"notification\",\n                 \"title\": payload.subject,\n                 \"body\": payload.content,\n                 \"data\": payload.template_data or {},\n                 \"priority\": payload.priority,\n                 \"timestamp\": datetime.utcnow().isoformat(),\n-                \"metadata\": payload.metadata or {}\n+                \"metadata\": payload.metadata or {},\n             }\n-            \n+\n             # Publish to user-specific channel\n             channel = f\"notifications:user:{payload.recipient}\"\n             await redis_client.publish(channel, json.dumps(message))\n-            \n+\n             # Also publish to general notifications channel for admin dashboards\n             await redis_client.publish(\"notifications:all\", json.dumps(message))\n-            \n+\n         except Exception as e:\n             logger.warning(f\"Failed to send real-time notification: {e}\")\n             # Don't fail the whole notification if real-time delivery fails\n-    \n-    async def get_unread_notifications(self, user_id: str, limit: int = 50) -> List[Dict[str, Any]]:\n+\n+    async def get_unread_notifications(\n+        self, user_id: str, limit: int = 50\n+    ) -> List[Dict[str, Any]]:\n         \"\"\"Get unread notifications for a user\"\"\"\n         try:\n             async with get_db_session() as session:\n                 result = await session.execute(\n                     \"\"\"\n@@ -220,35 +238,35 @@\n                     WHERE user_id = :user_id AND channel = 'in_app' AND is_read = false\n                     AND (expires_at IS NULL OR expires_at > :now)\n                     ORDER BY created_at DESC \n                     LIMIT :limit\n                     \"\"\",\n-                    {\n-                        \"user_id\": user_id,\n-                        \"now\": datetime.utcnow(),\n-                        \"limit\": limit\n-                    }\n-                )\n-                \n+                    {\"user_id\": user_id, \"now\": datetime.utcnow(), \"limit\": limit},\n+                )\n+\n                 notifications = []\n                 for row in result.fetchall():\n-                    notifications.append({\n-                        \"id\": str(row.id),\n-                        \"title\": row.subject,\n-                        \"body\": row.content,\n-                        \"data\": row.data or {},\n-                        \"priority\": row.priority,\n-                        \"created_at\": row.created_at.isoformat(),\n-                        \"expires_at\": row.expires_at.isoformat() if row.expires_at else None,\n-                    })\n-                \n+                    notifications.append(\n+                        {\n+                            \"id\": str(row.id),\n+                            \"title\": row.subject,\n+                            \"body\": row.content,\n+                            \"data\": row.data or {},\n+                            \"priority\": row.priority,\n+                            \"created_at\": row.created_at.isoformat(),\n+                            \"expires_at\": (\n+                                row.expires_at.isoformat() if row.expires_at else None\n+                            ),\n+                        }\n+                    )\n+\n                 return notifications\n-                \n+\n         except Exception as e:\n             logger.error(f\"Failed to get unread notifications for user {user_id}: {e}\")\n             return []\n-    \n+\n     async def mark_as_read(self, notification_id: str, user_id: str) -> bool:\n         \"\"\"Mark notification as read\"\"\"\n         try:\n             async with get_db_session() as session:\n                 result = await session.execute(\n@@ -258,170 +276,166 @@\n                     WHERE id = :notification_id AND user_id = :user_id AND channel = 'in_app'\n                     \"\"\",\n                     {\n                         \"notification_id\": notification_id,\n                         \"user_id\": user_id,\n-                        \"read_at\": datetime.utcnow()\n-                    }\n-                )\n-                \n+                        \"read_at\": datetime.utcnow(),\n+                    },\n+                )\n+\n                 await session.commit()\n                 return result.rowcount > 0\n-                \n+\n         except Exception as e:\n             logger.error(f\"Failed to mark notification {notification_id} as read: {e}\")\n             return False\n-    \n+\n     async def mark_all_as_read(self, user_id: str) -> int:\n         \"\"\"Mark all notifications as read for a user\"\"\"\n         try:\n             async with get_db_session() as session:\n                 result = await session.execute(\n                     \"\"\"\n                     UPDATE notifications \n                     SET is_read = true, read_at = :read_at\n                     WHERE user_id = :user_id AND channel = 'in_app' AND is_read = false\n                     \"\"\",\n-                    {\n-                        \"user_id\": user_id,\n-                        \"read_at\": datetime.utcnow()\n-                    }\n-                )\n-                \n+                    {\"user_id\": user_id, \"read_at\": datetime.utcnow()},\n+                )\n+\n                 await session.commit()\n                 return result.rowcount\n-                \n-        except Exception as e:\n-            logger.error(f\"Failed to mark all notifications as read for user {user_id}: {e}\")\n+\n+        except Exception as e:\n+            logger.error(\n+                f\"Failed to mark all notifications as read for user {user_id}: {e}\"\n+            )\n             return 0\n-    \n+\n     async def get_unread_count(self, user_id: str) -> int:\n         \"\"\"Get count of unread notifications for a user\"\"\"\n         try:\n             async with get_db_session() as session:\n                 result = await session.execute(\n                     \"\"\"\n                     SELECT COUNT(*) FROM notifications \n                     WHERE user_id = :user_id AND channel = 'in_app' AND is_read = false\n                     AND (expires_at IS NULL OR expires_at > :now)\n                     \"\"\",\n-                    {\n-                        \"user_id\": user_id,\n-                        \"now\": datetime.utcnow()\n-                    }\n-                )\n-                \n+                    {\"user_id\": user_id, \"now\": datetime.utcnow()},\n+                )\n+\n                 return result.scalar()\n-                \n+\n         except Exception as e:\n             logger.error(f\"Failed to get unread count for user {user_id}: {e}\")\n             return 0\n-    \n+\n     async def get_delivery_status(self, notification_id: str) -> NotificationStatus:\n         \"\"\"Get notification delivery status\"\"\"\n         try:\n             async with get_db_session() as session:\n                 result = await session.execute(\n                     \"\"\"\n                     SELECT status, is_read, read_at FROM notifications \n                     WHERE id = :notification_id AND channel = 'in_app'\n                     \"\"\",\n-                    {\"notification_id\": notification_id}\n-                )\n-                \n+                    {\"notification_id\": notification_id},\n+                )\n+\n                 row = result.fetchone()\n                 if not row:\n                     return NotificationStatus.FAILED\n-                \n+\n                 # Map database status to provider status\n                 if row.is_read:\n                     return NotificationStatus.DELIVERED\n                 else:\n                     return NotificationStatus.SENT\n-                    \n+\n         except Exception as e:\n             logger.error(f\"Failed to get delivery status for {notification_id}: {e}\")\n             return NotificationStatus.FAILED\n-    \n+\n     async def cancel_notification(self, notification_id: str) -> bool:\n         \"\"\"Delete notification (cancel)\"\"\"\n         try:\n             async with get_db_session() as session:\n                 result = await session.execute(\n                     \"\"\"\n                     DELETE FROM notifications \n                     WHERE id = :notification_id AND channel = 'in_app'\n                     \"\"\",\n-                    {\"notification_id\": notification_id}\n-                )\n-                \n+                    {\"notification_id\": notification_id},\n+                )\n+\n                 await session.commit()\n                 return result.rowcount > 0\n-                \n+\n         except Exception as e:\n             logger.error(f\"Failed to cancel notification {notification_id}: {e}\")\n             return False\n-    \n+\n     async def health_check(self) -> bool:\n         \"\"\"Check database and Redis connectivity\"\"\"\n         if not self.is_enabled:\n             return False\n-            \n+\n         try:\n             # Test database connection\n             async with get_db_session() as session:\n                 await session.execute(\"SELECT 1\")\n-            \n+\n             # Test Redis connection\n             redis_client = await self._get_redis_client()\n             await redis_client.ping()\n-            \n+\n             return True\n-            \n+\n         except Exception as e:\n             logger.warning(f\"In-app provider health check failed: {e}\")\n             return False\n \n \n # WebSocket connection manager (placeholder for future WebSocket integration)\n class WebSocketManager:\n     \"\"\"Manage WebSocket connections for real-time notifications\"\"\"\n-    \n+\n     def __init__(self):\n         self.active_connections: Dict[str, List[Any]] = {}\n-    \n+\n     async def connect(self, websocket, user_id: str):\n         \"\"\"Connect user WebSocket\"\"\"\n         await websocket.accept()\n         if user_id not in self.active_connections:\n             self.active_connections[user_id] = []\n         self.active_connections[user_id].append(websocket)\n-    \n+\n     def disconnect(self, websocket, user_id: str):\n         \"\"\"Disconnect user WebSocket\"\"\"\n         if user_id in self.active_connections:\n             self.active_connections[user_id].remove(websocket)\n             if not self.active_connections[user_id]:\n                 del self.active_connections[user_id]\n-    \n+\n     async def send_personal_message(self, message: str, user_id: str):\n         \"\"\"Send message to specific user's WebSocket connections\"\"\"\n         if user_id in self.active_connections:\n             disconnected = []\n             for websocket in self.active_connections[user_id]:\n                 try:\n                     await websocket.send_text(message)\n                 except:\n                     disconnected.append(websocket)\n-            \n+\n             # Clean up disconnected sockets\n             for websocket in disconnected:\n                 self.active_connections[user_id].remove(websocket)\n-    \n+\n     async def broadcast(self, message: str):\n         \"\"\"Broadcast message to all connected users\"\"\"\n         for user_id in self.active_connections:\n             await self.send_personal_message(message, user_id)\n \n \n # Global WebSocket manager instance\n-websocket_manager = WebSocketManager()\n\\ No newline at end of file\n+websocket_manager = WebSocketManager()\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tasks/notification_tasks.py\t2025-09-09 14:28:03.841136+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tasks/notification_tasks.py\t2025-09-10 11:37:01.511812+00:00\n@@ -1,9 +1,10 @@\n \"\"\"\n Notification Celery Tasks\n Background processing for notification delivery\n \"\"\"\n+\n import asyncio\n from datetime import datetime, timedelta\n from typing import Dict, Any, List, Optional\n import uuid\n import logging\n@@ -14,72 +15,80 @@\n from ..providers.base import NotificationPayload, NotificationStatus\n from ..providers import create_email_provider, create_sms_provider, create_push_provider\n from ..providers.in_app import InAppProvider\n from ..template_engine import template_engine\n from ..database import get_db_session\n-from ..models import Notification, NotificationChannel, NotificationStatus as DBNotificationStatus\n+from ..models import (\n+    Notification,\n+    NotificationChannel,\n+    NotificationStatus as DBNotificationStatus,\n+)\n \n logger = logging.getLogger(__name__)\n \n \n class NotificationTask(Task):\n     \"\"\"Base task class with notification-specific error handling\"\"\"\n-    \n+\n     def on_failure(self, exc, task_id, args, kwargs, einfo):\n         \"\"\"Handle task failure\"\"\"\n         logger.error(f\"Notification task {task_id} failed: {exc}\")\n-        \n+\n         # Update notification status in database if notification_id provided\n-        notification_id = kwargs.get('notification_id') or (args[0] if args else None)\n+        notification_id = kwargs.get(\"notification_id\") or (args[0] if args else None)\n         if notification_id:\n-            asyncio.run(self._update_notification_status(\n-                notification_id, \n-                DBNotificationStatus.FAILED,\n-                error_message=str(exc)\n-            ))\n-    \n+            asyncio.run(\n+                self._update_notification_status(\n+                    notification_id, DBNotificationStatus.FAILED, error_message=str(exc)\n+                )\n+            )\n+\n     async def _update_notification_status(\n-        self, \n-        notification_id: str, \n+        self,\n+        notification_id: str,\n         status: DBNotificationStatus,\n-        error_message: Optional[str] = None\n+        error_message: Optional[str] = None,\n     ):\n         \"\"\"Update notification status in database\"\"\"\n         try:\n             async with get_db_session() as session:\n-                notification = await session.get(Notification, uuid.UUID(notification_id))\n+                notification = await session.get(\n+                    Notification, uuid.UUID(notification_id)\n+                )\n                 if notification:\n                     notification.status = status\n                     if error_message:\n                         notification.error_message = error_message\n                     if status == DBNotificationStatus.SENT:\n                         notification.sent_at = datetime.utcnow()\n                     elif status == DBNotificationStatus.DELIVERED:\n                         notification.delivered_at = datetime.utcnow()\n-                    \n+\n                     await session.commit()\n-                    \n+\n         except Exception as e:\n             logger.error(f\"Failed to update notification status: {e}\")\n \n \n-@celery_app.task(bind=True, base=NotificationTask, max_retries=3, default_retry_delay=60)\n+@celery_app.task(\n+    bind=True, base=NotificationTask, max_retries=3, default_retry_delay=60\n+)\n def send_notification(\n     self,\n     channel: str,\n     recipient: str,\n     content: str,\n     subject: Optional[str] = None,\n     template_id: Optional[str] = None,\n     template_data: Optional[Dict[str, Any]] = None,\n     metadata: Optional[Dict[str, Any]] = None,\n     notification_id: Optional[str] = None,\n-    priority: str = \"normal\"\n+    priority: str = \"normal\",\n ):\n     \"\"\"\n     Send a single notification via specified channel\n-    \n+\n     Args:\n         channel: Notification channel (email, sms, push, in_app)\n         recipient: Recipient address/ID\n         content: Notification content\n         subject: Notification subject (for email/push)\n@@ -96,107 +105,124 @@\n             content=content,\n             subject=subject,\n             template_id=template_id,\n             template_data=template_data or {},\n             metadata=metadata or {},\n-            priority=priority\n-        )\n-        \n+            priority=priority,\n+        )\n+\n         # Render template if template_id provided\n         if template_id:\n-            rendered = asyncio.run(template_engine.render_template(\n-                template_id,\n-                template_data or {},\n-                NotificationChannel(channel)\n-            ))\n+            rendered = asyncio.run(\n+                template_engine.render_template(\n+                    template_id, template_data or {}, NotificationChannel(channel)\n+                )\n+            )\n             payload.subject = rendered.get(\"subject\") or payload.subject\n             payload.content = rendered.get(\"content\") or payload.content\n-        \n+\n         # Get provider and send notification\n         provider = _get_provider(channel, metadata or {})\n         result = asyncio.run(provider.send(payload))\n-        \n+\n         # Update database with result\n         if notification_id:\n             status_mapping = {\n                 NotificationStatus.SENT: DBNotificationStatus.SENT,\n                 NotificationStatus.QUEUED: DBNotificationStatus.QUEUED,\n                 NotificationStatus.DELIVERED: DBNotificationStatus.DELIVERED,\n                 NotificationStatus.FAILED: DBNotificationStatus.FAILED,\n                 NotificationStatus.REJECTED: DBNotificationStatus.FAILED,\n             }\n-            \n-            asyncio.run(self._update_notification_status(\n-                notification_id,\n-                status_mapping.get(result.status, DBNotificationStatus.FAILED),\n-                result.error_message\n-            ))\n-        \n+\n+            asyncio.run(\n+                self._update_notification_status(\n+                    notification_id,\n+                    status_mapping.get(result.status, DBNotificationStatus.FAILED),\n+                    result.error_message,\n+                )\n+            )\n+\n         if result.status == NotificationStatus.FAILED:\n             raise Exception(f\"Notification delivery failed: {result.error_message}\")\n-        \n+\n         return {\n             \"status\": result.status.value,\n             \"provider_id\": result.provider_id,\n             \"notification_id\": result.id,\n             \"sent_at\": result.sent_at.isoformat() if result.sent_at else None,\n-            \"cost\": result.cost\n+            \"cost\": result.cost,\n         }\n-        \n+\n     except Exception as exc:\n         logger.error(f\"Notification task failed: {exc}\")\n-        \n+\n         # Retry with exponential backoff\n         if self.request.retries < self.max_retries:\n-            countdown = (2 ** self.request.retries) * 60  # 1, 2, 4 minutes\n+            countdown = (2**self.request.retries) * 60  # 1, 2, 4 minutes\n             raise self.retry(exc=exc, countdown=countdown)\n-        \n+\n         raise MaxRetriesExceededError(f\"Max retries exceeded: {exc}\")\n \n \n @celery_app.task(bind=True, base=NotificationTask)\n def send_urgent_notification(\n     self,\n     channel: str,\n     recipient: str,\n     content: str,\n     subject: Optional[str] = None,\n-    metadata: Optional[Dict[str, Any]] = None\n+    metadata: Optional[Dict[str, Any]] = None,\n ):\n     \"\"\"Send urgent notification with highest priority\"\"\"\n     return send_notification.apply_async(\n-        args=(channel, recipient, content, subject, None, None, metadata, None, \"urgent\"),\n+        args=(\n+            channel,\n+            recipient,\n+            content,\n+            subject,\n+            None,\n+            None,\n+            metadata,\n+            None,\n+            \"urgent\",\n+        ),\n         priority=9,\n-        countdown=0\n+        countdown=0,\n     )\n \n \n @celery_app.task(bind=True, base=NotificationTask)\n def send_bulk_notifications(\n     self,\n     notifications: List[Dict[str, Any]],\n     batch_size: int = 50,\n-    delay_between_batches: int = 5\n+    delay_between_batches: int = 5,\n ):\n     \"\"\"\n     Send bulk notifications in batches\n-    \n+\n     Args:\n         notifications: List of notification dicts with keys: channel, recipient, content, etc.\n         batch_size: Number of notifications per batch\n         delay_between_batches: Delay in seconds between batches\n     \"\"\"\n     try:\n         total_notifications = len(notifications)\n-        batches = [notifications[i:i + batch_size] for i in range(0, total_notifications, batch_size)]\n+        batches = [\n+            notifications[i : i + batch_size]\n+            for i in range(0, total_notifications, batch_size)\n+        ]\n         results = []\n-        \n-        logger.info(f\"Processing {total_notifications} notifications in {len(batches)} batches\")\n-        \n+\n+        logger.info(\n+            f\"Processing {total_notifications} notifications in {len(batches)} batches\"\n+        )\n+\n         for batch_idx, batch in enumerate(batches):\n             batch_results = []\n-            \n+\n             # Process batch\n             for notification in batch:\n                 task_result = send_notification.apply_async(\n                     args=(\n                         notification[\"channel\"],\n@@ -205,62 +231,67 @@\n                         notification.get(\"subject\"),\n                         notification.get(\"template_id\"),\n                         notification.get(\"template_data\"),\n                         notification.get(\"metadata\"),\n                         notification.get(\"notification_id\"),\n-                        notification.get(\"priority\", \"normal\")\n+                        notification.get(\"priority\", \"normal\"),\n                     ),\n-                    priority=2  # Lower priority for bulk\n+                    priority=2,  # Lower priority for bulk\n                 )\n                 batch_results.append(task_result.id)\n-            \n+\n             results.extend(batch_results)\n-            \n+\n             # Delay between batches (except last batch)\n             if batch_idx < len(batches) - 1:\n                 import time\n+\n                 time.sleep(delay_between_batches)\n-        \n+\n         return {\n             \"total_notifications\": total_notifications,\n             \"batches\": len(batches),\n-            \"task_ids\": results\n+            \"task_ids\": results,\n         }\n-        \n+\n     except Exception as exc:\n         logger.error(f\"Bulk notification task failed: {exc}\")\n         raise\n \n \n @celery_app.task(bind=True, base=NotificationTask, max_retries=1)\n def send_scheduled_notification(self, notification_id: str):\n     \"\"\"\n     Send a scheduled notification\n-    \n+\n     Args:\n         notification_id: Database notification ID to send\n     \"\"\"\n     try:\n         # Get notification from database\n         async def get_notification():\n             async with get_db_session() as session:\n                 return await session.get(Notification, uuid.UUID(notification_id))\n-        \n+\n         notification = asyncio.run(get_notification())\n-        \n+\n         if not notification:\n             raise ValueError(f\"Notification {notification_id} not found\")\n-        \n+\n         if notification.status != DBNotificationStatus.PENDING:\n-            logger.warning(f\"Notification {notification_id} already processed (status: {notification.status})\")\n+            logger.warning(\n+                f\"Notification {notification_id} already processed (status: {notification.status})\"\n+            )\n             return {\"status\": \"already_processed\"}\n-        \n+\n         # Check if it's time to send\n         if notification.scheduled_at and notification.scheduled_at > datetime.utcnow():\n-            logger.warning(f\"Notification {notification_id} not yet due (scheduled: {notification.scheduled_at})\")\n+            logger.warning(\n+                f\"Notification {notification_id} not yet due (scheduled: {notification.scheduled_at})\"\n+            )\n             return {\"status\": \"not_due\"}\n-        \n+\n         # Send notification\n         result = send_notification.apply_async(\n             args=(\n                 notification.channel.value,\n                 notification.recipient,\n@@ -268,20 +299,20 @@\n                 notification.subject,\n                 str(notification.template_id) if notification.template_id else None,\n                 notification.data,\n                 {\"notification_id\": notification_id},\n                 notification_id,\n-                notification.priority or \"normal\"\n-            )\n-        )\n-        \n+                notification.priority or \"normal\",\n+            )\n+        )\n+\n         return {\n             \"status\": \"sent\",\n             \"task_id\": result.id,\n-            \"notification_id\": notification_id\n+            \"notification_id\": notification_id,\n         }\n-        \n+\n     except Exception as exc:\n         logger.error(f\"Scheduled notification task failed: {exc}\")\n         if self.request.retries < self.max_retries:\n             raise self.retry(exc=exc, countdown=300)  # Retry in 5 minutes\n         raise\n@@ -289,10 +320,11 @@\n \n @celery_app.task\n def process_scheduled_notifications():\n     \"\"\"Process notifications that are due to be sent\"\"\"\n     try:\n+\n         async def get_due_notifications():\n             async with get_db_session() as session:\n                 result = await session.execute(\n                     \"\"\"\n                     SELECT id FROM notifications \n@@ -301,64 +333,73 @@\n                     AND scheduled_at <= :now\n                     AND (expires_at IS NULL OR expires_at > :now)\n                     ORDER BY scheduled_at ASC\n                     LIMIT 100\n                     \"\"\",\n-                    {\"now\": datetime.utcnow()}\n+                    {\"now\": datetime.utcnow()},\n                 )\n                 return [str(row.id) for row in result.fetchall()]\n-        \n+\n         due_notifications = asyncio.run(get_due_notifications())\n-        \n+\n         if not due_notifications:\n             return {\"processed\": 0}\n-        \n+\n         logger.info(f\"Processing {len(due_notifications)} scheduled notifications\")\n-        \n+\n         # Send scheduled notifications\n         for notification_id in due_notifications:\n             send_scheduled_notification.apply_async(args=(notification_id,))\n-        \n+\n         return {\n             \"processed\": len(due_notifications),\n-            \"notification_ids\": due_notifications\n+            \"notification_ids\": due_notifications,\n         }\n-        \n+\n     except Exception as exc:\n         logger.error(f\"Process scheduled notifications failed: {exc}\")\n         raise\n \n \n def _get_provider(channel: str, config: Dict[str, Any]):\n     \"\"\"Get notification provider for channel\"\"\"\n     if channel == \"email\":\n-        return create_email_provider(\"smtp\", {\n-            \"smtp_host\": config.get(\"smtp_host\", \"localhost\"),\n-            \"smtp_port\": config.get(\"smtp_port\", 587),\n-            \"smtp_username\": config.get(\"smtp_username\"),\n-            \"smtp_password\": config.get(\"smtp_password\"),\n-            \"from_email\": config.get(\"from_email\", \"noreply@example.com\"),\n-            \"use_tls\": config.get(\"use_tls\", True),\n-            \"enabled\": True\n-        })\n-    \n+        return create_email_provider(\n+            \"smtp\",\n+            {\n+                \"smtp_host\": config.get(\"smtp_host\", \"localhost\"),\n+                \"smtp_port\": config.get(\"smtp_port\", 587),\n+                \"smtp_username\": config.get(\"smtp_username\"),\n+                \"smtp_password\": config.get(\"smtp_password\"),\n+                \"from_email\": config.get(\"from_email\", \"noreply@example.com\"),\n+                \"use_tls\": config.get(\"use_tls\", True),\n+                \"enabled\": True,\n+            },\n+        )\n+\n     elif channel == \"sms\":\n-        return create_sms_provider(\"twilio\", {\n-            \"account_sid\": config.get(\"twilio_account_sid\"),\n-            \"auth_token\": config.get(\"twilio_auth_token\"),\n-            \"from_number\": config.get(\"twilio_from_number\"),\n-            \"enabled\": True\n-        })\n-    \n+        return create_sms_provider(\n+            \"twilio\",\n+            {\n+                \"account_sid\": config.get(\"twilio_account_sid\"),\n+                \"auth_token\": config.get(\"twilio_auth_token\"),\n+                \"from_number\": config.get(\"twilio_from_number\"),\n+                \"enabled\": True,\n+            },\n+        )\n+\n     elif channel == \"push\":\n-        return create_push_provider(\"firebase\", {\n-            \"project_id\": config.get(\"firebase_project_id\"),\n-            \"private_key\": config.get(\"firebase_private_key\"),\n-            \"client_email\": config.get(\"firebase_client_email\"),\n-            \"enabled\": True\n-        })\n-    \n+        return create_push_provider(\n+            \"firebase\",\n+            {\n+                \"project_id\": config.get(\"firebase_project_id\"),\n+                \"private_key\": config.get(\"firebase_private_key\"),\n+                \"client_email\": config.get(\"firebase_client_email\"),\n+                \"enabled\": True,\n+            },\n+        )\n+\n     elif channel == \"in_app\":\n         return InAppProvider({\"enabled\": True})\n-    \n+\n     else:\n-        raise ValueError(f\"Unknown notification channel: {channel}\")\n\\ No newline at end of file\n+        raise ValueError(f\"Unknown notification channel: {channel}\")\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/models.py\t2025-09-09 13:50:55.770214+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/models.py\t2025-09-10 11:37:01.581652+00:00\n@@ -1,346 +1,408 @@\n \"\"\"\n Communication Service Database Models\n SQLAlchemy models for notifications, messages, conversations, and templates\n \"\"\"\n+\n import uuid\n from datetime import datetime\n from typing import Optional, Dict, Any\n from sqlalchemy import (\n-    Column, String, Text, DateTime, Boolean, Integer, \n-    ForeignKey, JSON, Enum, Index\n+    Column,\n+    String,\n+    Text,\n+    DateTime,\n+    Boolean,\n+    Integer,\n+    ForeignKey,\n+    JSON,\n+    Enum,\n+    Index,\n )\n from sqlalchemy.ext.declarative import declarative_base\n from sqlalchemy.orm import relationship\n from sqlalchemy.dialects.postgresql import UUID\n import enum\n \n Base = declarative_base()\n \n+\n class NotificationStatus(enum.Enum):\n     \"\"\"Notification delivery status\"\"\"\n+\n     PENDING = \"pending\"\n     QUEUED = \"queued\"\n     SENT = \"sent\"\n     DELIVERED = \"delivered\"\n     FAILED = \"failed\"\n     CANCELLED = \"cancelled\"\n \n+\n class NotificationChannel(enum.Enum):\n     \"\"\"Notification delivery channels\"\"\"\n+\n     EMAIL = \"email\"\n     SMS = \"sms\"\n     PUSH = \"push\"\n     IN_APP = \"in_app\"\n \n+\n class ConversationType(enum.Enum):\n     \"\"\"Conversation types\"\"\"\n+\n     DIRECT = \"direct\"\n     GROUP = \"group\"\n     SUPPORT = \"support\"\n     SYSTEM = \"system\"\n \n+\n class MessageType(enum.Enum):\n     \"\"\"Message content types\"\"\"\n+\n     TEXT = \"text\"\n     HTML = \"html\"\n     MARKDOWN = \"markdown\"\n     FILE = \"file\"\n     IMAGE = \"image\"\n     SYSTEM = \"system\"\n \n+\n class ParticipantRole(enum.Enum):\n     \"\"\"Participant roles in conversations\"\"\"\n+\n     MEMBER = \"member\"\n     ADMIN = \"admin\"\n     MODERATOR = \"moderator\"\n     READONLY = \"readonly\"\n \n \n class NotificationCategory(Base):\n     \"\"\"Categories for organizing notifications\"\"\"\n+\n     __tablename__ = \"notification_categories\"\n-    \n+\n     id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n     name = Column(String(100), unique=True, nullable=False)\n     description = Column(Text)\n     default_enabled = Column(Boolean, default=True)\n     created_at = Column(DateTime, default=datetime.utcnow)\n     updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n-    \n+\n     # Relationships\n     notifications = relationship(\"Notification\", back_populates=\"category\")\n     templates = relationship(\"NotificationTemplate\", back_populates=\"category\")\n-    \n+\n     def __repr__(self):\n         return f\"<NotificationCategory(name='{self.name}')>\"\n \n \n class NotificationTemplate(Base):\n     \"\"\"Templates for notifications with variable substitution\"\"\"\n+\n     __tablename__ = \"notification_templates\"\n-    \n+\n     id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n     name = Column(String(200), nullable=False)\n     category_id = Column(UUID(as_uuid=True), ForeignKey(\"notification_categories.id\"))\n     channel = Column(Enum(NotificationChannel), nullable=False)\n     language = Column(String(10), default=\"en\")\n-    \n+\n     # Template content\n     subject = Column(String(500))  # For email/push notifications\n     content = Column(Text, nullable=False)\n     variables = Column(JSON, default=dict)  # Expected template variables\n-    \n+\n     # Metadata\n     version = Column(Integer, default=1)\n     is_active = Column(Boolean, default=True)\n     template_metadata = Column(JSON, default=dict)  # Flexible metadata storage\n-    \n-    # Timestamps\n-    created_at = Column(DateTime, default=datetime.utcnow)\n-    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n-    \n+\n+    # Timestamps\n+    created_at = Column(DateTime, default=datetime.utcnow)\n+    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n+\n     # Relationships\n     category = relationship(\"NotificationCategory\", back_populates=\"templates\")\n     notifications = relationship(\"Notification\", back_populates=\"template\")\n-    \n+\n     # Indexes\n     __table_args__ = (\n         Index(\"idx_template_category_channel\", \"category_id\", \"channel\"),\n         Index(\"idx_template_active\", \"is_active\"),\n     )\n-    \n+\n     def __repr__(self):\n         return f\"<NotificationTemplate(name='{self.name}', channel='{self.channel.value}')>\"\n \n \n class Notification(Base):\n     \"\"\"Individual notifications sent to users\"\"\"\n+\n     __tablename__ = \"notifications\"\n-    \n+\n     id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n     user_id = Column(UUID(as_uuid=True), nullable=False)  # From Identity Service\n-    \n+\n     # Notification details\n     category_id = Column(UUID(as_uuid=True), ForeignKey(\"notification_categories.id\"))\n-    template_id = Column(UUID(as_uuid=True), ForeignKey(\"notification_templates.id\"), nullable=True)\n+    template_id = Column(\n+        UUID(as_uuid=True), ForeignKey(\"notification_templates.id\"), nullable=True\n+    )\n     channel = Column(Enum(NotificationChannel), nullable=False)\n-    \n+\n     # Content\n     subject = Column(String(500))\n     content = Column(Text, nullable=False)\n     data = Column(JSON, default=dict)  # Template variables and custom data\n-    \n+\n     # Delivery\n     status = Column(Enum(NotificationStatus), default=NotificationStatus.PENDING)\n     recipient = Column(String(255), nullable=False)  # Email, phone, device token\n     provider = Column(String(50))  # SendGrid, Twilio, Firebase, etc.\n     provider_message_id = Column(String(255))  # External provider's message ID\n-    \n+\n     # Scheduling\n     scheduled_at = Column(DateTime, nullable=True)  # For scheduled notifications\n     sent_at = Column(DateTime, nullable=True)\n     delivered_at = Column(DateTime, nullable=True)\n     read_at = Column(DateTime, nullable=True)  # For in-app notifications\n-    \n+\n     # Error handling\n     error_message = Column(Text)\n     retry_count = Column(Integer, default=0)\n     max_retries = Column(Integer, default=3)\n-    \n-    # Timestamps\n-    created_at = Column(DateTime, default=datetime.utcnow)\n-    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n-    \n+\n+    # Timestamps\n+    created_at = Column(DateTime, default=datetime.utcnow)\n+    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n+\n     # Relationships\n     category = relationship(\"NotificationCategory\", back_populates=\"notifications\")\n     template = relationship(\"NotificationTemplate\", back_populates=\"notifications\")\n-    \n+\n     # Indexes\n     __table_args__ = (\n         Index(\"idx_notification_user_status\", \"user_id\", \"status\"),\n         Index(\"idx_notification_scheduled\", \"scheduled_at\"),\n         Index(\"idx_notification_channel\", \"channel\"),\n         Index(\"idx_notification_provider\", \"provider\"),\n     )\n-    \n+\n     def __repr__(self):\n         return f\"<Notification(user_id='{self.user_id}', status='{self.status.value}')>\"\n \n \n class NotificationPreference(Base):\n     \"\"\"User preferences for notification delivery\"\"\"\n+\n     __tablename__ = \"notification_preferences\"\n-    \n+\n     id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n     user_id = Column(UUID(as_uuid=True), nullable=False)\n     category_id = Column(UUID(as_uuid=True), ForeignKey(\"notification_categories.id\"))\n-    \n+\n     # Channel preferences\n     email_enabled = Column(Boolean, default=True)\n     sms_enabled = Column(Boolean, default=False)\n     push_enabled = Column(Boolean, default=True)\n     in_app_enabled = Column(Boolean, default=True)\n-    \n+\n     # Contact information\n     email_address = Column(String(255))\n     phone_number = Column(String(50))\n     push_token = Column(Text)  # Device push notification token\n-    \n+\n     # Settings\n     quiet_hours_start = Column(String(5))  # HH:MM format\n     quiet_hours_end = Column(String(5))  # HH:MM format\n     timezone = Column(String(50), default=\"UTC\")\n-    \n-    # Timestamps\n-    created_at = Column(DateTime, default=datetime.utcnow)\n-    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n-    \n+\n+    # Timestamps\n+    created_at = Column(DateTime, default=datetime.utcnow)\n+    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n+\n     # Relationships\n     category = relationship(\"NotificationCategory\")\n-    \n-    # Indexes\n-    __table_args__ = (\n-        Index(\"idx_preference_user_category\", \"user_id\", \"category_id\"),\n-    )\n-    \n+\n+    # Indexes\n+    __table_args__ = (Index(\"idx_preference_user_category\", \"user_id\", \"category_id\"),)\n+\n     def __repr__(self):\n         return f\"<NotificationPreference(user_id='{self.user_id}')>\"\n \n \n class Conversation(Base):\n     \"\"\"Conversations between users\"\"\"\n+\n     __tablename__ = \"conversations\"\n-    \n+\n     id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n     type = Column(Enum(ConversationType), default=ConversationType.DIRECT)\n-    \n+\n     # Content\n     subject = Column(String(500))  # Optional subject for group/support conversations\n-    notification_metadata = Column(JSON, default=dict)  # Flexible metadata (tags, priority, etc.)\n-    \n+    notification_metadata = Column(\n+        JSON, default=dict\n+    )  # Flexible metadata (tags, priority, etc.)\n+\n     # Status\n     is_active = Column(Boolean, default=True)\n     is_archived = Column(Boolean, default=False)\n-    \n+\n     # Timestamps\n     created_at = Column(DateTime, default=datetime.utcnow)\n     updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n     last_message_at = Column(DateTime, default=datetime.utcnow)\n-    \n-    # Relationships\n-    messages = relationship(\"Message\", back_populates=\"conversation\", cascade=\"all, delete-orphan\")\n-    participants = relationship(\"ConversationParticipant\", back_populates=\"conversation\", cascade=\"all, delete-orphan\")\n-    \n+\n+    # Relationships\n+    messages = relationship(\n+        \"Message\", back_populates=\"conversation\", cascade=\"all, delete-orphan\"\n+    )\n+    participants = relationship(\n+        \"ConversationParticipant\",\n+        back_populates=\"conversation\",\n+        cascade=\"all, delete-orphan\",\n+    )\n+\n     # Indexes\n     __table_args__ = (\n         Index(\"idx_conversation_type\", \"type\"),\n         Index(\"idx_conversation_active\", \"is_active\"),\n         Index(\"idx_conversation_last_message\", \"last_message_at\"),\n     )\n-    \n+\n     def __repr__(self):\n         return f\"<Conversation(type='{self.type.value}')>\"\n \n \n class ConversationParticipant(Base):\n     \"\"\"Participants in conversations with roles and status\"\"\"\n+\n     __tablename__ = \"conversation_participants\"\n-    \n-    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n-    conversation_id = Column(UUID(as_uuid=True), ForeignKey(\"conversations.id\"), nullable=False)\n+\n+    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n+    conversation_id = Column(\n+        UUID(as_uuid=True), ForeignKey(\"conversations.id\"), nullable=False\n+    )\n     user_id = Column(UUID(as_uuid=True), nullable=False)  # From Identity Service\n-    \n+\n     # Participant status\n     role = Column(Enum(ParticipantRole), default=ParticipantRole.MEMBER)\n     is_active = Column(Boolean, default=True)\n-    \n+\n     # Activity tracking\n     joined_at = Column(DateTime, default=datetime.utcnow)\n     last_read_at = Column(DateTime, default=datetime.utcnow)\n     last_activity_at = Column(DateTime, default=datetime.utcnow)\n-    \n+\n     # Settings\n     notifications_enabled = Column(Boolean, default=True)\n-    \n-    # Timestamps\n-    created_at = Column(DateTime, default=datetime.utcnow)\n-    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n-    \n+\n+    # Timestamps\n+    created_at = Column(DateTime, default=datetime.utcnow)\n+    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n+\n     # Relationships\n     conversation = relationship(\"Conversation\", back_populates=\"participants\")\n     messages = relationship(\"Message\", back_populates=\"sender\")\n-    \n+\n     # Indexes\n     __table_args__ = (\n         Index(\"idx_participant_conversation\", \"conversation_id\"),\n         Index(\"idx_participant_user\", \"user_id\"),\n         Index(\"idx_participant_active\", \"is_active\"),\n     )\n-    \n+\n     def __repr__(self):\n         return f\"<ConversationParticipant(user_id='{self.user_id}', role='{self.role.value}')>\"\n \n \n class Message(Base):\n     \"\"\"Messages within conversations\"\"\"\n+\n     __tablename__ = \"messages\"\n-    \n-    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n-    conversation_id = Column(UUID(as_uuid=True), ForeignKey(\"conversations.id\"), nullable=False)\n-    sender_id = Column(UUID(as_uuid=True), ForeignKey(\"conversation_participants.id\"), nullable=False)\n-    \n+\n+    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n+    conversation_id = Column(\n+        UUID(as_uuid=True), ForeignKey(\"conversations.id\"), nullable=False\n+    )\n+    sender_id = Column(\n+        UUID(as_uuid=True), ForeignKey(\"conversation_participants.id\"), nullable=False\n+    )\n+\n     # Message content\n     content = Column(Text, nullable=False)\n     message_type = Column(Enum(MessageType), default=MessageType.TEXT)\n     message_metadata = Column(JSON, default=dict)  # File attachments, formatting, etc.\n-    \n+\n     # Message status\n     is_edited = Column(Boolean, default=False)\n     is_deleted = Column(Boolean, default=False)\n     edited_at = Column(DateTime)\n     deleted_at = Column(DateTime)\n-    \n+\n     # Delivery tracking\n     sent_at = Column(DateTime, default=datetime.utcnow)\n-    \n-    # Timestamps\n-    created_at = Column(DateTime, default=datetime.utcnow)\n-    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n-    \n+\n+    # Timestamps\n+    created_at = Column(DateTime, default=datetime.utcnow)\n+    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n+\n     # Relationships\n     conversation = relationship(\"Conversation\", back_populates=\"messages\")\n     sender = relationship(\"ConversationParticipant\", back_populates=\"messages\")\n-    \n+\n     # Indexes\n     __table_args__ = (\n         Index(\"idx_message_conversation\", \"conversation_id\"),\n         Index(\"idx_message_sender\", \"sender_id\"),\n         Index(\"idx_message_sent\", \"sent_at\"),\n         Index(\"idx_message_type\", \"message_type\"),\n     )\n-    \n+\n     def __repr__(self):\n         return f\"<Message(conversation_id='{self.conversation_id}', type='{self.message_type.value}')>\"\n \n \n # Utility functions for model operations\n def create_default_categories():\n     \"\"\"Create default notification categories\"\"\"\n     default_categories = [\n-        {\"name\": \"system\", \"description\": \"System notifications and alerts\", \"default_enabled\": True},\n-        {\"name\": \"transactional\", \"description\": \"Transaction confirmations and receipts\", \"default_enabled\": True},\n-        {\"name\": \"marketing\", \"description\": \"Marketing campaigns and promotions\", \"default_enabled\": False},\n-        {\"name\": \"social\", \"description\": \"Social interactions and updates\", \"default_enabled\": True},\n-        {\"name\": \"security\", \"description\": \"Security alerts and notifications\", \"default_enabled\": True},\n+        {\n+            \"name\": \"system\",\n+            \"description\": \"System notifications and alerts\",\n+            \"default_enabled\": True,\n+        },\n+        {\n+            \"name\": \"transactional\",\n+            \"description\": \"Transaction confirmations and receipts\",\n+            \"default_enabled\": True,\n+        },\n+        {\n+            \"name\": \"marketing\",\n+            \"description\": \"Marketing campaigns and promotions\",\n+            \"default_enabled\": False,\n+        },\n+        {\n+            \"name\": \"social\",\n+            \"description\": \"Social interactions and updates\",\n+            \"default_enabled\": True,\n+        },\n+        {\n+            \"name\": \"security\",\n+            \"description\": \"Security alerts and notifications\",\n+            \"default_enabled\": True,\n+        },\n     ]\n     return [NotificationCategory(**cat) for cat in default_categories]\n \n \n def get_user_notification_preferences(db_session, user_id: uuid.UUID) -> Dict[str, Any]:\n     \"\"\"Get user's notification preferences across all categories\"\"\"\n-    preferences = db_session.query(NotificationPreference).filter_by(user_id=user_id).all()\n+    preferences = (\n+        db_session.query(NotificationPreference).filter_by(user_id=user_id).all()\n+    )\n     return {pref.category.name: pref for pref in preferences}\n \n \n def create_notification(\n     db_session,\n@@ -350,28 +412,32 @@\n     category_name: str = \"system\",\n     recipient: Optional[str] = None,\n     template_id: Optional[uuid.UUID] = None,\n     subject: Optional[str] = None,\n     data: Optional[Dict[str, Any]] = None,\n-    scheduled_at: Optional[datetime] = None\n+    scheduled_at: Optional[datetime] = None,\n ) -> Notification:\n     \"\"\"Create a new notification\"\"\"\n-    category = db_session.query(NotificationCategory).filter_by(name=category_name).first()\n+    category = (\n+        db_session.query(NotificationCategory).filter_by(name=category_name).first()\n+    )\n     if not category:\n-        category = NotificationCategory(name=category_name, description=f\"{category_name} notifications\")\n+        category = NotificationCategory(\n+            name=category_name, description=f\"{category_name} notifications\"\n+        )\n         db_session.add(category)\n         db_session.flush()\n-    \n+\n     notification = Notification(\n         user_id=user_id,\n         category_id=category.id,\n         template_id=template_id,\n         channel=channel,\n         subject=subject,\n         content=content,\n         data=data or {},\n         recipient=recipient,\n-        scheduled_at=scheduled_at\n-    )\n-    \n+        scheduled_at=scheduled_at,\n+    )\n+\n     db_session.add(notification)\n-    return notification\n\\ No newline at end of file\n+    return notification\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/redis_client.py\t2025-09-09 13:30:04.231018+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/redis_client.py\t2025-09-10 11:37:01.589651+00:00\n@@ -1,9 +1,10 @@\n \"\"\"\n Redis client configuration for Communication Service\n Handles caching, session storage, and real-time features\n \"\"\"\n+\n import os\n import json\n import pickle\n from typing import Optional, Any, Dict, List, Union\n from contextlib import asynccontextmanager, contextmanager\n@@ -12,168 +13,175 @@\n from datetime import datetime, timedelta\n import logging\n \n logger = logging.getLogger(__name__)\n \n+\n class RedisConfig:\n     \"\"\"Redis configuration and connection management\"\"\"\n-    \n+\n     def __init__(self):\n         self.redis_url = self._get_redis_url()\n         self.cache_ttl = int(os.getenv(\"REDIS_CACHE_TTL\", \"3600\"))  # 1 hour default\n         self.max_connections = int(os.getenv(\"REDIS_MAX_CONNECTIONS\", \"10\"))\n-        \n+\n         # Initialize sync and async clients\n         self.sync_client = self._create_sync_client()\n         self.async_client = None  # Will be initialized when needed\n-    \n+\n     def _get_redis_url(self) -> str:\n         \"\"\"Get Redis URL from environment variables\"\"\"\n         redis_url = os.getenv(\"REDIS_URL\")\n         if not redis_url:\n             # Fallback to component parts\n             host = os.getenv(\"REDIS_HOST\", \"localhost\")\n             port = os.getenv(\"REDIS_PORT\", \"6382\")\n             db = os.getenv(\"REDIS_DB\", \"0\")\n             password = os.getenv(\"REDIS_PASSWORD\", \"\")\n-            \n+\n             if password:\n                 redis_url = f\"redis://:{password}@{host}:{port}/{db}\"\n             else:\n                 redis_url = f\"redis://{host}:{port}/{db}\"\n-        \n-        logger.info(f\"Redis URL configured: {redis_url.split('@')[-1] if '@' in redis_url else redis_url}\")\n+\n+        logger.info(\n+            f\"Redis URL configured: {redis_url.split('@')[-1] if '@' in redis_url else redis_url}\"\n+        )\n         return redis_url\n-    \n+\n     def _create_sync_client(self) -> redis.Redis:\n         \"\"\"Create synchronous Redis client\"\"\"\n         client = redis.from_url(\n             self.redis_url,\n             encoding=\"utf-8\",\n             decode_responses=True,\n             max_connections=self.max_connections,\n             health_check_interval=30,\n         )\n-        \n+\n         # Test connection\n         try:\n             client.ping()\n             logger.info(\"Redis sync client connected successfully\")\n         except Exception as e:\n             logger.error(f\"Failed to connect to Redis: {e}\")\n             raise\n-        \n+\n         return client\n-    \n+\n     async def _create_async_client(self) -> aioredis.Redis:\n         \"\"\"Create asynchronous Redis client\"\"\"\n         if self.async_client is None:\n             self.async_client = aioredis.from_url(\n                 self.redis_url,\n                 encoding=\"utf-8\",\n                 decode_responses=True,\n                 max_connections=self.max_connections,\n                 health_check_interval=30,\n             )\n-            \n+\n             # Test connection\n             try:\n                 await self.async_client.ping()\n                 logger.info(\"Redis async client connected successfully\")\n             except Exception as e:\n                 logger.error(f\"Failed to connect to Redis async: {e}\")\n                 raise\n-        \n+\n         return self.async_client\n-    \n+\n     def health_check(self) -> bool:\n         \"\"\"Check Redis connectivity\"\"\"\n         try:\n             self.sync_client.ping()\n             return True\n         except Exception as e:\n             logger.error(f\"Redis health check failed: {e}\")\n             return False\n-    \n+\n     async def async_health_check(self) -> bool:\n         \"\"\"Check Redis connectivity (async)\"\"\"\n         try:\n             client = await self._create_async_client()\n             await client.ping()\n             return True\n         except Exception as e:\n             logger.error(f\"Redis async health check failed: {e}\")\n             return False\n \n+\n # Global Redis configuration\n redis_config = RedisConfig()\n \n+\n class CacheManager:\n     \"\"\"Generic caching functionality\"\"\"\n-    \n+\n     def __init__(self, redis_client: redis.Redis, prefix: str = \"comm\"):\n         self.client = redis_client\n         self.prefix = prefix\n-    \n+\n     def _key(self, key: str) -> str:\n         \"\"\"Add service prefix to cache key\"\"\"\n         return f\"{self.prefix}:{key}\"\n-    \n+\n     def set(self, key: str, value: Any, ttl: Optional[int] = None) -> bool:\n         \"\"\"Set cache value with optional TTL\"\"\"\n         try:\n             ttl = ttl or redis_config.cache_ttl\n-            serialized_value = json.dumps(value) if not isinstance(value, str) else value\n-            \n+            serialized_value = (\n+                json.dumps(value) if not isinstance(value, str) else value\n+            )\n+\n             if ttl:\n                 return self.client.setex(self._key(key), ttl, serialized_value)\n             else:\n                 return self.client.set(self._key(key), serialized_value)\n         except Exception as e:\n             logger.error(f\"Cache set error for key {key}: {e}\")\n             return False\n-    \n+\n     def get(self, key: str, default: Any = None) -> Any:\n         \"\"\"Get cache value\"\"\"\n         try:\n             value = self.client.get(self._key(key))\n             if value is None:\n                 return default\n-            \n+\n             # Try to deserialize JSON\n             try:\n                 return json.loads(value)\n             except json.JSONDecodeError:\n                 return value\n         except Exception as e:\n             logger.error(f\"Cache get error for key {key}: {e}\")\n             return default\n-    \n+\n     def delete(self, key: str) -> bool:\n         \"\"\"Delete cache entry\"\"\"\n         try:\n             return bool(self.client.delete(self._key(key)))\n         except Exception as e:\n             logger.error(f\"Cache delete error for key {key}: {e}\")\n             return False\n-    \n+\n     def exists(self, key: str) -> bool:\n         \"\"\"Check if cache key exists\"\"\"\n         try:\n             return bool(self.client.exists(self._key(key)))\n         except Exception as e:\n             logger.error(f\"Cache exists error for key {key}: {e}\")\n             return False\n-    \n+\n     def ttl(self, key: str) -> int:\n         \"\"\"Get time to live for cache key\"\"\"\n         try:\n             return self.client.ttl(self._key(key))\n         except Exception as e:\n             logger.error(f\"Cache TTL error for key {key}: {e}\")\n             return -1\n-    \n+\n     def clear_pattern(self, pattern: str) -> int:\n         \"\"\"Clear all keys matching pattern\"\"\"\n         try:\n             keys = self.client.keys(self._key(pattern))\n             if keys:\n@@ -181,125 +189,131 @@\n             return 0\n         except Exception as e:\n             logger.error(f\"Cache clear pattern error for {pattern}: {e}\")\n             return 0\n \n+\n class TemplateCache:\n     \"\"\"Specialized caching for notification templates\"\"\"\n-    \n+\n     def __init__(self, cache_manager: CacheManager):\n         self.cache = cache_manager\n-    \n+\n     def get_template(self, template_id: str) -> Optional[Dict[str, Any]]:\n         \"\"\"Get cached template\"\"\"\n         return self.cache.get(f\"template:{template_id}\")\n-    \n-    def set_template(self, template_id: str, template_data: Dict[str, Any], ttl: int = 1800) -> bool:\n+\n+    def set_template(\n+        self, template_id: str, template_data: Dict[str, Any], ttl: int = 1800\n+    ) -> bool:\n         \"\"\"Cache template for 30 minutes by default\"\"\"\n         return self.cache.set(f\"template:{template_id}\", template_data, ttl)\n-    \n+\n     def invalidate_template(self, template_id: str) -> bool:\n         \"\"\"Remove template from cache\"\"\"\n         return self.cache.delete(f\"template:{template_id}\")\n-    \n+\n     def get_rendered_template(self, template_id: str, data_hash: str) -> Optional[str]:\n         \"\"\"Get cached rendered template\"\"\"\n         cache_key = f\"rendered:{template_id}:{data_hash}\"\n         return self.cache.get(cache_key)\n-    \n+\n     def set_rendered_template(\n-        self, \n-        template_id: str, \n-        data_hash: str, \n-        rendered_content: str, \n-        ttl: int = 300\n+        self, template_id: str, data_hash: str, rendered_content: str, ttl: int = 300\n     ) -> bool:\n         \"\"\"Cache rendered template for 5 minutes by default\"\"\"\n         cache_key = f\"rendered:{template_id}:{data_hash}\"\n         return self.cache.set(cache_key, rendered_content, ttl)\n \n+\n class UserPreferenceCache:\n     \"\"\"Caching for user notification preferences\"\"\"\n-    \n+\n     def __init__(self, cache_manager: CacheManager):\n         self.cache = cache_manager\n-    \n+\n     def get_preferences(self, user_id: str) -> Optional[Dict[str, Any]]:\n         \"\"\"Get cached user preferences\"\"\"\n         return self.cache.get(f\"prefs:{user_id}\")\n-    \n-    def set_preferences(self, user_id: str, preferences: Dict[str, Any], ttl: int = 1800) -> bool:\n+\n+    def set_preferences(\n+        self, user_id: str, preferences: Dict[str, Any], ttl: int = 1800\n+    ) -> bool:\n         \"\"\"Cache user preferences for 30 minutes\"\"\"\n         return self.cache.set(f\"prefs:{user_id}\", preferences, ttl)\n-    \n+\n     def invalidate_preferences(self, user_id: str) -> bool:\n         \"\"\"Remove user preferences from cache\"\"\"\n         return self.cache.delete(f\"prefs:{user_id}\")\n \n+\n class SessionManager:\n     \"\"\"WebSocket session management for real-time features\"\"\"\n-    \n+\n     def __init__(self, cache_manager: CacheManager):\n         self.cache = cache_manager\n-    \n-    def create_session(self, user_id: str, session_id: str, metadata: Dict[str, Any]) -> bool:\n+\n+    def create_session(\n+        self, user_id: str, session_id: str, metadata: Dict[str, Any]\n+    ) -> bool:\n         \"\"\"Create user session\"\"\"\n         session_data = {\n             \"user_id\": user_id,\n             \"created_at\": datetime.utcnow().isoformat(),\n-            \"metadata\": metadata\n+            \"metadata\": metadata,\n         }\n         return self.cache.set(f\"session:{session_id}\", session_data, ttl=3600)  # 1 hour\n-    \n+\n     def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:\n         \"\"\"Get session data\"\"\"\n         return self.cache.get(f\"session:{session_id}\")\n-    \n+\n     def update_session_activity(self, session_id: str) -> bool:\n         \"\"\"Update session last activity\"\"\"\n         session = self.get_session(session_id)\n         if session:\n             session[\"last_activity\"] = datetime.utcnow().isoformat()\n             return self.cache.set(f\"session:{session_id}\", session, ttl=3600)\n         return False\n-    \n+\n     def delete_session(self, session_id: str) -> bool:\n         \"\"\"Delete session\"\"\"\n         return self.cache.delete(f\"session:{session_id}\")\n-    \n+\n     def get_user_sessions(self, user_id: str) -> List[str]:\n         \"\"\"Get all session IDs for a user\"\"\"\n         pattern = \"session:*\"\n         session_keys = redis_config.sync_client.keys(f\"comm:{pattern}\")\n-        \n+\n         user_sessions = []\n         for key in session_keys:\n             session_data = self.cache.get(key.replace(\"comm:\", \"\"))\n             if session_data and session_data.get(\"user_id\") == user_id:\n                 session_id = key.split(\":\")[-1]\n                 user_sessions.append(session_id)\n-        \n+\n         return user_sessions\n+\n \n class NotificationQueue:\n     \"\"\"Queue management for background notification processing\"\"\"\n-    \n+\n     def __init__(self, redis_client: redis.Redis):\n         self.client = redis_client\n         self.queue_name = \"comm:notification_queue\"\n         self.processing_queue = \"comm:processing_queue\"\n         self.failed_queue = \"comm:failed_queue\"\n-    \n+\n     def enqueue_notification(self, notification_data: Dict[str, Any]) -> bool:\n         \"\"\"Add notification to processing queue\"\"\"\n         try:\n             serialized = json.dumps(notification_data)\n             return bool(self.client.lpush(self.queue_name, serialized))\n         except Exception as e:\n             logger.error(f\"Failed to enqueue notification: {e}\")\n             return False\n-    \n+\n     def dequeue_notification(self, timeout: int = 0) -> Optional[Dict[str, Any]]:\n         \"\"\"Get next notification from queue\"\"\"\n         try:\n             result = self.client.brpop(self.queue_name, timeout=timeout)\n             if result:\n@@ -307,35 +321,37 @@\n                 return json.loads(data)\n             return None\n         except Exception as e:\n             logger.error(f\"Failed to dequeue notification: {e}\")\n             return None\n-    \n+\n     def get_queue_length(self) -> int:\n         \"\"\"Get current queue length\"\"\"\n         try:\n             return self.client.llen(self.queue_name)\n         except Exception as e:\n             logger.error(f\"Failed to get queue length: {e}\")\n             return 0\n-    \n+\n     def move_to_failed(self, notification_data: Dict[str, Any]) -> bool:\n         \"\"\"Move failed notification to failed queue\"\"\"\n         try:\n             notification_data[\"failed_at\"] = datetime.utcnow().isoformat()\n             serialized = json.dumps(notification_data)\n             return bool(self.client.lpush(self.failed_queue, serialized))\n         except Exception as e:\n             logger.error(f\"Failed to move notification to failed queue: {e}\")\n             return False\n+\n \n # Initialize global instances\n cache_manager = CacheManager(redis_config.sync_client)\n template_cache = TemplateCache(cache_manager)\n user_preference_cache = UserPreferenceCache(cache_manager)\n session_manager = SessionManager(cache_manager)\n notification_queue = NotificationQueue(redis_config.sync_client)\n+\n \n # Utility functions\n def get_cache_stats() -> Dict[str, Any]:\n     \"\"\"Get Redis cache statistics\"\"\"\n     try:\n@@ -347,15 +363,16 @@\n             \"total_commands_processed\": info.get(\"total_commands_processed\"),\n             \"keyspace\": info.get(\"db0\", {}),\n             \"queue_lengths\": {\n                 \"notifications\": notification_queue.get_queue_length(),\n                 \"failed\": redis_config.sync_client.llen(\"comm:failed_queue\"),\n-            }\n+            },\n         }\n     except Exception as e:\n         logger.error(f\"Failed to get cache stats: {e}\")\n         return {\"error\": str(e)}\n+\n \n def clear_all_cache() -> bool:\n     \"\"\"Clear all communication service cache entries\"\"\"\n     try:\n         keys = redis_config.sync_client.keys(\"comm:*\")\n@@ -363,6 +380,6 @@\n             redis_config.sync_client.delete(*keys)\n             logger.info(f\"Cleared {len(keys)} cache entries\")\n         return True\n     except Exception as e:\n         logger.error(f\"Failed to clear cache: {e}\")\n-        return False\n\\ No newline at end of file\n+        return False\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/performance/__init__.py\t2025-09-09 19:33:56.021013+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/performance/__init__.py\t2025-09-10 11:37:01.600766+00:00\n@@ -1 +1 @@\n-# Performance testing module for Communication Service\n\\ No newline at end of file\n+# Performance testing module for Communication Service\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tasks/monitoring_tasks.py\t2025-09-09 14:30:03.917132+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tasks/monitoring_tasks.py\t2025-09-10 11:37:01.585280+00:00\n@@ -1,9 +1,10 @@\n \"\"\"\n Monitoring and Statistics Celery Tasks\n Background tasks for system monitoring and reporting\n \"\"\"\n+\n import asyncio\n from datetime import datetime, timedelta\n from typing import Dict, Any, List\n import logging\n \n@@ -18,46 +19,51 @@\n \n @celery_app.task(bind=True)\n def update_notification_statistics(self):\n     \"\"\"Update notification delivery statistics\"\"\"\n     try:\n+\n         async def collect_stats():\n             async with get_db_session() as session:\n                 # Get statistics for the last 24 hours\n                 yesterday = datetime.utcnow() - timedelta(days=1)\n-                \n+\n                 # Overall statistics\n                 total_result = await session.execute(\n                     \"SELECT COUNT(*) FROM notifications WHERE created_at >= :yesterday\",\n-                    {\"yesterday\": yesterday}\n+                    {\"yesterday\": yesterday},\n                 )\n                 total_notifications = total_result.scalar()\n-                \n+\n                 # Statistics by status\n                 status_result = await session.execute(\n                     \"\"\"\n                     SELECT status, COUNT(*) as count \n                     FROM notifications \n                     WHERE created_at >= :yesterday \n                     GROUP BY status\n                     \"\"\",\n-                    {\"yesterday\": yesterday}\n-                )\n-                status_stats = {row.status: row.count for row in status_result.fetchall()}\n-                \n+                    {\"yesterday\": yesterday},\n+                )\n+                status_stats = {\n+                    row.status: row.count for row in status_result.fetchall()\n+                }\n+\n                 # Statistics by channel\n                 channel_result = await session.execute(\n                     \"\"\"\n                     SELECT channel, COUNT(*) as count \n                     FROM notifications \n                     WHERE created_at >= :yesterday \n                     GROUP BY channel\n                     \"\"\",\n-                    {\"yesterday\": yesterday}\n-                )\n-                channel_stats = {row.channel: row.count for row in channel_result.fetchall()}\n-                \n+                    {\"yesterday\": yesterday},\n+                )\n+                channel_stats = {\n+                    row.channel: row.count for row in channel_result.fetchall()\n+                }\n+\n                 # Error statistics\n                 error_result = await session.execute(\n                     \"\"\"\n                     SELECT error_message, COUNT(*) as count \n                     FROM notifications \n@@ -66,207 +72,219 @@\n                     AND error_message IS NOT NULL\n                     GROUP BY error_message \n                     ORDER BY count DESC \n                     LIMIT 10\n                     \"\"\",\n-                    {\"yesterday\": yesterday}\n-                )\n-                error_stats = {row.error_message: row.count for row in error_result.fetchall()}\n-                \n+                    {\"yesterday\": yesterday},\n+                )\n+                error_stats = {\n+                    row.error_message: row.count for row in error_result.fetchall()\n+                }\n+\n                 return {\n                     \"total_notifications\": total_notifications,\n                     \"status_breakdown\": status_stats,\n                     \"channel_breakdown\": channel_stats,\n-                    \"top_errors\": error_stats\n-                }\n-        \n+                    \"top_errors\": error_stats,\n+                }\n+\n         stats = asyncio.run(collect_stats())\n-        \n+\n         # Store stats in Redis for quick access\n         async def store_stats():\n             redis_client = await get_redis_client()\n-            stats_key = f\"notification_stats:{datetime.utcnow().strftime('%Y-%m-%d-%H')}\"\n-            \n+            stats_key = (\n+                f\"notification_stats:{datetime.utcnow().strftime('%Y-%m-%d-%H')}\"\n+            )\n+\n             await redis_client.setex(\n                 stats_key,\n                 3600,  # 1 hour TTL\n-                str(stats)  # Would use JSON in production\n+                str(stats),  # Would use JSON in production\n             )\n-        \n+\n         asyncio.run(store_stats())\n-        \n+\n         return {\n             \"status\": \"completed\",\n             \"statistics\": stats,\n-            \"updated_at\": datetime.utcnow().isoformat()\n+            \"updated_at\": datetime.utcnow().isoformat(),\n         }\n-        \n+\n     except Exception as exc:\n         logger.error(f\"Statistics update failed: {exc}\")\n         raise\n \n \n @celery_app.task(bind=True)\n def check_provider_health(self):\n     \"\"\"Check health of all notification providers\"\"\"\n     try:\n+\n         async def check_all_providers():\n             health_results = {}\n-            \n+\n             # Check email provider\n             try:\n-                email_provider = create_email_provider(\"smtp\", {\n-                    \"smtp_host\": \"localhost\",\n-                    \"smtp_port\": 587,\n-                    \"enabled\": True\n-                })\n+                email_provider = create_email_provider(\n+                    \"smtp\",\n+                    {\"smtp_host\": \"localhost\", \"smtp_port\": 587, \"enabled\": True},\n+                )\n                 health_results[\"email\"] = await email_provider.health_check()\n             except Exception as e:\n                 health_results[\"email\"] = False\n                 logger.warning(f\"Email provider health check failed: {e}\")\n-            \n+\n             # Check SMS provider (if configured)\n             try:\n-                sms_provider = create_sms_provider(\"twilio\", {\n-                    \"account_sid\": \"test\",\n-                    \"auth_token\": \"test\",\n-                    \"from_number\": \"+1234567890\",\n-                    \"enabled\": True\n-                })\n+                sms_provider = create_sms_provider(\n+                    \"twilio\",\n+                    {\n+                        \"account_sid\": \"test\",\n+                        \"auth_token\": \"test\",\n+                        \"from_number\": \"+1234567890\",\n+                        \"enabled\": True,\n+                    },\n+                )\n                 health_results[\"sms\"] = await sms_provider.health_check()\n             except Exception as e:\n                 health_results[\"sms\"] = False\n                 logger.warning(f\"SMS provider health check failed: {e}\")\n-            \n+\n             # Check push provider (if configured)\n             try:\n-                push_provider = create_push_provider(\"firebase\", {\n-                    \"project_id\": \"test\",\n-                    \"private_key\": \"test\",\n-                    \"client_email\": \"test@example.com\",\n-                    \"enabled\": True\n-                })\n+                push_provider = create_push_provider(\n+                    \"firebase\",\n+                    {\n+                        \"project_id\": \"test\",\n+                        \"private_key\": \"test\",\n+                        \"client_email\": \"test@example.com\",\n+                        \"enabled\": True,\n+                    },\n+                )\n                 health_results[\"push\"] = await push_provider.health_check()\n             except Exception as e:\n                 health_results[\"push\"] = False\n                 logger.warning(f\"Push provider health check failed: {e}\")\n-            \n+\n             # Check in-app provider\n             try:\n                 in_app_provider = InAppProvider({\"enabled\": True})\n                 health_results[\"in_app\"] = await in_app_provider.health_check()\n             except Exception as e:\n                 health_results[\"in_app\"] = False\n                 logger.warning(f\"In-app provider health check failed: {e}\")\n-            \n+\n             return health_results\n-        \n+\n         health_status = asyncio.run(check_all_providers())\n-        \n+\n         # Store health status in Redis\n         async def store_health_status():\n             redis_client = await get_redis_client()\n             await redis_client.setex(\n-                \"provider_health_status\",\n-                300,  # 5 minute TTL\n-                str(health_status)\n+                \"provider_health_status\", 300, str(health_status)  # 5 minute TTL\n             )\n-        \n+\n         asyncio.run(store_health_status())\n-        \n+\n         # Count healthy vs unhealthy providers\n         healthy_count = sum(1 for status in health_status.values() if status)\n         total_count = len(health_status)\n-        \n+\n         return {\n             \"status\": \"completed\",\n             \"provider_health\": health_status,\n             \"healthy_providers\": healthy_count,\n             \"total_providers\": total_count,\n             \"all_healthy\": healthy_count == total_count,\n-            \"checked_at\": datetime.utcnow().isoformat()\n+            \"checked_at\": datetime.utcnow().isoformat(),\n         }\n-        \n+\n     except Exception as exc:\n         logger.error(f\"Provider health check failed: {exc}\")\n         raise\n \n \n @celery_app.task(bind=True)\n def generate_daily_report(self, date: str = None):\n     \"\"\"\n     Generate daily notification report\n-    \n+\n     Args:\n         date: Date in YYYY-MM-DD format (defaults to yesterday)\n     \"\"\"\n     try:\n         if date:\n             report_date = datetime.strptime(date, \"%Y-%m-%d\").date()\n         else:\n             report_date = (datetime.utcnow() - timedelta(days=1)).date()\n-        \n+\n         async def generate_report():\n             async with get_db_session() as session:\n                 start_date = datetime.combine(report_date, datetime.min.time())\n                 end_date = start_date + timedelta(days=1)\n-                \n+\n                 # Total notifications\n                 total_result = await session.execute(\n                     \"\"\"\n                     SELECT COUNT(*) FROM notifications \n                     WHERE created_at >= :start_date AND created_at < :end_date\n                     \"\"\",\n-                    {\"start_date\": start_date, \"end_date\": end_date}\n+                    {\"start_date\": start_date, \"end_date\": end_date},\n                 )\n                 total_notifications = total_result.scalar()\n-                \n+\n                 # Success rate\n                 success_result = await session.execute(\n                     \"\"\"\n                     SELECT COUNT(*) FROM notifications \n                     WHERE created_at >= :start_date AND created_at < :end_date\n                     AND status IN ('sent', 'delivered')\n                     \"\"\",\n-                    {\"start_date\": start_date, \"end_date\": end_date}\n+                    {\"start_date\": start_date, \"end_date\": end_date},\n                 )\n                 successful_notifications = success_result.scalar()\n-                \n+\n                 # Channel breakdown\n                 channel_result = await session.execute(\n                     \"\"\"\n                     SELECT channel, COUNT(*) as count,\n                            SUM(CASE WHEN status IN ('sent', 'delivered') THEN 1 ELSE 0 END) as successful\n                     FROM notifications \n                     WHERE created_at >= :start_date AND created_at < :end_date\n                     GROUP BY channel\n                     \"\"\",\n-                    {\"start_date\": start_date, \"end_date\": end_date}\n-                )\n-                \n+                    {\"start_date\": start_date, \"end_date\": end_date},\n+                )\n+\n                 channel_breakdown = {}\n                 for row in channel_result.fetchall():\n                     channel_breakdown[row.channel] = {\n                         \"total\": row.count,\n                         \"successful\": row.successful,\n-                        \"success_rate\": (row.successful / row.count * 100) if row.count > 0 else 0\n+                        \"success_rate\": (\n+                            (row.successful / row.count * 100) if row.count > 0 else 0\n+                        ),\n                     }\n-                \n+\n                 # Hourly distribution\n                 hourly_result = await session.execute(\n                     \"\"\"\n                     SELECT EXTRACT(hour FROM created_at) as hour, COUNT(*) as count\n                     FROM notifications \n                     WHERE created_at >= :start_date AND created_at < :end_date\n                     GROUP BY EXTRACT(hour FROM created_at)\n                     ORDER BY hour\n                     \"\"\",\n-                    {\"start_date\": start_date, \"end_date\": end_date}\n-                )\n-                \n-                hourly_distribution = {int(row.hour): row.count for row in hourly_result.fetchall()}\n-                \n+                    {\"start_date\": start_date, \"end_date\": end_date},\n+                )\n+\n+                hourly_distribution = {\n+                    int(row.hour): row.count for row in hourly_result.fetchall()\n+                }\n+\n                 # Top failure reasons\n                 failure_result = await session.execute(\n                     \"\"\"\n                     SELECT error_message, COUNT(*) as count\n                     FROM notifications \n@@ -275,173 +293,185 @@\n                     AND error_message IS NOT NULL\n                     GROUP BY error_message\n                     ORDER BY count DESC\n                     LIMIT 5\n                     \"\"\",\n-                    {\"start_date\": start_date, \"end_date\": end_date}\n-                )\n-                \n-                top_failures = {row.error_message: row.count for row in failure_result.fetchall()}\n-                \n+                    {\"start_date\": start_date, \"end_date\": end_date},\n+                )\n+\n+                top_failures = {\n+                    row.error_message: row.count for row in failure_result.fetchall()\n+                }\n+\n                 return {\n                     \"date\": report_date.isoformat(),\n                     \"total_notifications\": total_notifications,\n                     \"successful_notifications\": successful_notifications,\n-                    \"success_rate\": (successful_notifications / total_notifications * 100) if total_notifications > 0 else 0,\n+                    \"success_rate\": (\n+                        (successful_notifications / total_notifications * 100)\n+                        if total_notifications > 0\n+                        else 0\n+                    ),\n                     \"channel_breakdown\": channel_breakdown,\n                     \"hourly_distribution\": hourly_distribution,\n-                    \"top_failure_reasons\": top_failures\n-                }\n-        \n+                    \"top_failure_reasons\": top_failures,\n+                }\n+\n         report = asyncio.run(generate_report())\n-        \n+\n         # Store report in Redis\n         async def store_report():\n             redis_client = await get_redis_client()\n             report_key = f\"daily_report:{report_date.isoformat()}\"\n-            \n+\n             await redis_client.setex(\n-                report_key,\n-                86400 * 7,  # Keep for 7 days\n-                str(report)\n+                report_key, 86400 * 7, str(report)  # Keep for 7 days\n             )\n-        \n+\n         asyncio.run(store_report())\n-        \n+\n         return {\n             \"status\": \"completed\",\n             \"report\": report,\n-            \"generated_at\": datetime.utcnow().isoformat()\n+            \"generated_at\": datetime.utcnow().isoformat(),\n         }\n-        \n+\n     except Exception as exc:\n         logger.error(f\"Daily report generation failed: {exc}\")\n         raise\n \n \n @celery_app.task(bind=True)\n def monitor_queue_health(self):\n     \"\"\"Monitor Celery queue health and performance\"\"\"\n     try:\n         from celery import current_app\n-        \n+\n         # Get queue statistics\n         inspect = current_app.control.inspect()\n-        \n+\n         # Active tasks\n         active_tasks = inspect.active()\n         active_count = sum(len(tasks) for tasks in (active_tasks or {}).values())\n-        \n+\n         # Reserved tasks\n         reserved_tasks = inspect.reserved()\n         reserved_count = sum(len(tasks) for tasks in (reserved_tasks or {}).values())\n-        \n+\n         # Queue lengths (approximate)\n         async def get_queue_lengths():\n             redis_client = await get_redis_client()\n-            \n-            queues = [\"notifications\", \"bulk\", \"scheduled\", \"templates\", \"maintenance\", \"monitoring\"]\n+\n+            queues = [\n+                \"notifications\",\n+                \"bulk\",\n+                \"scheduled\",\n+                \"templates\",\n+                \"maintenance\",\n+                \"monitoring\",\n+            ]\n             queue_lengths = {}\n-            \n+\n             for queue in queues:\n                 length = await redis_client.llen(f\"celery:{queue}\")\n                 queue_lengths[queue] = length\n-            \n+\n             return queue_lengths\n-        \n+\n         queue_lengths = asyncio.run(get_queue_lengths())\n-        \n+\n         # Calculate queue health score\n         total_queued = sum(queue_lengths.values())\n         health_score = 100\n-        \n+\n         if total_queued > 1000:\n             health_score -= 30\n         elif total_queued > 500:\n             health_score -= 20\n         elif total_queued > 100:\n             health_score -= 10\n-        \n+\n         if active_count > 50:\n             health_score -= 20\n         elif active_count > 20:\n             health_score -= 10\n-        \n+\n         return {\n             \"status\": \"completed\",\n             \"queue_health\": {\n                 \"health_score\": health_score,\n                 \"active_tasks\": active_count,\n                 \"reserved_tasks\": reserved_count,\n                 \"queue_lengths\": queue_lengths,\n-                \"total_queued\": total_queued\n+                \"total_queued\": total_queued,\n             },\n-            \"checked_at\": datetime.utcnow().isoformat()\n+            \"checked_at\": datetime.utcnow().isoformat(),\n         }\n-        \n+\n     except Exception as exc:\n         logger.error(f\"Queue health monitoring failed: {exc}\")\n         raise\n \n \n @celery_app.task(bind=True)\n def alert_on_high_failure_rate(self, threshold: float = 10.0):\n     \"\"\"\n     Alert if notification failure rate exceeds threshold\n-    \n+\n     Args:\n         threshold: Failure rate threshold percentage (default: 10%)\n     \"\"\"\n     try:\n+\n         async def check_failure_rate():\n             async with get_db_session() as session:\n                 # Check failure rate in last hour\n                 last_hour = datetime.utcnow() - timedelta(hours=1)\n-                \n+\n                 total_result = await session.execute(\n                     \"SELECT COUNT(*) FROM notifications WHERE created_at >= :last_hour\",\n-                    {\"last_hour\": last_hour}\n+                    {\"last_hour\": last_hour},\n                 )\n                 total_notifications = total_result.scalar()\n-                \n+\n                 if total_notifications == 0:\n                     return {\"failure_rate\": 0, \"total\": 0, \"failed\": 0, \"alert\": False}\n-                \n+\n                 failed_result = await session.execute(\n                     \"\"\"\n                     SELECT COUNT(*) FROM notifications \n                     WHERE created_at >= :last_hour AND status = 'failed'\n                     \"\"\",\n-                    {\"last_hour\": last_hour}\n+                    {\"last_hour\": last_hour},\n                 )\n                 failed_notifications = failed_result.scalar()\n-                \n+\n                 failure_rate = (failed_notifications / total_notifications) * 100\n-                \n+\n                 return {\n                     \"failure_rate\": failure_rate,\n                     \"total\": total_notifications,\n                     \"failed\": failed_notifications,\n-                    \"alert\": failure_rate > threshold\n-                }\n-        \n+                    \"alert\": failure_rate > threshold,\n+                }\n+\n         result = asyncio.run(check_failure_rate())\n-        \n+\n         if result[\"alert\"]:\n             logger.warning(\n                 f\"High failure rate alert: {result['failure_rate']:.2f}% \"\n                 f\"({result['failed']}/{result['total']}) in the last hour\"\n             )\n-            \n+\n             # In production, this would send an alert notification\n             # to administrators via email, Slack, etc.\n-        \n+\n         return {\n             \"status\": \"completed\",\n             \"failure_rate_check\": result,\n             \"threshold\": threshold,\n-            \"checked_at\": datetime.utcnow().isoformat()\n+            \"checked_at\": datetime.utcnow().isoformat(),\n         }\n-        \n+\n     except Exception as exc:\n         logger.error(f\"Failure rate monitoring failed: {exc}\")\n-        raise\n\\ No newline at end of file\n+        raise\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/template_engine.py\t2025-09-09 14:26:37.480078+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/template_engine.py\t2025-09-10 11:37:01.746819+00:00\n@@ -1,17 +1,24 @@\n \"\"\"\n Notification Template Engine\n Jinja2-based template rendering with multi-channel support and variable validation\n \"\"\"\n+\n import asyncio\n from datetime import datetime, timedelta\n from typing import Dict, Any, Optional, List, Union\n import uuid\n import json\n import logging\n from pathlib import Path\n-from jinja2 import Environment, FileSystemLoader, BaseLoader, TemplateNotFound, TemplateSyntaxError\n+from jinja2 import (\n+    Environment,\n+    FileSystemLoader,\n+    BaseLoader,\n+    TemplateNotFound,\n+    TemplateSyntaxError,\n+)\n from jinja2.sandbox import SandboxedEnvironment\n import bleach\n from sqlalchemy.orm import Session\n import aiofiles\n \n@@ -22,459 +29,494 @@\n logger = logging.getLogger(__name__)\n \n \n class DatabaseTemplateLoader(BaseLoader):\n     \"\"\"Custom Jinja2 loader that loads templates from database\"\"\"\n-    \n+\n     def __init__(self):\n         self.db_session = None\n-    \n+\n     async def get_db_session(self):\n         if not self.db_session:\n             self.db_session = get_db_session()\n         return self.db_session\n-    \n+\n     def get_source(self, environment, template_name):\n         \"\"\"Load template from database\"\"\"\n         try:\n             # Parse template name: \"template_id:channel\" or just \"template_id\"\n             parts = template_name.split(\":\")\n             template_id = parts[0]\n             channel = parts[1] if len(parts) > 1 else None\n-            \n+\n             # Query database for template\n             session = get_db_session()\n             query = session.query(NotificationTemplate).filter(\n                 NotificationTemplate.id == uuid.UUID(template_id),\n-                NotificationTemplate.is_active == True\n-            )\n-            \n+                NotificationTemplate.is_active == True,\n+            )\n+\n             if channel:\n-                query = query.filter(NotificationTemplate.channel == NotificationChannel(channel))\n-            \n+                query = query.filter(\n+                    NotificationTemplate.channel == NotificationChannel(channel)\n+                )\n+\n             template = query.first()\n-            \n+\n             if not template:\n                 raise TemplateNotFound(template_name)\n-            \n+\n             source = template.content\n-            mtime = template.updated_at.timestamp() if template.updated_at else datetime.utcnow().timestamp()\n-            \n+            mtime = (\n+                template.updated_at.timestamp()\n+                if template.updated_at\n+                else datetime.utcnow().timestamp()\n+            )\n+\n             def uptodate():\n                 # Check if template has been modified\n-                current_template = session.query(NotificationTemplate).filter(\n-                    NotificationTemplate.id == template.id\n-                ).first()\n-                return current_template and current_template.updated_at.timestamp() == mtime\n-            \n+                current_template = (\n+                    session.query(NotificationTemplate)\n+                    .filter(NotificationTemplate.id == template.id)\n+                    .first()\n+                )\n+                return (\n+                    current_template\n+                    and current_template.updated_at.timestamp() == mtime\n+                )\n+\n             return source, None, uptodate\n-            \n+\n         except Exception as e:\n             logger.error(f\"Failed to load template {template_name}: {e}\")\n             raise TemplateNotFound(template_name)\n \n \n class TemplateEngine:\n     \"\"\"Advanced template engine for multi-channel notifications\"\"\"\n-    \n+\n     def __init__(self, config: Dict[str, Any] = None):\n         self.config = config or {}\n         self.template_dirs = self.config.get(\"template_dirs\", [\"templates\"])\n         self.cache_enabled = self.config.get(\"cache_enabled\", True)\n         self.cache_ttl = self.config.get(\"cache_ttl_seconds\", 3600)\n         self.sandbox_enabled = self.config.get(\"sandbox_enabled\", True)\n         self.auto_escape = self.config.get(\"auto_escape\", True)\n         self.redis_client = None\n-        \n+\n         # Initialize Jinja2 environment\n         self._setup_jinja_env()\n-        \n+\n     def _setup_jinja_env(self):\n         \"\"\"Setup Jinja2 environment with appropriate settings\"\"\"\n         if self.sandbox_enabled:\n             # Use sandboxed environment for security\n             self.jinja_env = SandboxedEnvironment(\n                 loader=DatabaseTemplateLoader(),\n                 autoescape=self.auto_escape,\n                 trim_blocks=True,\n                 lstrip_blocks=True,\n-                enable_async=True\n+                enable_async=True,\n             )\n         else:\n             self.jinja_env = Environment(\n                 loader=DatabaseTemplateLoader(),\n                 autoescape=self.auto_escape,\n                 trim_blocks=True,\n                 lstrip_blocks=True,\n-                enable_async=True\n-            )\n-        \n+                enable_async=True,\n+            )\n+\n         # Add custom filters\n         self._add_custom_filters()\n-        \n+\n         # Add custom functions\n         self._add_custom_functions()\n-    \n+\n     def _add_custom_filters(self):\n         \"\"\"Add custom Jinja2 filters\"\"\"\n-        \n+\n         def format_currency(value, currency=\"USD\"):\n             \"\"\"Format value as currency\"\"\"\n             try:\n                 return f\"{float(value):.2f} {currency}\"\n             except (ValueError, TypeError):\n                 return str(value)\n-        \n+\n         def format_date(value, format=\"%Y-%m-%d\"):\n             \"\"\"Format datetime value\"\"\"\n             if isinstance(value, str):\n                 try:\n-                    value = datetime.fromisoformat(value.replace('Z', '+00:00'))\n+                    value = datetime.fromisoformat(value.replace(\"Z\", \"+00:00\"))\n                 except ValueError:\n                     return value\n-            \n+\n             if isinstance(value, datetime):\n                 return value.strftime(format)\n             return str(value)\n-        \n+\n         def truncate_words(value, length=50):\n             \"\"\"Truncate text to specified word count\"\"\"\n             words = str(value).split()\n             if len(words) <= length:\n                 return str(value)\n-            return ' '.join(words[:length]) + '...'\n-        \n+            return \" \".join(words[:length]) + \"...\"\n+\n         def sanitize_html(value):\n             \"\"\"Sanitize HTML content\"\"\"\n-            allowed_tags = ['p', 'br', 'strong', 'em', 'u', 'a', 'ul', 'ol', 'li']\n-            allowed_attributes = {'a': ['href']}\n-            return bleach.clean(str(value), tags=allowed_tags, attributes=allowed_attributes)\n-        \n+            allowed_tags = [\"p\", \"br\", \"strong\", \"em\", \"u\", \"a\", \"ul\", \"ol\", \"li\"]\n+            allowed_attributes = {\"a\": [\"href\"]}\n+            return bleach.clean(\n+                str(value), tags=allowed_tags, attributes=allowed_attributes\n+            )\n+\n         # Register filters\n-        self.jinja_env.filters['currency'] = format_currency\n-        self.jinja_env.filters['date'] = format_date\n-        self.jinja_env.filters['truncate_words'] = truncate_words\n-        self.jinja_env.filters['sanitize'] = sanitize_html\n-    \n+        self.jinja_env.filters[\"currency\"] = format_currency\n+        self.jinja_env.filters[\"date\"] = format_date\n+        self.jinja_env.filters[\"truncate_words\"] = truncate_words\n+        self.jinja_env.filters[\"sanitize\"] = sanitize_html\n+\n     def _add_custom_functions(self):\n         \"\"\"Add custom Jinja2 global functions\"\"\"\n-        \n+\n         def current_year():\n             \"\"\"Get current year\"\"\"\n             return datetime.now().year\n-        \n+\n         def current_date(format=\"%Y-%m-%d\"):\n             \"\"\"Get current date formatted\"\"\"\n             return datetime.now().strftime(format)\n-        \n+\n         def url_for(endpoint, **values):\n             \"\"\"Generate URL for endpoint (placeholder)\"\"\"\n             # This would integrate with your routing system\n             base_url = self.config.get(\"base_url\", \"https://example.com\")\n             return f\"{base_url}/{endpoint}\"\n-        \n+\n         # Register global functions\n-        self.jinja_env.globals['current_year'] = current_year\n-        self.jinja_env.globals['current_date'] = current_date\n-        self.jinja_env.globals['url_for'] = url_for\n-    \n+        self.jinja_env.globals[\"current_year\"] = current_year\n+        self.jinja_env.globals[\"current_date\"] = current_date\n+        self.jinja_env.globals[\"url_for\"] = url_for\n+\n     async def _get_redis_client(self):\n         \"\"\"Get Redis client for caching\"\"\"\n         if not self.redis_client:\n             self.redis_client = await get_redis_client()\n         return self.redis_client\n-    \n+\n     async def render_template(\n-        self, \n-        template_id: str, \n+        self,\n+        template_id: str,\n         variables: Dict[str, Any],\n-        channel: Optional[NotificationChannel] = None\n+        channel: Optional[NotificationChannel] = None,\n     ) -> Dict[str, str]:\n         \"\"\"\n         Render template with variables\n-        \n+\n         Args:\n             template_id: UUID of template to render\n             variables: Template variables\n             channel: Notification channel for channel-specific templates\n-            \n+\n         Returns:\n             Dict with 'subject' and 'content' keys\n         \"\"\"\n         try:\n             # Build template name for loader\n             template_name = template_id\n             if channel:\n                 template_name = f\"{template_id}:{channel.value}\"\n-            \n+\n             # Check cache first\n             if self.cache_enabled:\n                 cached_result = await self._get_from_cache(template_name, variables)\n                 if cached_result:\n                     return cached_result\n-            \n+\n             # Load and render template\n             template = self.jinja_env.get_template(template_name)\n-            \n+\n             # Get template metadata\n             template_data = await self._get_template_data(template_id)\n-            \n+\n             # Validate variables\n             self._validate_variables(variables, template_data.get(\"variables\", {}))\n-            \n+\n             # Render subject and content\n             subject = \"\"\n             if template_data.get(\"subject\"):\n                 subject_template = self.jinja_env.from_string(template_data[\"subject\"])\n                 subject = await subject_template.render_async(**variables)\n-            \n+\n             content = await template.render_async(**variables)\n-            \n+\n             # Post-process based on channel\n             if channel:\n                 content = await self._post_process_content(content, channel)\n-            \n-            result = {\n-                \"subject\": subject.strip(),\n-                \"content\": content.strip()\n-            }\n-            \n+\n+            result = {\"subject\": subject.strip(), \"content\": content.strip()}\n+\n             # Cache result\n             if self.cache_enabled:\n                 await self._cache_result(template_name, variables, result)\n-            \n+\n             return result\n-            \n+\n         except TemplateNotFound:\n             raise ValueError(f\"Template {template_id} not found\")\n         except TemplateSyntaxError as e:\n             raise ValueError(f\"Template syntax error: {str(e)}\")\n         except Exception as e:\n             logger.error(f\"Template rendering failed: {e}\")\n             raise\n-    \n+\n     async def _get_template_data(self, template_id: str) -> Dict[str, Any]:\n         \"\"\"Get template metadata from database\"\"\"\n         try:\n             async with get_db_session() as session:\n-                template = await session.get(NotificationTemplate, uuid.UUID(template_id))\n+                template = await session.get(\n+                    NotificationTemplate, uuid.UUID(template_id)\n+                )\n                 if not template:\n                     raise ValueError(f\"Template {template_id} not found\")\n-                \n+\n                 return {\n                     \"id\": str(template.id),\n                     \"name\": template.name,\n                     \"subject\": template.subject,\n                     \"variables\": template.variables or {},\n                     \"channel\": template.channel.value,\n                     \"language\": template.language,\n-                    \"version\": template.version\n+                    \"version\": template.version,\n                 }\n-                \n+\n         except Exception as e:\n             logger.error(f\"Failed to get template data for {template_id}: {e}\")\n             raise\n-    \n-    def _validate_variables(self, variables: Dict[str, Any], required_variables: Dict[str, str]):\n+\n+    def _validate_variables(\n+        self, variables: Dict[str, Any], required_variables: Dict[str, str]\n+    ):\n         \"\"\"Validate that all required variables are provided with correct types\"\"\"\n         missing_vars = []\n         type_errors = []\n-        \n+\n         for var_name, var_type in required_variables.items():\n             if var_name not in variables:\n                 missing_vars.append(var_name)\n                 continue\n-            \n+\n             value = variables[var_name]\n-            \n+\n             # Type checking\n             if var_type == \"string\" and not isinstance(value, str):\n-                type_errors.append(f\"{var_name} should be string, got {type(value).__name__}\")\n+                type_errors.append(\n+                    f\"{var_name} should be string, got {type(value).__name__}\"\n+                )\n             elif var_type == \"number\" and not isinstance(value, (int, float)):\n-                type_errors.append(f\"{var_name} should be number, got {type(value).__name__}\")\n+                type_errors.append(\n+                    f\"{var_name} should be number, got {type(value).__name__}\"\n+                )\n             elif var_type == \"boolean\" and not isinstance(value, bool):\n-                type_errors.append(f\"{var_name} should be boolean, got {type(value).__name__}\")\n+                type_errors.append(\n+                    f\"{var_name} should be boolean, got {type(value).__name__}\"\n+                )\n             elif var_type == \"date\" and not isinstance(value, (str, datetime)):\n-                type_errors.append(f\"{var_name} should be date string or datetime, got {type(value).__name__}\")\n-        \n+                type_errors.append(\n+                    f\"{var_name} should be date string or datetime, got {type(value).__name__}\"\n+                )\n+\n         if missing_vars:\n             raise ValueError(f\"Missing required variables: {', '.join(missing_vars)}\")\n-        \n+\n         if type_errors:\n             raise ValueError(f\"Variable type errors: {'; '.join(type_errors)}\")\n-    \n-    async def _post_process_content(self, content: str, channel: NotificationChannel) -> str:\n+\n+    async def _post_process_content(\n+        self, content: str, channel: NotificationChannel\n+    ) -> str:\n         \"\"\"Post-process content based on notification channel\"\"\"\n         if channel == NotificationChannel.SMS:\n             # Truncate for SMS\n             return content[:160]\n-        \n+\n         elif channel == NotificationChannel.EMAIL:\n             # Ensure HTML is clean for email\n             if \"<html>\" in content.lower() or \"<body>\" in content.lower():\n-                return bleach.clean(content, tags=bleach.ALLOWED_TAGS + ['html', 'body', 'head', 'title'])\n-        \n+                return bleach.clean(\n+                    content,\n+                    tags=bleach.ALLOWED_TAGS + [\"html\", \"body\", \"head\", \"title\"],\n+                )\n+\n         elif channel == NotificationChannel.PUSH:\n             # Truncate for push notifications\n             return content[:1000]\n-        \n+\n         return content\n-    \n-    async def _get_from_cache(self, template_name: str, variables: Dict[str, Any]) -> Optional[Dict[str, str]]:\n+\n+    async def _get_from_cache(\n+        self, template_name: str, variables: Dict[str, Any]\n+    ) -> Optional[Dict[str, str]]:\n         \"\"\"Get rendered template from cache\"\"\"\n         try:\n             redis_client = await self._get_redis_client()\n-            cache_key = f\"template_cache:{template_name}:{hash(frozenset(variables.items()))}\"\n-            \n+            cache_key = (\n+                f\"template_cache:{template_name}:{hash(frozenset(variables.items()))}\"\n+            )\n+\n             cached = await redis_client.get(cache_key)\n             if cached:\n                 return json.loads(cached)\n-            \n+\n         except Exception as e:\n             logger.warning(f\"Failed to get template from cache: {e}\")\n-        \n+\n         return None\n-    \n-    async def _cache_result(self, template_name: str, variables: Dict[str, Any], result: Dict[str, str]):\n+\n+    async def _cache_result(\n+        self, template_name: str, variables: Dict[str, Any], result: Dict[str, str]\n+    ):\n         \"\"\"Cache rendered template result\"\"\"\n         try:\n             redis_client = await self._get_redis_client()\n-            cache_key = f\"template_cache:{template_name}:{hash(frozenset(variables.items()))}\"\n-            \n-            await redis_client.setex(\n-                cache_key,\n-                self.cache_ttl,\n-                json.dumps(result)\n-            )\n-            \n+            cache_key = (\n+                f\"template_cache:{template_name}:{hash(frozenset(variables.items()))}\"\n+            )\n+\n+            await redis_client.setex(cache_key, self.cache_ttl, json.dumps(result))\n+\n         except Exception as e:\n             logger.warning(f\"Failed to cache template result: {e}\")\n-    \n+\n     async def preview_template(\n-        self, \n+        self,\n         template_content: str,\n         subject: str,\n         variables: Dict[str, Any],\n-        channel: Optional[NotificationChannel] = None\n+        channel: Optional[NotificationChannel] = None,\n     ) -> Dict[str, str]:\n         \"\"\"\n         Preview template rendering without saving to database\n-        \n+\n         Args:\n             template_content: Template content string\n             subject: Template subject string\n             variables: Template variables\n             channel: Notification channel\n-            \n+\n         Returns:\n             Dict with 'subject' and 'content' keys\n         \"\"\"\n         try:\n             # Render subject\n             rendered_subject = \"\"\n             if subject:\n                 subject_template = self.jinja_env.from_string(subject)\n                 rendered_subject = await subject_template.render_async(**variables)\n-            \n+\n             # Render content\n             content_template = self.jinja_env.from_string(template_content)\n             rendered_content = await content_template.render_async(**variables)\n-            \n+\n             # Post-process based on channel\n             if channel:\n-                rendered_content = await self._post_process_content(rendered_content, channel)\n-            \n+                rendered_content = await self._post_process_content(\n+                    rendered_content, channel\n+                )\n+\n             return {\n                 \"subject\": rendered_subject.strip(),\n-                \"content\": rendered_content.strip()\n+                \"content\": rendered_content.strip(),\n             }\n-            \n+\n         except Exception as e:\n             logger.error(f\"Template preview failed: {e}\")\n             raise ValueError(f\"Template preview error: {str(e)}\")\n-    \n-    async def validate_template_syntax(self, template_content: str, subject: str = \"\") -> Dict[str, Any]:\n+\n+    async def validate_template_syntax(\n+        self, template_content: str, subject: str = \"\"\n+    ) -> Dict[str, Any]:\n         \"\"\"\n         Validate template syntax without rendering\n-        \n+\n         Args:\n             template_content: Template content to validate\n             subject: Subject template to validate\n-            \n+\n         Returns:\n             Dict with validation results\n         \"\"\"\n         errors = []\n         warnings = []\n-        \n+\n         try:\n             # Validate content template\n             self.jinja_env.from_string(template_content)\n         except TemplateSyntaxError as e:\n             errors.append(f\"Content template syntax error: {str(e)}\")\n         except Exception as e:\n             errors.append(f\"Content template error: {str(e)}\")\n-        \n+\n         try:\n             # Validate subject template\n             if subject:\n                 self.jinja_env.from_string(subject)\n         except TemplateSyntaxError as e:\n             errors.append(f\"Subject template syntax error: {str(e)}\")\n         except Exception as e:\n             errors.append(f\"Subject template error: {str(e)}\")\n-        \n+\n         # Check for potentially problematic patterns\n         if \"{{\" in template_content and \"}}\" not in template_content:\n             warnings.append(\"Unclosed template variable detected\")\n-        \n+\n         if len(template_content) > 50000:\n             warnings.append(\"Template content is very large (>50KB)\")\n-        \n-        return {\n-            \"valid\": len(errors) == 0,\n-            \"errors\": errors,\n-            \"warnings\": warnings\n-        }\n-    \n+\n+        return {\"valid\": len(errors) == 0, \"errors\": errors, \"warnings\": warnings}\n+\n     async def clear_cache(self, template_id: Optional[str] = None):\n         \"\"\"Clear template cache\"\"\"\n         try:\n             redis_client = await self._get_redis_client()\n-            \n+\n             if template_id:\n                 # Clear cache for specific template\n                 pattern = f\"template_cache:{template_id}*\"\n             else:\n                 # Clear all template cache\n                 pattern = \"template_cache:*\"\n-            \n+\n             keys = await redis_client.keys(pattern)\n             if keys:\n                 await redis_client.delete(*keys)\n                 logger.info(f\"Cleared {len(keys)} template cache entries\")\n-            \n+\n         except Exception as e:\n             logger.error(f\"Failed to clear template cache: {e}\")\n-    \n+\n     async def get_template_variables(self, template_content: str) -> List[str]:\n         \"\"\"Extract variable names from template content\"\"\"\n         try:\n             import re\n-            \n+\n             # Find all {{ variable }} patterns\n-            variable_pattern = r'\\{\\{\\s*([a-zA-Z_][a-zA-Z0-9_]*(?:\\.[a-zA-Z_][a-zA-Z0-9_]*)*)\\s*(?:\\|[^}]*)?\\}\\}'\n+            variable_pattern = r\"\\{\\{\\s*([a-zA-Z_][a-zA-Z0-9_]*(?:\\.[a-zA-Z_][a-zA-Z0-9_]*)*)\\s*(?:\\|[^}]*)?\\}\\}\"\n             variables = re.findall(variable_pattern, template_content)\n-            \n+\n             # Remove duplicates and filter out built-in functions\n             unique_vars = list(set(variables))\n-            built_ins = ['current_year', 'current_date', 'url_for']\n-            \n-            return [var for var in unique_vars if not any(var.startswith(builtin) for builtin in built_ins)]\n-            \n+            built_ins = [\"current_year\", \"current_date\", \"url_for\"]\n+\n+            return [\n+                var\n+                for var in unique_vars\n+                if not any(var.startswith(builtin) for builtin in built_ins)\n+            ]\n+\n         except Exception as e:\n             logger.error(f\"Failed to extract template variables: {e}\")\n             return []\n \n \n # Global template engine instance\n-template_engine = TemplateEngine()\n\\ No newline at end of file\n+template_engine = TemplateEngine()\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/run_tests.py\t2025-09-09 18:45:16.247944+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/run_tests.py\t2025-09-10 11:37:01.838782+00:00\n@@ -13,481 +13,493 @@\n import argparse\n \n \n class TestRunner:\n     \"\"\"Comprehensive test runner with validation and reporting\"\"\"\n-    \n+\n     def __init__(self):\n         self.test_root = Path(__file__).parent / \"tests\"\n         self.coverage_threshold = 80\n         self.auth_coverage_threshold = 100\n         self.results = {\n             \"timestamp\": datetime.utcnow().isoformat(),\n             \"overall_status\": \"unknown\",\n             \"test_results\": {},\n             \"coverage_results\": {},\n             \"quality_metrics\": {},\n-            \"recommendations\": []\n-        }\n-    \n+            \"recommendations\": [],\n+        }\n+\n     def run_command(self, command, capture_output=True):\n         \"\"\"Run shell command and return result\"\"\"\n         try:\n             result = subprocess.run(\n                 command,\n                 shell=True,\n                 capture_output=capture_output,\n                 text=True,\n-                check=False\n+                check=False,\n             )\n             return {\n                 \"returncode\": result.returncode,\n                 \"stdout\": result.stdout,\n                 \"stderr\": result.stderr,\n-                \"success\": result.returncode == 0\n+                \"success\": result.returncode == 0,\n             }\n         except Exception as e:\n-            return {\n-                \"returncode\": -1,\n-                \"stdout\": \"\",\n-                \"stderr\": str(e),\n-                \"success\": False\n-            }\n-    \n+            return {\"returncode\": -1, \"stdout\": \"\", \"stderr\": str(e), \"success\": False}\n+\n     def install_test_dependencies(self):\n         \"\"\"Install test dependencies\"\"\"\n         print(\"\ud83d\udce6 Installing test dependencies...\")\n-        \n+\n         # Check if test_requirements.txt exists\n         test_req_file = Path(\"test_requirements.txt\")\n         if not test_req_file.exists():\n             print(\"\u274c test_requirements.txt not found\")\n             return False\n-        \n+\n         # Install test dependencies\n         result = self.run_command(\"pip install -r test_requirements.txt\")\n         if not result[\"success\"]:\n             print(f\"\u274c Failed to install test dependencies: {result['stderr']}\")\n             return False\n-        \n+\n         print(\"\u2705 Test dependencies installed successfully\")\n         return True\n-    \n+\n     def validate_test_structure(self):\n         \"\"\"Validate test directory structure\"\"\"\n         print(\"\ud83c\udfd7\ufe0f Validating test structure...\")\n-        \n+\n         required_dirs = [\n             \"tests/unit\",\n-            \"tests/integration\", \n+            \"tests/integration\",\n             \"tests/e2e\",\n-            \"tests/fixtures\"\n+            \"tests/fixtures\",\n         ]\n-        \n+\n         required_files = [\n             \"tests/__init__.py\",\n             \"tests/conftest.py\",\n             \"tests/unit/__init__.py\",\n             \"tests/integration/__init__.py\",\n             \"tests/e2e/__init__.py\",\n             \"tests/fixtures/__init__.py\",\n-            \"pytest.ini\"\n+            \"pytest.ini\",\n         ]\n-        \n+\n         missing_dirs = []\n         missing_files = []\n-        \n+\n         for dir_path in required_dirs:\n             if not Path(dir_path).exists():\n                 missing_dirs.append(dir_path)\n-        \n+\n         for file_path in required_files:\n             if not Path(file_path).exists():\n                 missing_files.append(file_path)\n-        \n+\n         if missing_dirs:\n             print(f\"\u274c Missing directories: {', '.join(missing_dirs)}\")\n             return False\n-        \n+\n         if missing_files:\n             print(f\"\u274c Missing files: {', '.join(missing_files)}\")\n             return False\n-        \n+\n         print(\"\u2705 Test structure validation passed\")\n         return True\n-    \n+\n     def run_unit_tests(self):\n         \"\"\"Run unit tests with coverage\"\"\"\n         print(\"\ud83e\uddea Running unit tests...\")\n-        \n+\n         command = \"pytest tests/unit -v --cov=. --cov-report=term-missing --cov-report=json:coverage-unit.json -m unit\"\n         result = self.run_command(command)\n-        \n+\n         self.results[\"test_results\"][\"unit\"] = {\n             \"success\": result[\"success\"],\n             \"output\": result[\"stdout\"],\n-            \"errors\": result[\"stderr\"]\n-        }\n-        \n+            \"errors\": result[\"stderr\"],\n+        }\n+\n         if result[\"success\"]:\n             print(\"\u2705 Unit tests passed\")\n             return True\n         else:\n             print(f\"\u274c Unit tests failed: {result['stderr']}\")\n             return False\n-    \n+\n     def run_integration_tests(self):\n         \"\"\"Run integration tests\"\"\"\n         print(\"\ud83d\udd17 Running integration tests...\")\n-        \n+\n         command = \"pytest tests/integration -v --cov=. --cov-report=json:coverage-integration.json -m integration\"\n         result = self.run_command(command)\n-        \n+\n         self.results[\"test_results\"][\"integration\"] = {\n             \"success\": result[\"success\"],\n             \"output\": result[\"stdout\"],\n-            \"errors\": result[\"stderr\"]\n-        }\n-        \n+            \"errors\": result[\"stderr\"],\n+        }\n+\n         if result[\"success\"]:\n             print(\"\u2705 Integration tests passed\")\n             return True\n         else:\n             print(f\"\u274c Integration tests failed: {result['stderr']}\")\n             return False\n-    \n+\n     def run_auth_tests(self):\n         \"\"\"Run authentication tests specifically\"\"\"\n         print(\"\ud83d\udd10 Running authentication tests...\")\n-        \n+\n         command = \"pytest tests/integration/test_auth_integration.py -v --cov=. --cov-report=json:coverage-auth.json -m auth\"\n         result = self.run_command(command)\n-        \n+\n         self.results[\"test_results\"][\"auth\"] = {\n             \"success\": result[\"success\"],\n             \"output\": result[\"stdout\"],\n-            \"errors\": result[\"stderr\"]\n-        }\n-        \n+            \"errors\": result[\"stderr\"],\n+        }\n+\n         if result[\"success\"]:\n             print(\"\u2705 Authentication tests passed\")\n             return True\n         else:\n             print(f\"\u274c Authentication tests failed: {result['stderr']}\")\n             return False\n-    \n+\n     def run_e2e_tests(self):\n         \"\"\"Run end-to-end tests\"\"\"\n         print(\"\ud83c\udf10 Running end-to-end tests...\")\n-        \n+\n         command = \"pytest tests/e2e -v -m e2e --tb=short\"\n         result = self.run_command(command)\n-        \n+\n         self.results[\"test_results\"][\"e2e\"] = {\n             \"success\": result[\"success\"],\n             \"output\": result[\"stdout\"],\n-            \"errors\": result[\"stderr\"]\n-        }\n-        \n+            \"errors\": result[\"stderr\"],\n+        }\n+\n         if result[\"success\"]:\n             print(\"\u2705 End-to-end tests passed\")\n             return True\n         else:\n             print(f\"\u274c End-to-end tests failed: {result['stderr']}\")\n             return False\n-    \n+\n     def run_all_tests_with_coverage(self):\n         \"\"\"Run all tests with comprehensive coverage\"\"\"\n         print(\"\ud83d\udcca Running all tests with coverage...\")\n-        \n+\n         command = \"pytest --cov=. --cov-report=html:htmlcov --cov-report=json:coverage.json --cov-report=term-missing --cov-fail-under=80\"\n         result = self.run_command(command)\n-        \n+\n         self.results[\"test_results\"][\"comprehensive\"] = {\n             \"success\": result[\"success\"],\n             \"output\": result[\"stdout\"],\n-            \"errors\": result[\"stderr\"]\n-        }\n-        \n+            \"errors\": result[\"stderr\"],\n+        }\n+\n         return result[\"success\"]\n-    \n+\n     def analyze_coverage(self):\n         \"\"\"Analyze test coverage results\"\"\"\n         print(\"\ud83d\udcc8 Analyzing test coverage...\")\n-        \n+\n         coverage_files = [\n             \"coverage.json\",\n             \"coverage-unit.json\",\n             \"coverage-integration.json\",\n-            \"coverage-auth.json\"\n+            \"coverage-auth.json\",\n         ]\n-        \n+\n         coverage_data = {}\n-        \n+\n         for coverage_file in coverage_files:\n             if Path(coverage_file).exists():\n                 try:\n-                    with open(coverage_file, 'r') as f:\n+                    with open(coverage_file, \"r\") as f:\n                         data = json.load(f)\n                         coverage_data[coverage_file] = data\n                 except Exception as e:\n                     print(f\"\u26a0\ufe0f Failed to read {coverage_file}: {e}\")\n-        \n+\n         # Analyze overall coverage\n         if \"coverage.json\" in coverage_data:\n             overall_coverage = coverage_data[\"coverage.json\"]\n-            total_coverage = overall_coverage.get(\"totals\", {}).get(\"percent_covered\", 0)\n-            \n+            total_coverage = overall_coverage.get(\"totals\", {}).get(\n+                \"percent_covered\", 0\n+            )\n+\n             self.results[\"coverage_results\"][\"overall\"] = {\n                 \"percentage\": total_coverage,\n                 \"meets_threshold\": total_coverage >= self.coverage_threshold,\n-                \"threshold\": self.coverage_threshold\n+                \"threshold\": self.coverage_threshold,\n             }\n-            \n+\n             print(f\"\ud83d\udcca Overall coverage: {total_coverage:.1f}%\")\n-            \n+\n             if total_coverage >= self.coverage_threshold:\n-                print(f\"\u2705 Coverage meets minimum threshold ({self.coverage_threshold}%)\")\n+                print(\n+                    f\"\u2705 Coverage meets minimum threshold ({self.coverage_threshold}%)\"\n+                )\n             else:\n                 print(f\"\u274c Coverage below threshold ({self.coverage_threshold}%)\")\n                 self.results[\"recommendations\"].append(\n                     f\"Increase test coverage from {total_coverage:.1f}% to at least {self.coverage_threshold}%\"\n                 )\n-        \n+\n         # Analyze file-by-file coverage\n         if \"coverage.json\" in coverage_data:\n             files_data = coverage_data[\"coverage.json\"].get(\"files\", {})\n             low_coverage_files = []\n-            \n+\n             for file_path, file_data in files_data.items():\n                 file_coverage = file_data.get(\"summary\", {}).get(\"percent_covered\", 0)\n                 if file_coverage < 70:  # Files with less than 70% coverage\n                     low_coverage_files.append((file_path, file_coverage))\n-            \n+\n             if low_coverage_files:\n                 print(\"\u26a0\ufe0f Files with low coverage:\")\n                 for file_path, coverage in low_coverage_files[:10]:  # Show top 10\n                     print(f\"   {file_path}: {coverage:.1f}%\")\n-                \n+\n                 self.results[\"recommendations\"].append(\n                     f\"Improve coverage for {len(low_coverage_files)} files with low coverage\"\n                 )\n-        \n+\n         return True\n-    \n+\n     def check_code_quality(self):\n         \"\"\"Check code quality metrics\"\"\"\n         print(\"\ud83d\udd0d Checking code quality...\")\n-        \n+\n         # Check if flake8 is available\n         flake8_result = self.run_command(\"flake8 --version\")\n         if flake8_result[\"success\"]:\n             print(\"  Running flake8 linting...\")\n-            lint_result = self.run_command(\"flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics\")\n-            \n+            lint_result = self.run_command(\n+                \"flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics\"\n+            )\n+\n             self.results[\"quality_metrics\"][\"linting\"] = {\n                 \"tool\": \"flake8\",\n                 \"success\": lint_result[\"success\"],\n-                \"output\": lint_result[\"stdout\"]\n+                \"output\": lint_result[\"stdout\"],\n             }\n-            \n+\n             if lint_result[\"success\"]:\n                 print(\"  \u2705 Linting passed\")\n             else:\n                 print(f\"  \u26a0\ufe0f Linting issues found: {lint_result['stdout']}\")\n         else:\n             print(\"  \u26a0\ufe0f flake8 not available, skipping linting\")\n-        \n+\n         # Check if black is available for formatting\n         black_result = self.run_command(\"black --version\")\n         if black_result[\"success\"]:\n             print(\"  Checking code formatting...\")\n             format_result = self.run_command(\"black --check --diff .\")\n-            \n+\n             self.results[\"quality_metrics\"][\"formatting\"] = {\n                 \"tool\": \"black\",\n                 \"success\": format_result[\"success\"],\n-                \"output\": format_result[\"stdout\"]\n+                \"output\": format_result[\"stdout\"],\n             }\n-            \n+\n             if format_result[\"success\"]:\n                 print(\"  \u2705 Code formatting is consistent\")\n             else:\n                 print(\"  \u26a0\ufe0f Code formatting issues found\")\n-                self.results[\"recommendations\"].append(\"Run 'black .' to fix formatting issues\")\n+                self.results[\"recommendations\"].append(\n+                    \"Run 'black .' to fix formatting issues\"\n+                )\n         else:\n             print(\"  \u26a0\ufe0f black not available, skipping format check\")\n-        \n+\n         return True\n-    \n+\n     def validate_auth_coverage(self):\n         \"\"\"Validate that authentication tests have 100% coverage\"\"\"\n         print(\"\ud83d\udd10 Validating authentication test coverage...\")\n-        \n+\n         # Run auth tests specifically with coverage\n         auth_files = [\n             \"auth.py\",\n-            \"auth_middleware.py\", \n+            \"auth_middleware.py\",\n             \"identity_client.py\",\n-            \"jwt_handler.py\"\n+            \"jwt_handler.py\",\n         ]\n-        \n+\n         if Path(\"coverage.json\").exists():\n             try:\n-                with open(\"coverage.json\", 'r') as f:\n+                with open(\"coverage.json\", \"r\") as f:\n                     coverage_data = json.load(f)\n-                \n+\n                 auth_coverage_issues = []\n                 files_data = coverage_data.get(\"files\", {})\n-                \n+\n                 for file_path, file_data in files_data.items():\n                     if any(auth_file in file_path for auth_file in auth_files):\n-                        file_coverage = file_data.get(\"summary\", {}).get(\"percent_covered\", 0)\n+                        file_coverage = file_data.get(\"summary\", {}).get(\n+                            \"percent_covered\", 0\n+                        )\n                         if file_coverage < self.auth_coverage_threshold:\n                             auth_coverage_issues.append((file_path, file_coverage))\n-                \n+\n                 if auth_coverage_issues:\n                     print(\"\u274c Authentication files with insufficient coverage:\")\n                     for file_path, coverage in auth_coverage_issues:\n-                        print(f\"   {file_path}: {coverage:.1f}% (requires {self.auth_coverage_threshold}%)\")\n-                    \n+                        print(\n+                            f\"   {file_path}: {coverage:.1f}% (requires {self.auth_coverage_threshold}%)\"\n+                        )\n+\n                     self.results[\"recommendations\"].append(\n                         \"Authentication files must have 100% test coverage for security reasons\"\n                     )\n                     return False\n                 else:\n                     print(\"\u2705 Authentication test coverage validated\")\n                     return True\n-                    \n+\n             except Exception as e:\n                 print(f\"\u26a0\ufe0f Failed to validate auth coverage: {e}\")\n                 return False\n         else:\n             print(\"\u26a0\ufe0f No coverage data available for auth validation\")\n             return False\n-    \n+\n     def generate_test_report(self):\n         \"\"\"Generate comprehensive test report\"\"\"\n         print(\"\ud83d\udccb Generating test report...\")\n-        \n+\n         report_file = \"test_report.json\"\n-        \n+\n         # Calculate overall status\n         test_results = self.results[\"test_results\"]\n         all_tests_passed = all(\n-            result.get(\"success\", False) \n-            for result in test_results.values()\n+            result.get(\"success\", False) for result in test_results.values()\n         )\n-        \n-        coverage_passed = self.results.get(\"coverage_results\", {}).get(\"overall\", {}).get(\"meets_threshold\", False)\n-        \n+\n+        coverage_passed = (\n+            self.results.get(\"coverage_results\", {})\n+            .get(\"overall\", {})\n+            .get(\"meets_threshold\", False)\n+        )\n+\n         if all_tests_passed and coverage_passed:\n             self.results[\"overall_status\"] = \"passed\"\n         elif all_tests_passed:\n             self.results[\"overall_status\"] = \"passed_with_warnings\"\n         else:\n             self.results[\"overall_status\"] = \"failed\"\n-        \n+\n         # Save report\n         try:\n-            with open(report_file, 'w') as f:\n+            with open(report_file, \"w\") as f:\n                 json.dump(self.results, f, indent=2)\n-            \n+\n             print(f\"\u2705 Test report generated: {report_file}\")\n             return True\n         except Exception as e:\n             print(f\"\u274c Failed to generate report: {e}\")\n             return False\n-    \n+\n     def print_summary(self):\n         \"\"\"Print test execution summary\"\"\"\n-        print(\"\\n\" + \"=\"*60)\n+        print(\"\\n\" + \"=\" * 60)\n         print(\"\ud83d\udcca TEST EXECUTION SUMMARY\")\n-        print(\"=\"*60)\n-        \n+        print(\"=\" * 60)\n+\n         # Overall status\n         status_emoji = {\n             \"passed\": \"\u2705\",\n-            \"passed_with_warnings\": \"\u26a0\ufe0f\", \n+            \"passed_with_warnings\": \"\u26a0\ufe0f\",\n             \"failed\": \"\u274c\",\n-            \"unknown\": \"\u2753\"\n-        }\n-        \n+            \"unknown\": \"\u2753\",\n+        }\n+\n         overall_status = self.results[\"overall_status\"]\n-        print(f\"Overall Status: {status_emoji.get(overall_status, '\u2753')} {overall_status.upper()}\")\n-        \n+        print(\n+            f\"Overall Status: {status_emoji.get(overall_status, '\u2753')} {overall_status.upper()}\"\n+        )\n+\n         # Test results\n         test_results = self.results[\"test_results\"]\n         if test_results:\n             print(\"\\nTest Results:\")\n             for test_type, result in test_results.items():\n                 status = \"\u2705 PASSED\" if result.get(\"success\", False) else \"\u274c FAILED\"\n                 print(f\"  {test_type.title()}: {status}\")\n-        \n+\n         # Coverage results\n         coverage_results = self.results.get(\"coverage_results\", {})\n         if \"overall\" in coverage_results:\n             coverage_data = coverage_results[\"overall\"]\n             percentage = coverage_data.get(\"percentage\", 0)\n             threshold = coverage_data.get(\"threshold\", 0)\n             meets_threshold = coverage_data.get(\"meets_threshold\", False)\n-            \n+\n             status = \"\u2705\" if meets_threshold else \"\u274c\"\n             print(f\"\\nCoverage: {status} {percentage:.1f}% (threshold: {threshold}%)\")\n-        \n+\n         # Recommendations\n         recommendations = self.results.get(\"recommendations\", [])\n         if recommendations:\n             print(\"\\nRecommendations:\")\n             for i, recommendation in enumerate(recommendations, 1):\n                 print(f\"  {i}. {recommendation}\")\n-        \n-        print(\"=\"*60)\n-    \n+\n+        print(\"=\" * 60)\n+\n     def run_quick_tests(self):\n         \"\"\"Run essential tests quickly\"\"\"\n         print(\"\u26a1 Running quick test suite...\")\n-        \n+\n         success = True\n-        \n+\n         # Run unit tests\n         if not self.run_unit_tests():\n             success = False\n-        \n+\n         # Run auth tests\n         if not self.run_auth_tests():\n             success = False\n-        \n+\n         # Basic coverage check\n         command = \"pytest tests/unit tests/integration/test_auth_integration.py --cov=. --cov-report=json:coverage-quick.json\"\n         result = self.run_command(command)\n-        \n+\n         if result[\"success\"]:\n             self.analyze_coverage()\n-        \n+\n         return success\n-    \n+\n     def run_full_validation(self):\n         \"\"\"Run complete test validation suite\"\"\"\n         print(\"\ud83d\ude80 Running full test validation suite...\")\n-        \n+\n         steps = [\n             (\"Validate test structure\", self.validate_test_structure),\n             (\"Install test dependencies\", self.install_test_dependencies),\n             (\"Run unit tests\", self.run_unit_tests),\n-            (\"Run integration tests\", self.run_integration_tests), \n+            (\"Run integration tests\", self.run_integration_tests),\n             (\"Run authentication tests\", self.run_auth_tests),\n             (\"Run E2E tests\", self.run_e2e_tests),\n             (\"Run comprehensive coverage\", self.run_all_tests_with_coverage),\n             (\"Analyze coverage\", self.analyze_coverage),\n             (\"Validate auth coverage\", self.validate_auth_coverage),\n             (\"Check code quality\", self.check_code_quality),\n-            (\"Generate report\", self.generate_test_report)\n+            (\"Generate report\", self.generate_test_report),\n         ]\n-        \n+\n         overall_success = True\n-        \n+\n         for step_name, step_func in steps:\n             print(f\"\\n\ud83d\udd04 {step_name}...\")\n             try:\n                 step_success = step_func()\n                 if not step_success:\n@@ -496,54 +508,56 @@\n                 else:\n                     print(f\"\u2705 {step_name} completed\")\n             except Exception as e:\n                 print(f\"\u274c {step_name} failed with error: {e}\")\n                 overall_success = False\n-        \n+\n         self.results[\"overall_status\"] = \"passed\" if overall_success else \"failed\"\n         return overall_success\n \n \n def main():\n     \"\"\"Main entry point\"\"\"\n-    parser = argparse.ArgumentParser(description=\"Comprehensive test runner and validator\")\n+    parser = argparse.ArgumentParser(\n+        description=\"Comprehensive test runner and validator\"\n+    )\n     parser.add_argument(\n-        \"--mode\", \n+        \"--mode\",\n         choices=[\"quick\", \"full\"],\n         default=\"full\",\n-        help=\"Test mode: quick (essential tests) or full (complete validation)\"\n+        help=\"Test mode: quick (essential tests) or full (complete validation)\",\n     )\n     parser.add_argument(\n         \"--coverage-threshold\",\n         type=int,\n         default=80,\n-        help=\"Minimum coverage threshold percentage\"\n+        help=\"Minimum coverage threshold percentage\",\n     )\n-    \n+\n     args = parser.parse_args()\n-    \n+\n     # Initialize test runner\n     runner = TestRunner()\n     runner.coverage_threshold = args.coverage_threshold\n-    \n+\n     print(\"\ud83e\uddea Communication Service Test Suite\")\n-    print(\"=\"*50)\n+    print(\"=\" * 50)\n     print(f\"Mode: {args.mode}\")\n     print(f\"Coverage threshold: {args.coverage_threshold}%\")\n     print(f\"Timestamp: {datetime.utcnow().isoformat()}\")\n-    print(\"=\"*50)\n-    \n+    print(\"=\" * 50)\n+\n     # Run tests based on mode\n     if args.mode == \"quick\":\n         success = runner.run_quick_tests()\n     else:\n         success = runner.run_full_validation()\n-    \n+\n     # Print summary\n     runner.print_summary()\n-    \n+\n     # Exit with appropriate code\n     sys.exit(0 if success else 1)\n \n \n if __name__ == \"__main__\":\n-    main()\n\\ No newline at end of file\n+    main()\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/main.py\t2025-09-09 14:31:33.759199+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/main.py\t2025-09-10 11:37:01.979170+00:00\n@@ -1,9 +1,10 @@\n \"\"\"\n Communication Service - Notifications + Messaging\n Port: 8003\n \"\"\"\n+\n import os\n import httpx\n import redis.asyncio as redis\n from fastapi import FastAPI, HTTPException, Depends, status\n from fastapi.middleware.cors import CORSMiddleware\n@@ -32,11 +33,11 @@\n     title=f\"{SERVICE_NAME.title().replace('-', ' ')} API\",\n     description=\"Microservice for notifications, messaging, and multi-channel delivery\",\n     version=SERVICE_VERSION,\n     docs_url=\"/docs\",\n     redoc_url=\"/redoc\",\n-    openapi_url=\"/openapi.json\"\n+    openapi_url=\"/openapi.json\",\n )\n \n # CORS middleware - configured for frontend\n app.add_middleware(\n     CORSMiddleware,\n@@ -44,102 +45,113 @@\n     allow_credentials=True,\n     allow_methods=[\"*\"],\n     allow_headers=[\"*\"],\n )\n \n+\n # JWT Token Validation Function\n async def validate_jwt_token(token: str = Depends(security)):\n     \"\"\"\n     Validate JWT token with Identity Service.\n-    \n+\n     Args:\n         token: Bearer token from Authorization header\n-        \n+\n     Returns:\n         dict: User data from Identity Service\n-        \n+\n     Raises:\n         HTTPException: 401 if token is invalid or expired\n     \"\"\"\n     try:\n         # Call Identity Service to validate token\n         async with httpx.AsyncClient(timeout=10.0) as client:\n             response = await client.post(\n                 f\"{IDENTITY_SERVICE_URL}/auth/validate\",\n                 headers={\"Authorization\": f\"Bearer {token.credentials}\"},\n-                timeout=5.0\n-            )\n-            \n+                timeout=5.0,\n+            )\n+\n             if response.status_code == 200:\n                 user_data = response.json()\n-                logger.info(f\"Token validated for user: {user_data.get('user_id', 'unknown')}\")\n+                logger.info(\n+                    f\"Token validated for user: {user_data.get('user_id', 'unknown')}\"\n+                )\n                 return user_data\n-            \n+\n             elif response.status_code == 401:\n                 logger.warning(\"Invalid or expired token provided\")\n                 raise HTTPException(\n                     status_code=status.HTTP_401_UNAUTHORIZED,\n                     detail=\"Invalid or expired token\",\n                     headers={\"WWW-Authenticate\": \"Bearer\"},\n                 )\n-            \n+\n             else:\n-                logger.error(f\"Identity service returned unexpected status: {response.status_code}\")\n+                logger.error(\n+                    f\"Identity service returned unexpected status: {response.status_code}\"\n+                )\n                 raise HTTPException(\n                     status_code=status.HTTP_401_UNAUTHORIZED,\n                     detail=\"Token validation failed\",\n                     headers={\"WWW-Authenticate\": \"Bearer\"},\n                 )\n-                \n+\n     except httpx.TimeoutException:\n         logger.error(\"Timeout calling Identity Service for token validation\")\n         raise HTTPException(\n             status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n-            detail=\"Authentication service temporarily unavailable\"\n+            detail=\"Authentication service temporarily unavailable\",\n         )\n     except httpx.RequestError as e:\n         logger.error(f\"Network error calling Identity Service: {e}\")\n         raise HTTPException(\n             status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n-            detail=\"Authentication service unavailable\"\n+            detail=\"Authentication service unavailable\",\n         )\n     except Exception as e:\n         logger.error(f\"Unexpected error during token validation: {e}\")\n         raise HTTPException(\n             status_code=status.HTTP_401_UNAUTHORIZED,\n             detail=\"Token validation failed\",\n             headers={\"WWW-Authenticate\": \"Bearer\"},\n         )\n+\n \n # Pydantic models\n class NotificationRequest(BaseModel):\n     type: str  # email, sms, push, in_app\n     to: str\n     subject: Optional[str] = None\n     message: str\n     template_id: Optional[str] = None\n     variables: Optional[dict] = {}\n \n+\n class MessageRequest(BaseModel):\n     conversation_id: Optional[str] = None\n     to_user_id: str\n     message: str\n     message_type: str = \"text\"\n \n+\n # Helper functions for health check\n def get_uptime():\n     \"\"\"Get service uptime in seconds\"\"\"\n     return int(time.time() - start_time)\n \n+\n def get_memory_usage():\n     \"\"\"Get memory usage in MB\"\"\"\n     process = psutil.Process(os.getpid())\n     return round(process.memory_info().rss / 1024 / 1024, 2)\n \n+\n def get_active_connections():\n     \"\"\"Get active connection count (placeholder)\"\"\"\n     return 0  # TODO: Implement actual connection tracking\n+\n \n # Standard health check endpoint\n @app.get(\"/health\")\n async def health_check():\n     \"\"\"Standard health check following service integration patterns\"\"\"\n@@ -150,25 +162,25 @@\n         \"port\": SERVICE_PORT,\n         \"dependencies\": {},\n         \"metrics\": {\n             \"uptime_seconds\": get_uptime(),\n             \"active_connections\": get_active_connections(),\n-            \"memory_usage_mb\": get_memory_usage()\n-        }\n+            \"memory_usage_mb\": get_memory_usage(),\n+        },\n     }\n-    \n+\n     # Check Redis connection\n     try:\n         redis_url = os.getenv(\"REDIS_URL\", \"redis://localhost:6382/0\")\n         redis_client = redis.from_url(redis_url)\n         await redis_client.ping()\n         await redis_client.close()\n         health_status[\"dependencies\"][\"redis\"] = \"healthy\"\n     except Exception:\n         health_status[\"dependencies\"][\"redis\"] = \"unhealthy\"\n         health_status[\"status\"] = \"degraded\"\n-    \n+\n     # Check Identity Service\n     try:\n         async with httpx.AsyncClient(timeout=5.0) as client:\n             response = await client.get(f\"{IDENTITY_SERVICE_URL}/health\")\n             if response.status_code == 200:\n@@ -176,409 +188,425 @@\n             else:\n                 raise Exception(\"Identity service returned non-200\")\n     except Exception:\n         health_status[\"dependencies\"][\"identity-service\"] = \"unhealthy\"\n         health_status[\"status\"] = \"degraded\"\n-    \n+\n     # Check Celery workers (placeholder)\n     try:\n         # TODO: Implement actual Celery worker health check\n         health_status[\"dependencies\"][\"celery-workers\"] = \"not-implemented\"\n     except Exception:\n         health_status[\"dependencies\"][\"celery-workers\"] = \"unhealthy\"\n         health_status[\"status\"] = \"degraded\"\n-    \n+\n     return health_status\n+\n \n # Notification endpoints\n @app.post(\"/api/v1/notifications\")\n async def send_notification(\n-    notification: NotificationRequest,\n-    current_user: dict = Depends(validate_jwt_token)\n+    notification: NotificationRequest, current_user: dict = Depends(validate_jwt_token)\n ):\n     \"\"\"Send a notification via email, SMS, push, or in-app\"\"\"\n     from tasks.notification_tasks import send_notification as send_notification_task\n-    from models import Notification as DBNotification, NotificationChannel, NotificationStatus as DBNotificationStatus\n+    from models import (\n+        Notification as DBNotification,\n+        NotificationChannel,\n+        NotificationStatus as DBNotificationStatus,\n+    )\n     import uuid\n     from datetime import datetime\n-    \n+\n     user_id = current_user[\"user_id\"]\n     organization_id = current_user.get(\"organization_id\")\n-    \n+\n     try:\n         # Validate notification channel\n         try:\n             channel = NotificationChannel(notification.type)\n         except ValueError:\n             raise HTTPException(\n                 status_code=400,\n-                detail=f\"Invalid notification type: {notification.type}\"\n-            )\n-        \n+                detail=f\"Invalid notification type: {notification.type}\",\n+            )\n+\n         # Create notification record in database\n         async with get_db_session() as session:\n             db_notification = DBNotification(\n                 user_id=uuid.UUID(user_id),\n                 channel=channel,\n                 subject=notification.subject,\n                 content=notification.message,\n                 recipient=notification.to,\n-                template_id=uuid.UUID(notification.template_id) if notification.template_id else None,\n+                template_id=(\n+                    uuid.UUID(notification.template_id)\n+                    if notification.template_id\n+                    else None\n+                ),\n                 data=notification.variables or {},\n                 status=DBNotificationStatus.PENDING,\n-                priority=\"normal\"\n-            )\n-            \n+                priority=\"normal\",\n+            )\n+\n             session.add(db_notification)\n             await session.commit()\n             await session.refresh(db_notification)\n-            \n+\n             notification_id = str(db_notification.id)\n-        \n+\n         # Send notification via Celery task\n         task_result = send_notification_task.apply_async(\n             args=(\n                 notification.type,\n                 notification.to,\n                 notification.message,\n                 notification.subject,\n                 notification.template_id,\n                 notification.variables,\n                 {\"sent_by\": user_id, \"organization_id\": organization_id},\n-                notification_id\n+                notification_id,\n             )\n         )\n-        \n+\n         return {\n             \"notification_id\": notification_id,\n             \"task_id\": task_result.id,\n             \"status\": \"queued\",\n             \"channel\": notification.type,\n             \"recipient\": notification.to,\n             \"sent_by\": user_id,\n             \"organization\": organization_id,\n-            \"created_at\": datetime.utcnow().isoformat()\n+            \"created_at\": datetime.utcnow().isoformat(),\n         }\n-        \n+\n     except Exception as e:\n         logger.error(f\"Failed to send notification: {e}\")\n         raise HTTPException(status_code=500, detail=str(e))\n+\n \n @app.get(\"/api/v1/notifications/unread\")\n async def get_unread_notifications(\n-    current_user: dict = Depends(validate_jwt_token),\n-    limit: int = 50\n+    current_user: dict = Depends(validate_jwt_token), limit: int = 50\n ):\n     \"\"\"Get unread notifications for the authenticated user\"\"\"\n     from providers.in_app import InAppProvider\n-    \n-    user_id = current_user[\"user_id\"]\n-    \n+\n+    user_id = current_user[\"user_id\"]\n+\n     try:\n         # Use in-app provider to get unread notifications\n         in_app_provider = InAppProvider({\"enabled\": True})\n         notifications = await in_app_provider.get_unread_notifications(user_id, limit)\n         unread_count = await in_app_provider.get_unread_count(user_id)\n-        \n+\n         return {\n             \"notifications\": notifications,\n             \"unread_count\": unread_count,\n             \"user_id\": user_id,\n-            \"limit\": limit\n+            \"limit\": limit,\n         }\n-        \n+\n     except Exception as e:\n         logger.error(f\"Failed to get unread notifications: {e}\")\n         raise HTTPException(status_code=500, detail=str(e))\n+\n \n # Additional notification endpoints\n @app.put(\"/api/v1/notifications/{notification_id}/read\")\n async def mark_notification_read(\n-    notification_id: str,\n-    current_user: dict = Depends(validate_jwt_token)\n+    notification_id: str, current_user: dict = Depends(validate_jwt_token)\n ):\n     \"\"\"Mark a notification as read\"\"\"\n     from providers.in_app import InAppProvider\n-    \n-    user_id = current_user[\"user_id\"]\n-    \n+\n+    user_id = current_user[\"user_id\"]\n+\n     try:\n         in_app_provider = InAppProvider({\"enabled\": True})\n         success = await in_app_provider.mark_as_read(notification_id, user_id)\n-        \n+\n         if not success:\n             raise HTTPException(status_code=404, detail=\"Notification not found\")\n-        \n+\n         return {\"status\": \"success\", \"notification_id\": notification_id}\n-        \n+\n     except HTTPException:\n         raise\n     except Exception as e:\n         logger.error(f\"Failed to mark notification as read: {e}\")\n         raise HTTPException(status_code=500, detail=str(e))\n \n+\n @app.put(\"/api/v1/notifications/read-all\")\n-async def mark_all_notifications_read(\n-    current_user: dict = Depends(validate_jwt_token)\n-):\n+async def mark_all_notifications_read(current_user: dict = Depends(validate_jwt_token)):\n     \"\"\"Mark all notifications as read for the user\"\"\"\n     from providers.in_app import InAppProvider\n-    \n-    user_id = current_user[\"user_id\"]\n-    \n+\n+    user_id = current_user[\"user_id\"]\n+\n     try:\n         in_app_provider = InAppProvider({\"enabled\": True})\n         marked_count = await in_app_provider.mark_all_as_read(user_id)\n-        \n-        return {\n-            \"status\": \"success\",\n-            \"marked_count\": marked_count,\n-            \"user_id\": user_id\n-        }\n-        \n+\n+        return {\"status\": \"success\", \"marked_count\": marked_count, \"user_id\": user_id}\n+\n     except Exception as e:\n         logger.error(f\"Failed to mark all notifications as read: {e}\")\n         raise HTTPException(status_code=500, detail=str(e))\n+\n \n @app.get(\"/api/v1/notifications/history\")\n async def get_notification_history(\n-    current_user: dict = Depends(validate_jwt_token),\n-    page: int = 1,\n-    limit: int = 20\n+    current_user: dict = Depends(validate_jwt_token), page: int = 1, limit: int = 20\n ):\n     \"\"\"Get notification history for the user\"\"\"\n     user_id = current_user[\"user_id\"]\n-    \n+\n     try:\n         async with get_db_session() as session:\n             offset = (page - 1) * limit\n-            \n+\n             result = await session.execute(\n                 \"\"\"\n                 SELECT id, channel, subject, content, status, created_at, sent_at, is_read\n                 FROM notifications\n                 WHERE user_id = :user_id\n                 ORDER BY created_at DESC\n                 LIMIT :limit OFFSET :offset\n                 \"\"\",\n-                {\"user_id\": user_id, \"limit\": limit, \"offset\": offset}\n-            )\n-            \n+                {\"user_id\": user_id, \"limit\": limit, \"offset\": offset},\n+            )\n+\n             notifications = []\n             for row in result.fetchall():\n-                notifications.append({\n-                    \"id\": str(row.id),\n-                    \"channel\": row.channel,\n-                    \"subject\": row.subject,\n-                    \"content\": row.content[:200] + \"...\" if len(row.content) > 200 else row.content,\n-                    \"status\": row.status,\n-                    \"created_at\": row.created_at.isoformat(),\n-                    \"sent_at\": row.sent_at.isoformat() if row.sent_at else None,\n-                    \"is_read\": row.is_read\n-                })\n-            \n+                notifications.append(\n+                    {\n+                        \"id\": str(row.id),\n+                        \"channel\": row.channel,\n+                        \"subject\": row.subject,\n+                        \"content\": (\n+                            row.content[:200] + \"...\"\n+                            if len(row.content) > 200\n+                            else row.content\n+                        ),\n+                        \"status\": row.status,\n+                        \"created_at\": row.created_at.isoformat(),\n+                        \"sent_at\": row.sent_at.isoformat() if row.sent_at else None,\n+                        \"is_read\": row.is_read,\n+                    }\n+                )\n+\n             return {\n                 \"notifications\": notifications,\n                 \"page\": page,\n                 \"limit\": limit,\n-                \"user_id\": user_id\n+                \"user_id\": user_id,\n             }\n-            \n+\n     except Exception as e:\n         logger.error(f\"Failed to get notification history: {e}\")\n         raise HTTPException(status_code=500, detail=str(e))\n+\n \n @app.post(\"/api/v1/notifications/bulk\")\n async def send_bulk_notifications(\n     notifications: List[NotificationRequest],\n-    current_user: dict = Depends(validate_jwt_token)\n+    current_user: dict = Depends(validate_jwt_token),\n ):\n     \"\"\"Send multiple notifications in bulk\"\"\"\n     from tasks.notification_tasks import send_bulk_notifications as send_bulk_task\n-    \n+\n     user_id = current_user[\"user_id\"]\n     organization_id = current_user.get(\"organization_id\")\n-    \n+\n     try:\n         # Validate bulk request size\n         if len(notifications) > 1000:\n             raise HTTPException(\n                 status_code=400,\n-                detail=\"Maximum 1000 notifications allowed per bulk request\"\n-            )\n-        \n+                detail=\"Maximum 1000 notifications allowed per bulk request\",\n+            )\n+\n         # Prepare notification data for Celery task\n         notification_data = []\n         for notification in notifications:\n-            notification_data.append({\n-                \"channel\": notification.type,\n-                \"recipient\": notification.to,\n-                \"content\": notification.message,\n-                \"subject\": notification.subject,\n-                \"template_id\": notification.template_id,\n-                \"template_data\": notification.variables,\n-                \"metadata\": {\"sent_by\": user_id, \"organization_id\": organization_id}\n-            })\n-        \n+            notification_data.append(\n+                {\n+                    \"channel\": notification.type,\n+                    \"recipient\": notification.to,\n+                    \"content\": notification.message,\n+                    \"subject\": notification.subject,\n+                    \"template_id\": notification.template_id,\n+                    \"template_data\": notification.variables,\n+                    \"metadata\": {\n+                        \"sent_by\": user_id,\n+                        \"organization_id\": organization_id,\n+                    },\n+                }\n+            )\n+\n         # Send bulk notifications\n         task_result = send_bulk_task.apply_async(args=(notification_data,))\n-        \n+\n         return {\n             \"task_id\": task_result.id,\n             \"status\": \"queued\",\n             \"notification_count\": len(notifications),\n             \"sent_by\": user_id,\n-            \"organization\": organization_id\n+            \"organization\": organization_id,\n         }\n-        \n+\n     except HTTPException:\n         raise\n     except Exception as e:\n         logger.error(f\"Failed to send bulk notifications: {e}\")\n         raise HTTPException(status_code=500, detail=str(e))\n+\n \n # Messaging endpoints\n @app.post(\"/api/v1/messages\")\n async def send_message(\n-    message: MessageRequest,\n-    current_user: dict = Depends(validate_jwt_token)\n+    message: MessageRequest, current_user: dict = Depends(validate_jwt_token)\n ):\n     \"\"\"Send a message in a conversation\"\"\"\n     user_id = current_user[\"user_id\"]\n     organization_id = current_user.get(\"organization_id\")\n-    \n+\n     # TODO: Implement message sending with conversation management\n     return {\n         \"message\": \"Message sending endpoint - TODO: implement\",\n         \"conversation_id\": message.conversation_id,\n         \"recipient\": message.to_user_id,\n         \"sender\": user_id,\n-        \"organization\": organization_id\n+        \"organization\": organization_id,\n     }\n \n+\n @app.get(\"/api/v1/conversations\")\n-async def list_conversations(\n-    current_user: dict = Depends(validate_jwt_token)\n-):\n+async def list_conversations(current_user: dict = Depends(validate_jwt_token)):\n     \"\"\"List conversations for the authenticated user\"\"\"\n     user_id = current_user[\"user_id\"]\n     organization_id = current_user.get(\"organization_id\")\n-    \n+\n     # TODO: Implement conversation listing\n     return {\n         \"message\": f\"Conversations for user {user_id} - TODO: implement\",\n         \"user_id\": user_id,\n-        \"organization\": organization_id\n+        \"organization\": organization_id,\n     }\n+\n \n @app.get(\"/api/v1/conversations/{conversation_id}\")\n async def get_conversation(\n-    conversation_id: str,\n-    current_user: dict = Depends(validate_jwt_token)\n+    conversation_id: str, current_user: dict = Depends(validate_jwt_token)\n ):\n     \"\"\"Get conversation history\"\"\"\n     user_id = current_user[\"user_id\"]\n     user_roles = current_user.get(\"roles\", [])\n-    \n+\n     # TODO: Implement conversation history retrieval with access control\n     return {\n         \"message\": f\"Conversation {conversation_id} history - TODO: implement\",\n         \"conversation_id\": conversation_id,\n         \"requested_by\": user_id,\n-        \"user_roles\": user_roles\n+        \"user_roles\": user_roles,\n     }\n+\n \n # Template management\n @app.post(\"/api/v1/templates\")\n async def create_template(\n-    template_data: dict,\n-    current_user: dict = Depends(validate_jwt_token)\n+    template_data: dict, current_user: dict = Depends(validate_jwt_token)\n ):\n     \"\"\"Create a notification template\"\"\"\n     user_id = current_user[\"user_id\"]\n     organization_id = current_user.get(\"organization_id\")\n     user_roles = current_user.get(\"roles\", [])\n-    \n+\n     # TODO: Implement template creation and management with role checks\n     return {\n         \"message\": \"Template creation endpoint - TODO: implement\",\n         \"created_by\": user_id,\n         \"organization\": organization_id,\n-        \"user_roles\": user_roles\n+        \"user_roles\": user_roles,\n     }\n+\n \n @app.get(\"/api/v1/templates\")\n async def list_templates(\n     current_user: dict = Depends(validate_jwt_token),\n     category_id: Optional[str] = None,\n     channel: Optional[str] = None,\n-    language: Optional[str] = \"en\"\n+    language: Optional[str] = \"en\",\n ):\n     \"\"\"List available notification templates\"\"\"\n     user_id = current_user[\"user_id\"]\n     organization_id = current_user.get(\"organization_id\")\n-    \n+\n     try:\n         async with get_db_session() as session:\n             query = \"\"\"\n                 SELECT t.id, t.name, t.subject, t.channel, t.language, t.version, t.is_active,\n                        c.name as category_name, t.created_at, t.updated_at\n                 FROM notification_templates t\n                 LEFT JOIN notification_categories c ON t.category_id = c.id\n                 WHERE t.is_active = true\n             \"\"\"\n             params = {}\n-            \n+\n             if category_id:\n                 query += \" AND t.category_id = :category_id\"\n                 params[\"category_id\"] = category_id\n-            \n+\n             if channel:\n                 query += \" AND t.channel = :channel\"\n                 params[\"channel\"] = channel\n-            \n+\n             if language:\n                 query += \" AND t.language = :language\"\n                 params[\"language\"] = language\n-            \n+\n             query += \" ORDER BY t.name, t.version DESC\"\n-            \n+\n             result = await session.execute(query, params)\n-            \n+\n             templates = []\n             for row in result.fetchall():\n-                templates.append({\n-                    \"id\": str(row.id),\n-                    \"name\": row.name,\n-                    \"subject\": row.subject,\n-                    \"channel\": row.channel,\n-                    \"language\": row.language,\n-                    \"version\": row.version,\n-                    \"category\": row.category_name,\n-                    \"is_active\": row.is_active,\n-                    \"created_at\": row.created_at.isoformat(),\n-                    \"updated_at\": row.updated_at.isoformat()\n-                })\n-            \n+                templates.append(\n+                    {\n+                        \"id\": str(row.id),\n+                        \"name\": row.name,\n+                        \"subject\": row.subject,\n+                        \"channel\": row.channel,\n+                        \"language\": row.language,\n+                        \"version\": row.version,\n+                        \"category\": row.category_name,\n+                        \"is_active\": row.is_active,\n+                        \"created_at\": row.created_at.isoformat(),\n+                        \"updated_at\": row.updated_at.isoformat(),\n+                    }\n+                )\n+\n             return {\n                 \"templates\": templates,\n                 \"total\": len(templates),\n                 \"filters\": {\n                     \"category_id\": category_id,\n                     \"channel\": channel,\n-                    \"language\": language\n-                }\n+                    \"language\": language,\n+                },\n             }\n-            \n+\n     except Exception as e:\n         logger.error(f\"Failed to list templates: {e}\")\n         raise HTTPException(status_code=500, detail=str(e))\n+\n \n @app.get(\"/api/v1/templates/{template_id}\")\n async def get_template(\n-    template_id: str,\n-    current_user: dict = Depends(validate_jwt_token)\n+    template_id: str, current_user: dict = Depends(validate_jwt_token)\n ):\n     \"\"\"Get specific template details\"\"\"\n     try:\n         async with get_db_session() as session:\n             result = await session.execute(\n@@ -588,17 +616,17 @@\n                        t.created_at, t.updated_at\n                 FROM notification_templates t\n                 LEFT JOIN notification_categories c ON t.category_id = c.id\n                 WHERE t.id = :template_id\n                 \"\"\",\n-                {\"template_id\": template_id}\n-            )\n-            \n+                {\"template_id\": template_id},\n+            )\n+\n             row = result.fetchone()\n             if not row:\n                 raise HTTPException(status_code=404, detail=\"Template not found\")\n-            \n+\n             return {\n                 \"id\": str(row.id),\n                 \"name\": row.name,\n                 \"subject\": row.subject,\n                 \"content\": row.content,\n@@ -607,134 +635,128 @@\n                 \"variables\": row.variables or {},\n                 \"version\": row.version,\n                 \"category\": row.category_name,\n                 \"is_active\": row.is_active,\n                 \"created_at\": row.created_at.isoformat(),\n-                \"updated_at\": row.updated_at.isoformat()\n+                \"updated_at\": row.updated_at.isoformat(),\n             }\n-            \n+\n     except HTTPException:\n         raise\n     except Exception as e:\n         logger.error(f\"Failed to get template: {e}\")\n         raise HTTPException(status_code=500, detail=str(e))\n+\n \n @app.post(\"/api/v1/templates/render\")\n async def render_template(\n     template_id: str,\n     variables: Dict[str, Any],\n     channel: Optional[str] = None,\n-    current_user: dict = Depends(validate_jwt_token)\n+    current_user: dict = Depends(validate_jwt_token),\n ):\n     \"\"\"Render template with provided variables\"\"\"\n     from template_engine import template_engine\n     from models import NotificationChannel\n-    \n+\n     try:\n         channel_enum = NotificationChannel(channel) if channel else None\n-        \n+\n         result = await template_engine.render_template(\n-            template_id,\n-            variables,\n-            channel_enum\n+            template_id, variables, channel_enum\n         )\n-        \n+\n         return {\n             \"template_id\": template_id,\n             \"rendered\": result,\n             \"variables_used\": variables,\n-            \"channel\": channel\n+            \"channel\": channel,\n         }\n-        \n+\n     except ValueError as e:\n         raise HTTPException(status_code=400, detail=str(e))\n     except Exception as e:\n         logger.error(f\"Failed to render template: {e}\")\n         raise HTTPException(status_code=500, detail=str(e))\n+\n \n @app.post(\"/api/v1/templates/preview\")\n async def preview_template(\n     template_content: str,\n     subject: str,\n     variables: Dict[str, Any],\n     channel: Optional[str] = None,\n-    current_user: dict = Depends(validate_jwt_token)\n+    current_user: dict = Depends(validate_jwt_token),\n ):\n     \"\"\"Preview template rendering without saving\"\"\"\n     from template_engine import template_engine\n     from models import NotificationChannel\n-    \n+\n     try:\n         channel_enum = NotificationChannel(channel) if channel else None\n-        \n+\n         result = await template_engine.preview_template(\n-            template_content,\n-            subject,\n-            variables,\n-            channel_enum\n+            template_content, subject, variables, channel_enum\n         )\n-        \n-        return {\n-            \"preview\": result,\n-            \"variables_used\": variables,\n-            \"channel\": channel\n-        }\n-        \n+\n+        return {\"preview\": result, \"variables_used\": variables, \"channel\": channel}\n+\n     except Exception as e:\n         logger.error(f\"Failed to preview template: {e}\")\n         raise HTTPException(status_code=400, detail=str(e))\n \n+\n @app.get(\"/api/v1/templates/categories\")\n-async def list_template_categories(\n-    current_user: dict = Depends(validate_jwt_token)\n-):\n+async def list_template_categories(current_user: dict = Depends(validate_jwt_token)):\n     \"\"\"List all notification categories\"\"\"\n     try:\n         async with get_db_session() as session:\n             result = await session.execute(\n                 \"\"\"\n                 SELECT id, name, description, default_enabled, created_at\n                 FROM notification_categories\n                 ORDER BY name\n                 \"\"\"\n             )\n-            \n+\n             categories = []\n             for row in result.fetchall():\n-                categories.append({\n-                    \"id\": str(row.id),\n-                    \"name\": row.name,\n-                    \"description\": row.description,\n-                    \"default_enabled\": row.default_enabled,\n-                    \"created_at\": row.created_at.isoformat()\n-                })\n-            \n+                categories.append(\n+                    {\n+                        \"id\": str(row.id),\n+                        \"name\": row.name,\n+                        \"description\": row.description,\n+                        \"default_enabled\": row.default_enabled,\n+                        \"created_at\": row.created_at.isoformat(),\n+                    }\n+                )\n+\n             return {\"categories\": categories}\n-            \n+\n     except Exception as e:\n         logger.error(f\"Failed to list categories: {e}\")\n         raise HTTPException(status_code=500, detail=str(e))\n+\n \n # Queue status\n @app.get(\"/api/v1/queue/status\")\n-async def queue_status(\n-    current_user: dict = Depends(validate_jwt_token)\n-):\n+async def queue_status(current_user: dict = Depends(validate_jwt_token)):\n     \"\"\"Get background job queue status\"\"\"\n     user_id = current_user[\"user_id\"]\n     user_roles = current_user.get(\"roles\", [])\n-    \n+\n     # TODO: Implement Celery queue monitoring with admin role check\n     return {\n         \"message\": \"Queue status endpoint - TODO: implement\",\n         \"requested_by\": user_id,\n-        \"user_roles\": user_roles\n+        \"user_roles\": user_roles,\n     }\n+\n \n if __name__ == \"__main__\":\n     uvicorn.run(\n         \"main:app\",\n         host=\"0.0.0.0\",\n         port=SERVICE_PORT,\n         reload=os.getenv(\"DEBUG\") == \"true\",\n-        log_level=\"info\"\n-    )\n\\ No newline at end of file\n+        log_level=\"info\",\n+    )\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/conftest.py\t2025-09-09 18:06:19.539520+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/conftest.py\t2025-09-10 11:37:02.159408+00:00\n@@ -1,9 +1,10 @@\n \"\"\"\n Pytest configuration and fixtures for Communication Service tests\n Comprehensive testing setup following standardized microservices approach\n \"\"\"\n+\n import os\n import pytest\n import uuid\n import asyncio\n import tempfile\n@@ -16,78 +17,85 @@\n from sqlalchemy.orm import sessionmaker\n from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\n from fastapi.testclient import TestClient\n \n # Set test environment variables before importing modules\n-os.environ.update({\n-    \"DATABASE_URL\": \"sqlite:///test_communication.db\",\n-    \"REDIS_URL\": \"redis://localhost:6379/15\",  # Use different DB for tests\n-    \"IDENTITY_SERVICE_URL\": \"http://test-identity:8001\",\n-    \"JWT_SECRET_KEY\": \"test-secret-key-for-testing-only\",\n-    \"DEBUG\": \"true\",\n-    \"TESTING\": \"true\",\n-    \"LOG_LEVEL\": \"ERROR\",\n-    \"EMAIL_BACKEND\": \"console\",  # Use console backend for testing\n-    \"CELERY_ALWAYS_EAGER\": \"true\",  # Execute tasks synchronously in tests\n-    \"CELERY_TASK_ALWAYS_EAGER\": \"true\"\n-})\n+os.environ.update(\n+    {\n+        \"DATABASE_URL\": \"sqlite:///test_communication.db\",\n+        \"REDIS_URL\": \"redis://localhost:6379/15\",  # Use different DB for tests\n+        \"IDENTITY_SERVICE_URL\": \"http://test-identity:8001\",\n+        \"JWT_SECRET_KEY\": \"test-secret-key-for-testing-only\",\n+        \"DEBUG\": \"true\",\n+        \"TESTING\": \"true\",\n+        \"LOG_LEVEL\": \"ERROR\",\n+        \"EMAIL_BACKEND\": \"console\",  # Use console backend for testing\n+        \"CELERY_ALWAYS_EAGER\": \"true\",  # Execute tasks synchronously in tests\n+        \"CELERY_TASK_ALWAYS_EAGER\": \"true\",\n+    }\n+)\n \n from models import Base, NotificationCategory, NotificationTemplate, Notification\n from database import DatabaseConfig, get_db_session\n from redis_client import RedisConfig, CacheManager\n from identity_client import IdentityServiceClient\n from main import app\n+\n \n @pytest.fixture(scope=\"session\")\n def event_loop():\n     \"\"\"Create event loop for async tests\"\"\"\n     loop = asyncio.new_event_loop()\n     asyncio.set_event_loop(loop)\n     yield loop\n     loop.close()\n \n+\n @pytest.fixture(scope=\"session\")\n def test_engine():\n     \"\"\"Create test database engine\"\"\"\n     engine = create_engine(\n         \"sqlite:///test_communication.db\",\n         connect_args={\"check_same_thread\": False},\n-        echo=False\n+        echo=False,\n     )\n     Base.metadata.create_all(bind=engine)\n     yield engine\n     # Cleanup\n     try:\n         os.remove(\"test_communication.db\")\n     except FileNotFoundError:\n         pass\n \n+\n @pytest.fixture(scope=\"session\")\n async def async_test_engine():\n     \"\"\"Create async test database engine\"\"\"\n     test_database_url = \"sqlite+aiosqlite:///test_communication_async.db\"\n     engine = create_async_engine(test_database_url, echo=False)\n-    \n+\n     # Create tables\n     async with engine.begin() as conn:\n         await conn.run_sync(Base.metadata.create_all)\n-    \n+\n     yield engine\n-    \n+\n     # Cleanup\n     async with engine.begin() as conn:\n         await conn.run_sync(Base.metadata.drop_all)\n     await engine.dispose()\n     try:\n         os.remove(\"test_communication_async.db\")\n     except FileNotFoundError:\n         pass\n \n+\n @pytest.fixture(scope=\"session\")\n def test_session_maker(test_engine):\n     \"\"\"Create test session maker\"\"\"\n     return sessionmaker(bind=test_engine)\n+\n \n @pytest.fixture\n def db_session(test_session_maker):\n     \"\"\"Create test database session\"\"\"\n     session = test_session_maker()\n@@ -97,36 +105,41 @@\n     except Exception:\n         session.rollback()\n     finally:\n         session.close()\n \n+\n @pytest.fixture\n def client():\n     \"\"\"Create test client\"\"\"\n     with TestClient(app) as test_client:\n         yield test_client\n \n+\n @pytest.fixture\n async def async_db_session(async_test_engine):\n     \"\"\"Create async test database session\"\"\"\n     async_session = sessionmaker(\n         async_test_engine, class_=AsyncSession, expire_on_commit=False\n     )\n-    \n+\n     async with async_session() as session:\n         yield session\n         await session.rollback()\n \n+\n @pytest.fixture\n def override_get_db(db_session):\n     \"\"\"Override database dependency for testing\"\"\"\n+\n     async def _get_test_db():\n         yield db_session\n-    \n+\n     app.dependency_overrides[get_db_session] = _get_test_db\n     yield\n     app.dependency_overrides.clear()\n+\n \n @pytest.fixture\n def mock_redis():\n     \"\"\"Mock Redis client with comprehensive methods\"\"\"\n     mock = AsyncMock()\n@@ -145,106 +158,116 @@\n     mock.hset.return_value = True\n     mock.hdel.return_value = 1\n     mock.expire.return_value = True\n     return mock\n \n+\n @pytest.fixture\n def mock_identity_client():\n     \"\"\"Mock Identity Service client\"\"\"\n     mock = AsyncMock(spec=IdentityServiceClient)\n-    \n+\n     # Mock user data\n     mock_user = {\n         \"user_id\": str(uuid.uuid4()),\n         \"email\": \"test@example.com\",\n         \"roles\": [\"user\"],\n         \"permissions\": [\"notification:read\", \"notification:write\"],\n         \"organization_id\": str(uuid.uuid4()),\n-        \"validated_at\": datetime.utcnow().isoformat()\n-    }\n-    \n+        \"validated_at\": datetime.utcnow().isoformat(),\n+    }\n+\n     mock.validate_token.return_value = mock_user\n     mock.get_user_profile.return_value = {\n         \"user_id\": mock_user[\"user_id\"],\n         \"name\": \"Test User\",\n         \"email\": \"test@example.com\",\n-        \"avatar_url\": None\n+        \"avatar_url\": None,\n     }\n     mock.get_user_contact_info.return_value = {\n         \"email\": \"test@example.com\",\n         \"phone\": \"+1234567890\",\n-        \"push_tokens\": [\"test-push-token\"]\n+        \"push_tokens\": [\"test-push-token\"],\n     }\n     mock.health_check.return_value = True\n-    \n+\n     return mock\n+\n \n @pytest.fixture\n def sample_notification_category(db_session):\n     \"\"\"Create sample notification category\"\"\"\n     category = NotificationCategory(\n         name=\"test_category\",\n         description=\"Test category for unit tests\",\n-        default_enabled=True\n+        default_enabled=True,\n     )\n     db_session.add(category)\n     db_session.commit()\n     return category\n \n+\n @pytest.fixture\n def sample_notification_template(db_session, sample_notification_category):\n     \"\"\"Create sample notification template\"\"\"\n     from models import NotificationChannel\n-    \n+\n     template = NotificationTemplate(\n         name=\"test_template\",\n         category_id=sample_notification_category.id,\n         channel=NotificationChannel.EMAIL,\n         language=\"en\",\n         subject=\"Test Subject\",\n         content=\"Hello {{name}}, this is a test notification.\",\n-        variables={\"name\": \"string\"}\n+        variables={\"name\": \"string\"},\n     )\n     db_session.add(template)\n     db_session.commit()\n     return template\n \n-@pytest.fixture\n-def sample_notification(db_session, sample_notification_category, sample_notification_template):\n+\n+@pytest.fixture\n+def sample_notification(\n+    db_session, sample_notification_category, sample_notification_template\n+):\n     \"\"\"Create sample notification\"\"\"\n     from models import NotificationChannel, NotificationStatus\n-    \n+\n     notification = Notification(\n         user_id=uuid.uuid4(),\n         category_id=sample_notification_category.id,\n         template_id=sample_notification_template.id,\n         channel=NotificationChannel.EMAIL,\n         subject=\"Test Notification\",\n         content=\"This is a test notification\",\n         data={\"name\": \"Test User\"},\n         status=NotificationStatus.PENDING,\n-        recipient=\"test@example.com\"\n+        recipient=\"test@example.com\",\n     )\n     db_session.add(notification)\n     db_session.commit()\n     return notification\n \n+\n # Enhanced Authentication Fixtures\n @pytest.fixture\n def valid_jwt_token():\n     \"\"\"Valid JWT token for testing\"\"\"\n     return \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.valid.token\"\n \n+\n @pytest.fixture\n def invalid_jwt_token():\n     \"\"\"Invalid JWT token for testing\"\"\"\n     return \"invalid.jwt.token\"\n \n+\n @pytest.fixture\n def expired_jwt_token():\n     \"\"\"Expired JWT token for testing\"\"\"\n     return \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.expired.token\"\n+\n \n @pytest.fixture\n def mock_user_data():\n     \"\"\"Mock authenticated user data\"\"\"\n     return {\n@@ -252,88 +275,103 @@\n         \"email\": \"test@example.com\",\n         \"organization_id\": \"org-123\",\n         \"roles\": [\"user\"],\n         \"permissions\": [\"notification:read\", \"notification:write\"],\n         \"is_active\": True,\n-        \"expires_at\": (datetime.utcnow() + timedelta(hours=1)).isoformat()\n-    }\n+        \"expires_at\": (datetime.utcnow() + timedelta(hours=1)).isoformat(),\n+    }\n+\n \n @pytest.fixture\n def admin_user_data():\n     \"\"\"Mock admin user data\"\"\"\n     return {\n-        \"user_id\": \"admin-user-123\", \n+        \"user_id\": \"admin-user-123\",\n         \"email\": \"admin@example.com\",\n         \"organization_id\": \"org-123\",\n         \"roles\": [\"admin\", \"user\"],\n-        \"permissions\": [\"notification:read\", \"notification:write\", \"notification:delete\", \"admin\"],\n+        \"permissions\": [\n+            \"notification:read\",\n+            \"notification:write\",\n+            \"notification:delete\",\n+            \"admin\",\n+        ],\n         \"is_active\": True,\n-        \"expires_at\": (datetime.utcnow() + timedelta(hours=1)).isoformat()\n-    }\n+        \"expires_at\": (datetime.utcnow() + timedelta(hours=1)).isoformat(),\n+    }\n+\n \n @pytest.fixture\n def auth_headers(valid_jwt_token):\n     \"\"\"Create valid authentication headers for API tests\"\"\"\n     return {\n         \"Authorization\": f\"Bearer {valid_jwt_token}\",\n-        \"Content-Type\": \"application/json\"\n-    }\n+        \"Content-Type\": \"application/json\",\n+    }\n+\n \n @pytest.fixture\n def admin_auth_headers(valid_jwt_token):\n     \"\"\"Create admin authentication headers for API tests\"\"\"\n     return {\n         \"Authorization\": f\"Bearer {valid_jwt_token}\",\n         \"Content-Type\": \"application/json\",\n-        \"X-Admin-Access\": \"true\"\n-    }\n+        \"X-Admin-Access\": \"true\",\n+    }\n+\n \n @pytest.fixture\n def mock_cache_manager(mock_redis):\n     \"\"\"Mock cache manager with Redis client\"\"\"\n     cache_manager = CacheManager(mock_redis, prefix=\"test_comm\")\n     return cache_manager\n+\n \n # Test data generators\n def generate_test_user(user_id: str = None) -> dict:\n     \"\"\"Generate test user data\"\"\"\n     return {\n         \"user_id\": user_id or str(uuid.uuid4()),\n         \"email\": \"test@example.com\",\n         \"name\": \"Test User\",\n         \"roles\": [\"user\"],\n         \"permissions\": [\"notification:read\", \"notification:write\"],\n-        \"organization_id\": str(uuid.uuid4())\n-    }\n+        \"organization_id\": str(uuid.uuid4()),\n+    }\n+\n \n def generate_test_notification_data() -> dict:\n     \"\"\"Generate test notification data\"\"\"\n     return {\n         \"user_id\": str(uuid.uuid4()),\n         \"channel\": \"email\",\n         \"subject\": \"Test Notification\",\n         \"content\": \"This is a test notification\",\n         \"recipient\": \"test@example.com\",\n         \"category\": \"system\",\n-        \"data\": {\"name\": \"Test User\"}\n-    }\n+        \"data\": {\"name\": \"Test User\"},\n+    }\n+\n \n # Authentication fixtures for JWT testing\n @pytest.fixture\n def valid_jwt_token():\n     \"\"\"Valid JWT token for testing\"\"\"\n     return \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.valid.token\"\n \n+\n @pytest.fixture\n def invalid_jwt_token():\n     \"\"\"Invalid JWT token for testing\"\"\"\n     return \"invalid.jwt.token\"\n \n+\n @pytest.fixture\n def expired_jwt_token():\n     \"\"\"Expired JWT token for testing\"\"\"\n     return \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.expired.token\"\n+\n \n @pytest.fixture\n def mock_valid_user():\n     \"\"\"Mock valid user data from Identity Service\"\"\"\n     return {\n@@ -341,12 +379,13 @@\n         \"organization_id\": \"87654321-4321-8765-2109-876543210987\",\n         \"email\": \"test@example.com\",\n         \"roles\": [\"user\"],\n         \"permissions\": [\"read\", \"write\"],\n         \"is_verified\": True,\n-        \"expires_at\": \"2025-12-31T23:59:59Z\"\n-    }\n+        \"expires_at\": \"2025-12-31T23:59:59Z\",\n+    }\n+\n \n @pytest.fixture\n def mock_admin_user():\n     \"\"\"Mock admin user data from Identity Service\"\"\"\n     return {\n@@ -354,199 +393,221 @@\n         \"organization_id\": \"org-admin-987-654\",\n         \"email\": \"admin@example.com\",\n         \"roles\": [\"admin\", \"user\"],\n         \"permissions\": [\"read\", \"write\", \"admin\", \"manage\"],\n         \"is_verified\": True,\n-        \"expires_at\": \"2025-12-31T23:59:59Z\"\n-    }\n+        \"expires_at\": \"2025-12-31T23:59:59Z\",\n+    }\n+\n \n @pytest.fixture\n def auth_headers_valid(valid_jwt_token):\n     \"\"\"Valid authentication headers\"\"\"\n     return {\n         \"Authorization\": f\"Bearer {valid_jwt_token}\",\n-        \"Content-Type\": \"application/json\"\n-    }\n+        \"Content-Type\": \"application/json\",\n+    }\n+\n \n @pytest.fixture\n def auth_headers_invalid(invalid_jwt_token):\n     \"\"\"Invalid authentication headers\"\"\"\n     return {\n         \"Authorization\": f\"Bearer {invalid_jwt_token}\",\n-        \"Content-Type\": \"application/json\"\n-    }\n+        \"Content-Type\": \"application/json\",\n+    }\n+\n \n @pytest.fixture\n def mock_identity_service_success(mock_valid_user):\n     \"\"\"Mock successful Identity Service response\"\"\"\n     mock_response = AsyncMock()\n     mock_response.status_code = 200\n     mock_response.json.return_value = mock_valid_user\n     return mock_response\n \n+\n @pytest.fixture\n def mock_identity_service_unauthorized():\n     \"\"\"Mock unauthorized Identity Service response\"\"\"\n     mock_response = AsyncMock()\n     mock_response.status_code = 401\n     mock_response.json.return_value = {\"detail\": \"Invalid token\"}\n     return mock_response\n \n+\n @pytest.fixture\n def mock_identity_service_timeout():\n     \"\"\"Mock Identity Service timeout\"\"\"\n     return Exception(\"Timeout\")\n \n+\n @pytest.fixture\n def mock_identity_service_network_error():\n     \"\"\"Mock Identity Service network error\"\"\"\n     import httpx\n+\n     return httpx.RequestError(\"Network error\")\n \n-@pytest.fixture \n+\n+@pytest.fixture\n def protected_endpoints():\n     \"\"\"List of all protected API endpoints for testing\"\"\"\n     return [\n-        (\"POST\", \"/api/v1/notifications\", {\"type\": \"email\", \"to\": \"test@example.com\", \"message\": \"test\"}),\n+        (\n+            \"POST\",\n+            \"/api/v1/notifications\",\n+            {\"type\": \"email\", \"to\": \"test@example.com\", \"message\": \"test\"},\n+        ),\n         (\"GET\", \"/api/v1/notifications/unread\", None),\n         (\"POST\", \"/api/v1/messages\", {\"to_user_id\": \"123\", \"message\": \"test\"}),\n         (\"GET\", \"/api/v1/conversations\", None),\n         (\"GET\", \"/api/v1/conversations/test-id\", None),\n         (\"POST\", \"/api/v1/templates\", {\"name\": \"test\"}),\n         (\"GET\", \"/api/v1/templates\", None),\n         (\"GET\", \"/api/v1/queue/status\", None),\n     ]\n \n+\n # Test utilities\n class TestUtils:\n     \"\"\"Utility functions for tests\"\"\"\n-    \n+\n     @staticmethod\n     def assert_notification_data(notification, expected_data):\n         \"\"\"Assert notification matches expected data\"\"\"\n         assert notification.user_id == expected_data[\"user_id\"]\n         assert notification.channel.value == expected_data[\"channel\"]\n         assert notification.subject == expected_data[\"subject\"]\n         assert notification.content == expected_data[\"content\"]\n         assert notification.recipient == expected_data[\"recipient\"]\n-    \n+\n     @staticmethod\n     def create_mock_response(status_code: int = 200, data: dict = None):\n         \"\"\"Create mock HTTP response\"\"\"\n         mock_response = MagicMock()\n         mock_response.status_code = status_code\n         mock_response.json.return_value = data or {}\n         return mock_response\n \n+\n class AuthTestUtils:\n     \"\"\"Utility functions specifically for authentication testing\"\"\"\n-    \n+\n     @staticmethod\n     def assert_unauthorized_response(response):\n         \"\"\"Assert response is properly unauthorized\"\"\"\n         assert response.status_code == 401\n         assert \"detail\" in response.json()\n-        \n+\n     @staticmethod\n     def assert_service_unavailable_response(response):\n         \"\"\"Assert response indicates service unavailable\"\"\"\n         assert response.status_code == 503\n         assert \"detail\" in response.json()\n         assert \"unavailable\" in response.json()[\"detail\"].lower()\n-    \n+\n     @staticmethod\n     def assert_has_www_authenticate_header(response):\n         \"\"\"Assert response has WWW-Authenticate header\"\"\"\n         assert \"WWW-Authenticate\" in response.headers\n         assert response.headers[\"WWW-Authenticate\"] == \"Bearer\"\n-    \n+\n     @staticmethod\n     def assert_user_context_in_response(response, expected_user):\n         \"\"\"Assert user context is properly included in response\"\"\"\n         response_data = response.json()\n         user_fields = [\"user_id\", \"sent_by\", \"requested_by\", \"created_by\"]\n-        \n+\n         # Check if any user field is present and matches expected user\n         found_user_field = False\n         for field in user_fields:\n             if field in response_data:\n                 assert response_data[field] == expected_user[\"user_id\"]\n                 found_user_field = True\n                 break\n-        \n+\n         if not found_user_field:\n             # Some endpoints might not include user context in response but should still work\n             assert response.status_code == 200\n \n+\n # Additional Enhanced Fixtures for Comprehensive Testing\n+\n \n # Notification Provider Mock Fixtures\n @pytest.fixture\n def mock_email_provider():\n     \"\"\"Mock email notification provider\"\"\"\n-    with patch('providers.email.EmailProvider') as mock_provider:\n+    with patch(\"providers.email.EmailProvider\") as mock_provider:\n         mock_instance = AsyncMock()\n         mock_instance.send.return_value = {\"status\": \"sent\", \"message_id\": \"email-123\"}\n         mock_provider.return_value = mock_instance\n         yield mock_instance\n \n+\n @pytest.fixture\n def mock_sms_provider():\n     \"\"\"Mock SMS notification provider\"\"\"\n-    with patch('providers.sms.SMSProvider') as mock_provider:\n+    with patch(\"providers.sms.SMSProvider\") as mock_provider:\n         mock_instance = AsyncMock()\n         mock_instance.send.return_value = {\"status\": \"sent\", \"message_id\": \"sms-123\"}\n         mock_provider.return_value = mock_instance\n         yield mock_instance\n \n+\n @pytest.fixture\n def mock_push_provider():\n     \"\"\"Mock push notification provider\"\"\"\n-    with patch('providers.push.PushProvider') as mock_provider:\n+    with patch(\"providers.push.PushProvider\") as mock_provider:\n         mock_instance = AsyncMock()\n         mock_instance.send.return_value = {\"status\": \"sent\", \"message_id\": \"push-123\"}\n         mock_provider.return_value = mock_instance\n         yield mock_instance\n \n+\n @pytest.fixture\n def mock_in_app_provider():\n     \"\"\"Mock in-app notification provider\"\"\"\n-    with patch('providers.in_app.InAppProvider') as mock_provider:\n+    with patch(\"providers.in_app.InAppProvider\") as mock_provider:\n         mock_instance = AsyncMock()\n         mock_instance.send.return_value = {\"status\": \"sent\", \"message_id\": \"inapp-123\"}\n         mock_instance.get_unread_notifications.return_value = []\n         mock_instance.get_unread_count.return_value = 0\n         mock_provider.return_value = mock_instance\n         yield mock_instance\n \n+\n # Celery Mock Fixtures\n @pytest.fixture\n def mock_celery_task():\n     \"\"\"Mock Celery task execution\"\"\"\n-    with patch('tasks.notification_tasks.send_notification') as mock_task:\n+    with patch(\"tasks.notification_tasks.send_notification\") as mock_task:\n         mock_result = MagicMock()\n         mock_result.id = \"task-123\"\n         mock_result.status = \"SUCCESS\"\n         mock_result.result = {\"status\": \"sent\", \"message_id\": \"msg-123\"}\n         mock_task.apply_async.return_value = mock_result\n         yield mock_task\n \n+\n # Template Engine Mock Fixtures\n @pytest.fixture\n def mock_template_engine():\n     \"\"\"Mock template rendering engine\"\"\"\n-    with patch('services.template_engine.TemplateEngine') as mock_engine:\n+    with patch(\"services.template_engine.TemplateEngine\") as mock_engine:\n         mock_instance = MagicMock()\n         mock_instance.render.return_value = \"Rendered template content\"\n         mock_instance.validate_template.return_value = True\n         mock_engine.return_value = mock_instance\n         yield mock_instance\n \n+\n # Test Data Factories\n class NotificationDataFactory:\n     \"\"\"Factory for generating test notification data\"\"\"\n-    \n+\n     @staticmethod\n     def create_email_notification(user_id: str = None, **kwargs):\n         \"\"\"Create email notification test data\"\"\"\n         default_data = {\n             \"user_id\": user_id or str(uuid.uuid4()),\n@@ -554,30 +615,30 @@\n             \"subject\": \"Test Email Notification\",\n             \"content\": \"This is a test email notification content.\",\n             \"recipient\": \"test@example.com\",\n             \"category\": \"system\",\n             \"priority\": \"normal\",\n-            \"data\": {\"name\": \"Test User\", \"action\": \"test_action\"}\n+            \"data\": {\"name\": \"Test User\", \"action\": \"test_action\"},\n         }\n         default_data.update(kwargs)\n         return default_data\n-    \n+\n     @staticmethod\n     def create_sms_notification(user_id: str = None, **kwargs):\n         \"\"\"Create SMS notification test data\"\"\"\n         default_data = {\n             \"user_id\": user_id or str(uuid.uuid4()),\n             \"channel\": \"sms\",\n             \"content\": \"Test SMS notification message.\",\n             \"recipient\": \"+1234567890\",\n             \"category\": \"alert\",\n             \"priority\": \"high\",\n-            \"data\": {\"code\": \"123456\"}\n+            \"data\": {\"code\": \"123456\"},\n         }\n         default_data.update(kwargs)\n         return default_data\n-    \n+\n     @staticmethod\n     def create_push_notification(user_id: str = None, **kwargs):\n         \"\"\"Create push notification test data\"\"\"\n         default_data = {\n             \"user_id\": user_id or str(uuid.uuid4()),\n@@ -585,25 +646,34 @@\n             \"title\": \"Test Push Notification\",\n             \"content\": \"This is a test push notification.\",\n             \"recipient\": \"push-token-123\",\n             \"category\": \"update\",\n             \"priority\": \"normal\",\n-            \"data\": {\"deep_link\": \"/notifications\"}\n+            \"data\": {\"deep_link\": \"/notifications\"},\n         }\n         default_data.update(kwargs)\n         return default_data\n \n+\n # Test fixtures for specific notification types\n @pytest.fixture\n def email_notification_data(mock_user_data):\n     \"\"\"Email notification test data\"\"\"\n-    return NotificationDataFactory.create_email_notification(user_id=mock_user_data[\"user_id\"])\n+    return NotificationDataFactory.create_email_notification(\n+        user_id=mock_user_data[\"user_id\"]\n+    )\n+\n \n @pytest.fixture\n def sms_notification_data(mock_user_data):\n     \"\"\"SMS notification test data\"\"\"\n-    return NotificationDataFactory.create_sms_notification(user_id=mock_user_data[\"user_id\"])\n+    return NotificationDataFactory.create_sms_notification(\n+        user_id=mock_user_data[\"user_id\"]\n+    )\n+\n \n @pytest.fixture\n def push_notification_data(mock_user_data):\n     \"\"\"Push notification test data\"\"\"\n-    return NotificationDataFactory.create_push_notification(user_id=mock_user_data[\"user_id\"])\n\\ No newline at end of file\n+    return NotificationDataFactory.create_push_notification(\n+        user_id=mock_user_data[\"user_id\"]\n+    )\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/performance/locustfile.py\t2025-09-09 19:35:30.666192+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/performance/locustfile.py\t2025-09-10 11:37:02.170758+00:00\n@@ -9,25 +9,25 @@\n from locust import HttpUser, task, between\n \n \n class NotificationUser(HttpUser):\n     \"\"\"Simulated user for notification load testing\"\"\"\n-    \n+\n     wait_time = between(1, 3)  # Wait 1-3 seconds between requests\n-    \n+\n     def on_start(self):\n         \"\"\"Setup user session\"\"\"\n         # Mock JWT token for testing\n         self.headers = {\n             \"Authorization\": \"Bearer mock.jwt.token.for.load.testing\",\n-            \"Content-Type\": \"application/json\"\n-        }\n-        \n+            \"Content-Type\": \"application/json\",\n+        }\n+\n         # User data for varied testing\n         self.user_id = f\"load_test_user_{random.randint(1, 1000)}\"\n         self.organization_id = f\"org_{random.randint(1, 10)}\"\n-    \n+\n     @task(10)  # Weight: high frequency\n     def send_email_notification(self):\n         \"\"\"Send email notification - most common operation\"\"\"\n         notification_data = {\n             \"type\": \"email\",\n@@ -37,46 +37,47 @@\n             \"priority\": random.choice([\"urgent\", \"high\", \"normal\", \"low\"]),\n             \"data\": {\n                 \"test_type\": \"load_test\",\n                 \"user_id\": self.user_id,\n                 \"organization_id\": self.organization_id,\n-                \"timestamp\": datetime.now().isoformat()\n-            }\n-        }\n-        \n-        with self.client.post(\"/api/v1/notifications\",\n-                              json=notification_data,\n-                              headers=self.headers,\n-                              catch_response=True) as response:\n+                \"timestamp\": datetime.now().isoformat(),\n+            },\n+        }\n+\n+        with self.client.post(\n+            \"/api/v1/notifications\",\n+            json=notification_data,\n+            headers=self.headers,\n+            catch_response=True,\n+        ) as response:\n             if response.status_code == 200:\n                 response.success()\n             else:\n                 response.failure(f\"Email notification failed: {response.status_code}\")\n-    \n+\n     @task(5)  # Weight: medium frequency\n     def send_sms_notification(self):\n         \"\"\"Send SMS notification\"\"\"\n         notification_data = {\n             \"type\": \"sms\",\n             \"to\": f\"+1{random.randint(2000000000, 9999999999)}\",\n             \"message\": f\"Load test SMS {random.randint(1000, 9999)}. System performance verification in progress.\",\n             \"priority\": random.choice([\"urgent\", \"high\", \"normal\"]),\n-            \"data\": {\n-                \"test_type\": \"load_test_sms\",\n-                \"user_id\": self.user_id\n-            }\n-        }\n-        \n-        with self.client.post(\"/api/v1/notifications\",\n-                              json=notification_data,\n-                              headers=self.headers,\n-                              catch_response=True) as response:\n+            \"data\": {\"test_type\": \"load_test_sms\", \"user_id\": self.user_id},\n+        }\n+\n+        with self.client.post(\n+            \"/api/v1/notifications\",\n+            json=notification_data,\n+            headers=self.headers,\n+            catch_response=True,\n+        ) as response:\n             if response.status_code == 200:\n                 response.success()\n             else:\n                 response.failure(f\"SMS notification failed: {response.status_code}\")\n-    \n+\n     @task(3)  # Weight: lower frequency\n     def send_push_notification(self):\n         \"\"\"Send push notification\"\"\"\n         notification_data = {\n             \"type\": \"push\",\n@@ -84,67 +85,75 @@\n             \"title\": \"Load Test Push Notification\",\n             \"message\": \"Testing push notification system performance\",\n             \"data\": {\n                 \"test_type\": \"load_test_push\",\n                 \"deep_link\": f\"/test/{random.randint(1, 100)}\",\n-                \"user_id\": self.user_id\n-            }\n-        }\n-        \n-        with self.client.post(\"/api/v1/notifications\",\n-                              json=notification_data,\n-                              headers=self.headers,\n-                              catch_response=True) as response:\n+                \"user_id\": self.user_id,\n+            },\n+        }\n+\n+        with self.client.post(\n+            \"/api/v1/notifications\",\n+            json=notification_data,\n+            headers=self.headers,\n+            catch_response=True,\n+        ) as response:\n             if response.status_code == 200:\n                 response.success()\n             else:\n                 response.failure(f\"Push notification failed: {response.status_code}\")\n-    \n+\n     @task(4)  # Weight: medium frequency\n     def get_unread_notifications(self):\n         \"\"\"Get unread notifications\"\"\"\n-        with self.client.get(\"/api/v1/notifications/unread\",\n-                             headers=self.headers,\n-                             catch_response=True) as response:\n-            if response.status_code == 200:\n-                response.success()\n-            else:\n-                response.failure(f\"Get unread notifications failed: {response.status_code}\")\n-    \n+        with self.client.get(\n+            \"/api/v1/notifications/unread\", headers=self.headers, catch_response=True\n+        ) as response:\n+            if response.status_code == 200:\n+                response.success()\n+            else:\n+                response.failure(\n+                    f\"Get unread notifications failed: {response.status_code}\"\n+                )\n+\n     @task(2)  # Weight: low frequency\n     def mark_notifications_read(self):\n         \"\"\"Mark notifications as read\"\"\"\n         request_data = {\n             \"notification_ids\": [\n-                f\"notif_{random.randint(1, 1000)}_{i}\" \n+                f\"notif_{random.randint(1, 1000)}_{i}\"\n                 for i in range(random.randint(1, 5))\n             ]\n         }\n-        \n-        with self.client.post(\"/api/v1/notifications/mark-read\",\n-                              json=request_data,\n-                              headers=self.headers,\n-                              catch_response=True) as response:\n+\n+        with self.client.post(\n+            \"/api/v1/notifications/mark-read\",\n+            json=request_data,\n+            headers=self.headers,\n+            catch_response=True,\n+        ) as response:\n             if response.status_code == 200:\n                 response.success()\n             else:\n                 response.failure(f\"Mark read failed: {response.status_code}\")\n-    \n+\n     @task(1)  # Weight: very low frequency\n     def get_notification_status(self):\n         \"\"\"Check notification status\"\"\"\n         notification_id = f\"status_test_{random.randint(1, 100)}\"\n-        \n-        with self.client.get(f\"/api/v1/notifications/{notification_id}/status\",\n-                             headers=self.headers,\n-                             catch_response=True) as response:\n+\n+        with self.client.get(\n+            f\"/api/v1/notifications/{notification_id}/status\",\n+            headers=self.headers,\n+            catch_response=True,\n+        ) as response:\n             if response.status_code in [200, 404]:  # 404 is acceptable for random IDs\n                 response.success()\n             else:\n                 response.failure(f\"Status check failed: {response.status_code}\")\n-    \n-    @task(1)  # Weight: very low frequency  \n+\n+    @task(1)  # Weight: very low frequency\n     def health_check(self):\n         \"\"\"Health check endpoint\"\"\"\n         with self.client.get(\"/health\", catch_response=True) as response:\n             if response.status_code == 200:\n                 response.success()\n@@ -152,162 +161,171 @@\n                 response.failure(f\"Health check failed: {response.status_code}\")\n \n \n class AdminUser(HttpUser):\n     \"\"\"Simulated admin user for administrative operations\"\"\"\n-    \n+\n     wait_time = between(5, 10)  # Admins operate less frequently\n     weight = 1  # Lower weight (fewer admin users)\n-    \n+\n     def on_start(self):\n         \"\"\"Setup admin session\"\"\"\n         self.headers = {\n             \"Authorization\": \"Bearer admin.jwt.token.for.load.testing\",\n-            \"Content-Type\": \"application/json\"\n-        }\n-    \n+            \"Content-Type\": \"application/json\",\n+        }\n+\n     @task(5)\n     def create_notification_template(self):\n         \"\"\"Create notification template\"\"\"\n         template_data = {\n             \"name\": f\"Load Test Template {random.randint(1, 1000)}\",\n             \"subject\": \"Load Test Template - {{ user_name }}\",\n             \"content\": \"Hello {{ user_name }}, this is a load test template notification for {{ organization_name }}.\",\n             \"channel\": random.choice([\"email\", \"sms\", \"push\"]),\n             \"variables\": [\"user_name\", \"organization_name\"],\n-            \"metadata\": {\n-                \"created_by\": \"load_test\",\n-                \"test_type\": \"template_creation\"\n-            }\n-        }\n-        \n-        with self.client.post(\"/api/v1/templates\",\n-                              json=template_data,\n-                              headers=self.headers,\n-                              catch_response=True) as response:\n+            \"metadata\": {\"created_by\": \"load_test\", \"test_type\": \"template_creation\"},\n+        }\n+\n+        with self.client.post(\n+            \"/api/v1/templates\",\n+            json=template_data,\n+            headers=self.headers,\n+            catch_response=True,\n+        ) as response:\n             if response.status_code == 201:\n                 response.success()\n             else:\n                 response.failure(f\"Template creation failed: {response.status_code}\")\n-    \n+\n     @task(3)\n     def get_templates_list(self):\n         \"\"\"Get templates list\"\"\"\n         params = {\n             \"page\": random.randint(1, 5),\n             \"page_size\": 20,\n-            \"channel\": random.choice([\"email\", \"sms\", \"push\", \"\"])\n-        }\n-        \n-        with self.client.get(\"/api/v1/templates\",\n-                             params=params,\n-                             headers=self.headers,\n-                             catch_response=True) as response:\n+            \"channel\": random.choice([\"email\", \"sms\", \"push\", \"\"]),\n+        }\n+\n+        with self.client.get(\n+            \"/api/v1/templates\",\n+            params=params,\n+            headers=self.headers,\n+            catch_response=True,\n+        ) as response:\n             if response.status_code == 200:\n                 response.success()\n             else:\n                 response.failure(f\"Get templates failed: {response.status_code}\")\n-    \n+\n     @task(2)\n     def get_queue_status(self):\n         \"\"\"Get queue status (admin only)\"\"\"\n-        with self.client.get(\"/api/v1/queue/status\",\n-                             headers=self.headers,\n-                             catch_response=True) as response:\n+        with self.client.get(\n+            \"/api/v1/queue/status\", headers=self.headers, catch_response=True\n+        ) as response:\n             if response.status_code == 200:\n                 response.success()\n             else:\n                 response.failure(f\"Queue status failed: {response.status_code}\")\n-    \n+\n     @task(1)\n     def get_analytics(self):\n         \"\"\"Get notification analytics (admin only)\"\"\"\n         params = {\n             \"start_date\": \"2024-01-01\",\n             \"end_date\": datetime.now().strftime(\"%Y-%m-%d\"),\n-            \"channel\": random.choice([\"email\", \"sms\", \"push\", \"all\"])\n-        }\n-        \n-        with self.client.get(\"/api/v1/analytics/notifications\",\n-                             params=params,\n-                             headers=self.headers,\n-                             catch_response=True) as response:\n+            \"channel\": random.choice([\"email\", \"sms\", \"push\", \"all\"]),\n+        }\n+\n+        with self.client.get(\n+            \"/api/v1/analytics/notifications\",\n+            params=params,\n+            headers=self.headers,\n+            catch_response=True,\n+        ) as response:\n             if response.status_code == 200:\n                 response.success()\n             else:\n                 response.failure(f\"Analytics failed: {response.status_code}\")\n \n \n class HighVolumeUser(HttpUser):\n     \"\"\"High-volume user for stress testing\"\"\"\n-    \n+\n     wait_time = between(0.1, 0.5)  # Very frequent requests\n     weight = 2  # More frequent than admin, less than regular user\n-    \n+\n     def on_start(self):\n         \"\"\"Setup high-volume session\"\"\"\n         self.headers = {\n             \"Authorization\": \"Bearer highvolume.jwt.token.for.load.testing\",\n-            \"Content-Type\": \"application/json\"\n+            \"Content-Type\": \"application/json\",\n         }\n         self.batch_size = random.randint(5, 20)\n-    \n+\n     @task(15)\n     def batch_email_notifications(self):\n         \"\"\"Send batch of email notifications\"\"\"\n         for i in range(self.batch_size):\n             notification_data = {\n                 \"type\": \"email\",\n                 \"to\": f\"batch{i}@loadtest.com\",\n                 \"subject\": f\"Batch Email {i}\",\n                 \"message\": f\"High volume batch notification {i}\",\n-                \"priority\": \"normal\"\n+                \"priority\": \"normal\",\n             }\n-            \n-            with self.client.post(\"/api/v1/notifications\",\n-                                  json=notification_data,\n-                                  headers=self.headers,\n-                                  catch_response=True) as response:\n+\n+            with self.client.post(\n+                \"/api/v1/notifications\",\n+                json=notification_data,\n+                headers=self.headers,\n+                catch_response=True,\n+            ) as response:\n                 if response.status_code != 200:\n                     response.failure(f\"Batch email {i} failed: {response.status_code}\")\n                     break  # Stop batch on first failure\n         else:\n             # All requests in batch succeeded\n             response.success()\n-    \n+\n     @task(5)\n     def rapid_status_checks(self):\n         \"\"\"Rapid notification status checks\"\"\"\n         for i in range(5):\n             notification_id = f\"rapid_status_{random.randint(1, 100)}\"\n-            \n-            with self.client.get(f\"/api/v1/notifications/{notification_id}/status\",\n-                                 headers=self.headers,\n-                                 catch_response=True) as response:\n+\n+            with self.client.get(\n+                f\"/api/v1/notifications/{notification_id}/status\",\n+                headers=self.headers,\n+                catch_response=True,\n+            ) as response:\n                 if response.status_code not in [200, 404]:\n-                    response.failure(f\"Rapid status check {i} failed: {response.status_code}\")\n+                    response.failure(\n+                        f\"Rapid status check {i} failed: {response.status_code}\"\n+                    )\n                     break\n         else:\n             response.success()\n \n \n # Custom load testing scenarios\n class LoadTestScenarios:\n     \"\"\"Custom load testing scenarios for specific testing needs\"\"\"\n-    \n+\n     @staticmethod\n     def spike_test():\n         \"\"\"Spike test configuration - sudden load increase\"\"\"\n         # Use with: locust -f locustfile.py --users 200 --spawn-rate 50\n         pass\n-    \n+\n     @staticmethod\n     def stress_test():\n         \"\"\"Stress test configuration - sustained high load\"\"\"\n         # Use with: locust -f locustfile.py --users 500 --spawn-rate 10\n         pass\n-    \n+\n     @staticmethod\n     def volume_test():\n         \"\"\"Volume test configuration - large data processing\"\"\"\n         # Use with: locust -f locustfile.py --users 100 --spawn-rate 5 -t 30m\n         pass\n@@ -317,8 +335,8 @@\n if __name__ == \"__main__\":\n     print(\"Communication Service Load Testing Configuration\")\n     print(\"Available test scenarios:\")\n     print(\"1. Regular load test: locust -f locustfile.py --users 50 --spawn-rate 5\")\n     print(\"2. Spike test: locust -f locustfile.py --users 200 --spawn-rate 50\")\n-    print(\"3. Stress test: locust -f locustfile.py --users 500 --spawn-rate 10\") \n+    print(\"3. Stress test: locust -f locustfile.py --users 500 --spawn-rate 10\")\n     print(\"4. Volume test: locust -f locustfile.py --users 100 --spawn-rate 5 -t 30m\")\n-    print(\"\\nMake sure the Communication Service is running on port 8002\")\n\\ No newline at end of file\n+    print(\"\\nMake sure the Communication Service is running on port 8002\")\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/fixtures/mock_responses.py\t2025-09-09 18:13:02.196353+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/fixtures/mock_responses.py\t2025-09-10 11:37:02.272708+00:00\n@@ -5,13 +5,14 @@\n \n import uuid\n from datetime import datetime, timedelta\n from typing import Dict, Any, List\n \n+\n class IdentityServiceMocks:\n     \"\"\"Mock responses for Identity Service API calls\"\"\"\n-    \n+\n     @staticmethod\n     def get_successful_token_validation() -> Dict[str, Any]:\n         \"\"\"Mock successful JWT token validation response\"\"\"\n         return {\n             \"status_code\": 200,\n@@ -22,14 +23,14 @@\n                 \"name\": \"Test User\",\n                 \"roles\": [\"user\"],\n                 \"permissions\": [\"notification:read\", \"notification:write\"],\n                 \"is_active\": True,\n                 \"is_verified\": True,\n-                \"expires_at\": (datetime.utcnow() + timedelta(hours=1)).isoformat()\n-            }\n-        }\n-    \n+                \"expires_at\": (datetime.utcnow() + timedelta(hours=1)).isoformat(),\n+            },\n+        }\n+\n     @staticmethod\n     def get_admin_token_validation() -> Dict[str, Any]:\n         \"\"\"Mock successful admin token validation response\"\"\"\n         return {\n             \"status_code\": 200,\n@@ -38,57 +39,60 @@\n                 \"organization_id\": \"org-admin-987-654\",\n                 \"email\": \"admin@example.com\",\n                 \"name\": \"Admin User\",\n                 \"roles\": [\"admin\", \"user\"],\n                 \"permissions\": [\n-                    \"notification:read\", \"notification:write\", \"notification:delete\", \n-                    \"notification:admin\", \"admin\"\n+                    \"notification:read\",\n+                    \"notification:write\",\n+                    \"notification:delete\",\n+                    \"notification:admin\",\n+                    \"admin\",\n                 ],\n                 \"is_active\": True,\n                 \"is_verified\": True,\n-                \"expires_at\": (datetime.utcnow() + timedelta(hours=2)).isoformat()\n-            }\n-        }\n-    \n+                \"expires_at\": (datetime.utcnow() + timedelta(hours=2)).isoformat(),\n+            },\n+        }\n+\n     @staticmethod\n     def get_invalid_token_response() -> Dict[str, Any]:\n         \"\"\"Mock invalid token response\"\"\"\n         return {\n             \"status_code\": 401,\n             \"json\": {\n                 \"detail\": \"Invalid or expired token\",\n                 \"error\": \"authentication_failed\",\n-                \"code\": \"INVALID_TOKEN\"\n-            }\n-        }\n-    \n+                \"code\": \"INVALID_TOKEN\",\n+            },\n+        }\n+\n     @staticmethod\n     def get_expired_token_response() -> Dict[str, Any]:\n         \"\"\"Mock expired token response\"\"\"\n         return {\n             \"status_code\": 401,\n             \"json\": {\n                 \"detail\": \"Token has expired\",\n                 \"error\": \"token_expired\",\n                 \"code\": \"TOKEN_EXPIRED\",\n-                \"expired_at\": (datetime.utcnow() - timedelta(minutes=30)).isoformat()\n-            }\n-        }\n-    \n+                \"expired_at\": (datetime.utcnow() - timedelta(minutes=30)).isoformat(),\n+            },\n+        }\n+\n     @staticmethod\n     def get_insufficient_permissions_response() -> Dict[str, Any]:\n         \"\"\"Mock insufficient permissions response\"\"\"\n         return {\n             \"status_code\": 403,\n             \"json\": {\n                 \"detail\": \"Insufficient permissions for this operation\",\n                 \"error\": \"forbidden\",\n                 \"code\": \"INSUFFICIENT_PERMISSIONS\",\n-                \"required_permissions\": [\"notification:admin\"]\n-            }\n-        }\n-    \n+                \"required_permissions\": [\"notification:admin\"],\n+            },\n+        }\n+\n     @staticmethod\n     def get_user_profile_response() -> Dict[str, Any]:\n         \"\"\"Mock user profile response\"\"\"\n         return {\n             \"status_code\": 200,\n@@ -101,22 +105,22 @@\n                 \"language\": \"en\",\n                 \"phone\": \"+1234567890\",\n                 \"organization\": {\n                     \"id\": \"87654321-4321-8765-2109-876543210987\",\n                     \"name\": \"Test Organization\",\n-                    \"domain\": \"test.example.com\"\n+                    \"domain\": \"test.example.com\",\n                 },\n                 \"preferences\": {\n                     \"email_notifications\": True,\n                     \"sms_notifications\": True,\n-                    \"push_notifications\": True\n+                    \"push_notifications\": True,\n                 },\n                 \"created_at\": \"2024-01-01T00:00:00Z\",\n-                \"last_login\": datetime.utcnow().isoformat()\n-            }\n-        }\n-    \n+                \"last_login\": datetime.utcnow().isoformat(),\n+            },\n+        }\n+\n     @staticmethod\n     def get_user_contact_info_response() -> Dict[str, Any]:\n         \"\"\"Mock user contact information response\"\"\"\n         return {\n             \"status_code\": 200,\n@@ -128,175 +132,174 @@\n                     {\n                         \"token\": \"push-token-123456\",\n                         \"platform\": \"ios\",\n                         \"device_id\": \"device-ios-123\",\n                         \"created_at\": \"2024-01-01T00:00:00Z\",\n-                        \"is_active\": True\n+                        \"is_active\": True,\n                     },\n                     {\n                         \"token\": \"push-token-789012\",\n                         \"platform\": \"android\",\n                         \"device_id\": \"device-android-456\",\n                         \"created_at\": \"2024-01-02T00:00:00Z\",\n-                        \"is_active\": True\n-                    }\n+                        \"is_active\": True,\n+                    },\n                 ],\n                 \"notification_preferences\": {\n                     \"email\": {\n                         \"enabled\": True,\n-                        \"categories\": [\"system\", \"marketing\", \"security\"]\n+                        \"categories\": [\"system\", \"marketing\", \"security\"],\n                     },\n-                    \"sms\": {\n-                        \"enabled\": True,\n-                        \"categories\": [\"security\", \"urgent\"]\n-                    },\n+                    \"sms\": {\"enabled\": True, \"categories\": [\"security\", \"urgent\"]},\n                     \"push\": {\n                         \"enabled\": True,\n-                        \"categories\": [\"system\", \"messages\", \"updates\"]\n-                    }\n-                }\n-            }\n-        }\n-    \n+                        \"categories\": [\"system\", \"messages\", \"updates\"],\n+                    },\n+                },\n+            },\n+        }\n+\n     @staticmethod\n     def get_service_unavailable_response() -> Dict[str, Any]:\n         \"\"\"Mock service unavailable response\"\"\"\n         return {\n             \"status_code\": 503,\n             \"json\": {\n                 \"detail\": \"Identity service is temporarily unavailable\",\n                 \"error\": \"service_unavailable\",\n                 \"code\": \"SERVICE_UNAVAILABLE\",\n-                \"retry_after\": 30\n-            }\n-        }\n-    \n+                \"retry_after\": 30,\n+            },\n+        }\n+\n     @staticmethod\n     def get_timeout_error() -> Exception:\n         \"\"\"Mock timeout exception\"\"\"\n         import httpx\n+\n         return httpx.TimeoutException(\"Request timed out\")\n-    \n+\n     @staticmethod\n     def get_connection_error() -> Exception:\n         \"\"\"Mock connection error\"\"\"\n         import httpx\n+\n         return httpx.ConnectError(\"Connection refused\")\n \n \n class EmailProviderMocks:\n     \"\"\"Mock responses for email notification providers\"\"\"\n-    \n+\n     @staticmethod\n     def get_successful_send_response() -> Dict[str, Any]:\n         \"\"\"Mock successful email send response\"\"\"\n         return {\n             \"status\": \"sent\",\n             \"message_id\": f\"email-{uuid.uuid4()}\",\n             \"provider\": \"smtp\",\n             \"recipient\": \"test@example.com\",\n             \"sent_at\": datetime.utcnow().isoformat(),\n-            \"tracking_url\": \"https://provider.com/track/email-123456\"\n-        }\n-    \n+            \"tracking_url\": \"https://provider.com/track/email-123456\",\n+        }\n+\n     @staticmethod\n     def get_delivery_confirmation() -> Dict[str, Any]:\n         \"\"\"Mock email delivery confirmation\"\"\"\n         return {\n             \"event\": \"delivered\",\n             \"message_id\": f\"email-{uuid.uuid4()}\",\n             \"recipient\": \"test@example.com\",\n             \"delivered_at\": datetime.utcnow().isoformat(),\n-            \"provider_response\": \"250 Message delivered successfully\"\n-        }\n-    \n+            \"provider_response\": \"250 Message delivered successfully\",\n+        }\n+\n     @staticmethod\n     def get_bounce_notification() -> Dict[str, Any]:\n         \"\"\"Mock email bounce notification\"\"\"\n         return {\n             \"event\": \"bounced\",\n             \"message_id\": f\"email-{uuid.uuid4()}\",\n             \"recipient\": \"invalid@example.com\",\n             \"bounced_at\": datetime.utcnow().isoformat(),\n             \"bounce_type\": \"permanent\",\n             \"reason\": \"User mailbox does not exist\",\n-            \"provider_code\": \"550\"\n-        }\n-    \n+            \"provider_code\": \"550\",\n+        }\n+\n     @staticmethod\n     def get_rate_limit_error() -> Dict[str, Any]:\n         \"\"\"Mock email provider rate limit error\"\"\"\n         return {\n             \"error\": \"rate_limited\",\n             \"message\": \"Daily sending quota exceeded\",\n             \"retry_after\": 3600,\n-            \"quota_reset\": (datetime.utcnow() + timedelta(hours=1)).isoformat()\n-        }\n-    \n+            \"quota_reset\": (datetime.utcnow() + timedelta(hours=1)).isoformat(),\n+        }\n+\n     @staticmethod\n     def get_smtp_authentication_error() -> Dict[str, Any]:\n         \"\"\"Mock SMTP authentication error\"\"\"\n         return {\n             \"error\": \"authentication_failed\",\n             \"message\": \"Invalid SMTP credentials\",\n             \"provider_code\": \"535\",\n-            \"provider_message\": \"Authentication credentials invalid\"\n+            \"provider_message\": \"Authentication credentials invalid\",\n         }\n \n \n class SMSProviderMocks:\n     \"\"\"Mock responses for SMS notification providers\"\"\"\n-    \n+\n     @staticmethod\n     def get_successful_send_response() -> Dict[str, Any]:\n         \"\"\"Mock successful SMS send response\"\"\"\n         return {\n             \"status\": \"sent\",\n             \"message_id\": f\"sms-{uuid.uuid4()}\",\n             \"provider\": \"twilio\",\n             \"recipient\": \"+1234567890\",\n             \"sent_at\": datetime.utcnow().isoformat(),\n             \"cost\": 0.0075,\n-            \"segments\": 1\n-        }\n-    \n+            \"segments\": 1,\n+        }\n+\n     @staticmethod\n     def get_delivery_confirmation() -> Dict[str, Any]:\n         \"\"\"Mock SMS delivery confirmation\"\"\"\n         return {\n             \"event\": \"delivered\",\n             \"message_id\": f\"sms-{uuid.uuid4()}\",\n             \"recipient\": \"+1234567890\",\n             \"delivered_at\": datetime.utcnow().isoformat(),\n-            \"provider_status\": \"delivered\"\n-        }\n-    \n+            \"provider_status\": \"delivered\",\n+        }\n+\n     @staticmethod\n     def get_invalid_phone_error() -> Dict[str, Any]:\n         \"\"\"Mock invalid phone number error\"\"\"\n         return {\n             \"error\": \"invalid_phone_number\",\n             \"message\": \"Phone number is not valid\",\n             \"recipient\": \"+invalid123\",\n             \"provider_code\": \"21614\",\n-            \"provider_message\": \"Phone number is not a valid mobile number\"\n-        }\n-    \n+            \"provider_message\": \"Phone number is not a valid mobile number\",\n+        }\n+\n     @staticmethod\n     def get_unsubscribed_error() -> Dict[str, Any]:\n         \"\"\"Mock unsubscribed recipient error\"\"\"\n         return {\n             \"error\": \"recipient_unsubscribed\",\n             \"message\": \"Recipient has opted out of SMS messages\",\n             \"recipient\": \"+1234567890\",\n-            \"unsubscribed_at\": \"2024-01-10T15:30:00Z\"\n+            \"unsubscribed_at\": \"2024-01-10T15:30:00Z\",\n         }\n \n \n class PushProviderMocks:\n     \"\"\"Mock responses for push notification providers\"\"\"\n-    \n+\n     @staticmethod\n     def get_successful_send_response() -> Dict[str, Any]:\n         \"\"\"Mock successful push notification send response\"\"\"\n         return {\n             \"status\": \"sent\",\n@@ -304,49 +307,49 @@\n             \"provider\": \"fcm\",\n             \"recipient\": \"push-token-123456\",\n             \"sent_at\": datetime.utcnow().isoformat(),\n             \"multicast_id\": 123456789,\n             \"success\": 1,\n-            \"failure\": 0\n-        }\n-    \n+            \"failure\": 0,\n+        }\n+\n     @staticmethod\n     def get_invalid_token_error() -> Dict[str, Any]:\n         \"\"\"Mock invalid push token error\"\"\"\n         return {\n             \"error\": \"invalid_registration\",\n             \"message\": \"Push token is no longer valid\",\n             \"token\": \"invalid-push-token\",\n             \"provider_error\": \"NotRegistered\",\n-            \"should_remove_token\": True\n-        }\n-    \n+            \"should_remove_token\": True,\n+        }\n+\n     @staticmethod\n     def get_device_unregistered_error() -> Dict[str, Any]:\n         \"\"\"Mock device unregistered error\"\"\"\n         return {\n             \"error\": \"device_unregistered\",\n             \"message\": \"Device is no longer registered for push notifications\",\n             \"token\": \"push-token-123456\",\n             \"provider_error\": \"Unregistered\",\n-            \"should_remove_token\": True\n-        }\n-    \n+            \"should_remove_token\": True,\n+        }\n+\n     @staticmethod\n     def get_quota_exceeded_error() -> Dict[str, Any]:\n         \"\"\"Mock quota exceeded error\"\"\"\n         return {\n             \"error\": \"quota_exceeded\",\n             \"message\": \"Push notification quota exceeded\",\n             \"retry_after\": 3600,\n-            \"quota_reset\": (datetime.utcnow() + timedelta(hours=1)).isoformat()\n+            \"quota_reset\": (datetime.utcnow() + timedelta(hours=1)).isoformat(),\n         }\n \n \n class CeleryTaskMocks:\n     \"\"\"Mock responses for Celery task operations\"\"\"\n-    \n+\n     @staticmethod\n     def get_successful_task_result() -> Dict[str, Any]:\n         \"\"\"Mock successful Celery task result\"\"\"\n         return {\n             \"task_id\": f\"task-{uuid.uuid4()}\",\n@@ -354,29 +357,29 @@\n             \"result\": {\n                 \"notification_id\": str(uuid.uuid4()),\n                 \"status\": \"sent\",\n                 \"message_id\": f\"msg-{uuid.uuid4()}\",\n                 \"provider\": \"smtp\",\n-                \"sent_at\": datetime.utcnow().isoformat()\n+                \"sent_at\": datetime.utcnow().isoformat(),\n             },\n             \"started_at\": (datetime.utcnow() - timedelta(seconds=30)).isoformat(),\n             \"completed_at\": datetime.utcnow().isoformat(),\n-            \"worker\": \"worker@localhost.1\"\n-        }\n-    \n+            \"worker\": \"worker@localhost.1\",\n+        }\n+\n     @staticmethod\n     def get_pending_task_result() -> Dict[str, Any]:\n         \"\"\"Mock pending Celery task result\"\"\"\n         return {\n             \"task_id\": f\"task-{uuid.uuid4()}\",\n             \"status\": \"PENDING\",\n             \"result\": None,\n             \"queued_at\": datetime.utcnow().isoformat(),\n             \"queue\": \"notifications_normal\",\n-            \"retries\": 0\n-        }\n-    \n+            \"retries\": 0,\n+        }\n+\n     @staticmethod\n     def get_failed_task_result() -> Dict[str, Any]:\n         \"\"\"Mock failed Celery task result\"\"\"\n         return {\n             \"task_id\": f\"task-{uuid.uuid4()}\",\n@@ -384,18 +387,18 @@\n             \"result\": {\n                 \"error\": \"SMTP connection failed\",\n                 \"error_type\": \"ConnectionError\",\n                 \"retry_count\": 2,\n                 \"max_retries\": 3,\n-                \"next_retry\": (datetime.utcnow() + timedelta(minutes=5)).isoformat()\n+                \"next_retry\": (datetime.utcnow() + timedelta(minutes=5)).isoformat(),\n             },\n             \"started_at\": (datetime.utcnow() - timedelta(minutes=2)).isoformat(),\n             \"failed_at\": datetime.utcnow().isoformat(),\n             \"worker\": \"worker@localhost.1\",\n-            \"traceback\": \"Traceback (most recent call last):\\n  File ...\\nConnectionError: SMTP connection failed\"\n-        }\n-    \n+            \"traceback\": \"Traceback (most recent call last):\\n  File ...\\nConnectionError: SMTP connection failed\",\n+        }\n+\n     @staticmethod\n     def get_retry_task_result() -> Dict[str, Any]:\n         \"\"\"Mock retry Celery task result\"\"\"\n         return {\n             \"task_id\": f\"task-{uuid.uuid4()}\",\n@@ -403,17 +406,17 @@\n             \"result\": {\n                 \"error\": \"Temporary network error\",\n                 \"retry_count\": 1,\n                 \"max_retries\": 3,\n                 \"next_retry\": (datetime.utcnow() + timedelta(minutes=2)).isoformat(),\n-                \"backoff\": 120\n+                \"backoff\": 120,\n             },\n             \"started_at\": (datetime.utcnow() - timedelta(minutes=1)).isoformat(),\n             \"retried_at\": datetime.utcnow().isoformat(),\n-            \"worker\": \"worker@localhost.1\"\n-        }\n-    \n+            \"worker\": \"worker@localhost.1\",\n+        }\n+\n     @staticmethod\n     def get_task_progress() -> Dict[str, Any]:\n         \"\"\"Mock Celery task progress\"\"\"\n         return {\n             \"task_id\": f\"task-{uuid.uuid4()}\",\n@@ -424,79 +427,63 @@\n                 \"progress\": 50,\n                 \"details\": {\n                     \"template_rendered\": True,\n                     \"recipient_validated\": True,\n                     \"provider_selected\": True,\n-                    \"sending\": False\n-                }\n+                    \"sending\": False,\n+                },\n             },\n             \"started_at\": (datetime.utcnow() - timedelta(seconds=10)).isoformat(),\n-            \"worker\": \"worker@localhost.1\"\n+            \"worker\": \"worker@localhost.1\",\n         }\n \n \n class RedisQueueMocks:\n     \"\"\"Mock responses for Redis queue operations\"\"\"\n-    \n+\n     @staticmethod\n     def get_queue_status() -> Dict[str, Any]:\n         \"\"\"Mock Redis queue status\"\"\"\n         return {\n             \"queues\": {\n-                \"notifications_urgent\": {\n-                    \"pending\": 2,\n-                    \"processing\": 1,\n-                    \"length\": 3\n-                },\n-                \"notifications_high\": {\n-                    \"pending\": 8,\n-                    \"processing\": 2,\n-                    \"length\": 10\n-                },\n-                \"notifications_normal\": {\n-                    \"pending\": 45,\n-                    \"processing\": 5,\n-                    \"length\": 50\n-                },\n-                \"notifications_low\": {\n-                    \"pending\": 12,\n-                    \"processing\": 1,\n-                    \"length\": 13\n-                }\n+                \"notifications_urgent\": {\"pending\": 2, \"processing\": 1, \"length\": 3},\n+                \"notifications_high\": {\"pending\": 8, \"processing\": 2, \"length\": 10},\n+                \"notifications_normal\": {\"pending\": 45, \"processing\": 5, \"length\": 50},\n+                \"notifications_low\": {\"pending\": 12, \"processing\": 1, \"length\": 13},\n             },\n             \"total_pending\": 67,\n             \"total_processing\": 9,\n             \"workers_active\": 6,\n-            \"last_updated\": datetime.utcnow().isoformat()\n-        }\n-    \n+            \"last_updated\": datetime.utcnow().isoformat(),\n+        }\n+\n     @staticmethod\n     def get_queue_peek() -> List[Dict[str, Any]]:\n         \"\"\"Mock queue peek operation\"\"\"\n         return [\n             {\n                 \"notification_id\": str(uuid.uuid4()),\n                 \"priority\": \"high\",\n                 \"channel\": \"email\",\n                 \"recipient\": \"user@example.com\",\n                 \"queued_at\": datetime.utcnow().isoformat(),\n-                \"attempts\": 0\n+                \"attempts\": 0,\n             },\n             {\n                 \"notification_id\": str(uuid.uuid4()),\n                 \"priority\": \"normal\",\n                 \"channel\": \"sms\",\n                 \"recipient\": \"+1234567890\",\n                 \"queued_at\": (datetime.utcnow() - timedelta(minutes=2)).isoformat(),\n-                \"attempts\": 1\n-            }\n+                \"attempts\": 1,\n+            },\n         ]\n \n \n class WebhookMocks:\n     \"\"\"Mock webhook responses from notification providers\"\"\"\n-    \n+\n     @staticmethod\n     def get_email_delivered_webhook() -> Dict[str, Any]:\n         \"\"\"Mock email delivered webhook\"\"\"\n         return {\n             \"event\": \"delivered\",\n@@ -506,14 +493,14 @@\n             \"provider\": \"sendgrid\",\n             \"smtp_response\": \"250 2.0.0 OK\",\n             \"category\": [\"notification\", \"transactional\"],\n             \"unique_args\": {\n                 \"notification_id\": str(uuid.uuid4()),\n-                \"user_id\": \"12345678-1234-5678-9012-123456789012\"\n-            }\n-        }\n-    \n+                \"user_id\": \"12345678-1234-5678-9012-123456789012\",\n+            },\n+        }\n+\n     @staticmethod\n     def get_email_bounced_webhook() -> Dict[str, Any]:\n         \"\"\"Mock email bounced webhook\"\"\"\n         return {\n             \"event\": \"bounced\",\n@@ -524,14 +511,14 @@\n             \"reason\": \"550 5.1.1 User unknown\",\n             \"type\": \"bounce\",\n             \"bounce_classification\": \"hard_bounce\",\n             \"unique_args\": {\n                 \"notification_id\": str(uuid.uuid4()),\n-                \"user_id\": \"12345678-1234-5678-9012-123456789012\"\n-            }\n-        }\n-    \n+                \"user_id\": \"12345678-1234-5678-9012-123456789012\",\n+            },\n+        }\n+\n     @staticmethod\n     def get_sms_delivered_webhook() -> Dict[str, Any]:\n         \"\"\"Mock SMS delivered webhook\"\"\"\n         return {\n             \"MessageSid\": f\"sms-{uuid.uuid4()}\",\n@@ -539,25 +526,25 @@\n             \"To\": \"+1234567890\",\n             \"From\": \"+1987654321\",\n             \"AccountSid\": \"ACxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",\n             \"ApiVersion\": \"2010-04-01\",\n             \"EventType\": \"message-delivered\",\n-            \"Timestamp\": datetime.utcnow().isoformat()\n-        }\n-    \n+            \"Timestamp\": datetime.utcnow().isoformat(),\n+        }\n+\n     @staticmethod\n     def get_push_feedback_webhook() -> Dict[str, Any]:\n         \"\"\"Mock push notification feedback webhook\"\"\"\n         return {\n             \"results\": [\n                 {\n                     \"message_id\": f\"push-{uuid.uuid4()}\",\n                     \"registration_id\": \"push-token-123456\",\n-                    \"error\": None\n+                    \"error\": None,\n                 }\n             ],\n             \"canonical_ids\": 0,\n             \"failure\": 0,\n             \"success\": 1,\n             \"multicast_id\": 123456789012345,\n-            \"timestamp\": datetime.utcnow().isoformat()\n-        }\n\\ No newline at end of file\n+            \"timestamp\": datetime.utcnow().isoformat(),\n+        }\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/fixtures/sample_data.py\t2025-09-09 18:11:51.345939+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/fixtures/sample_data.py\t2025-09-10 11:37:02.291243+00:00\n@@ -5,13 +5,14 @@\n \n import uuid\n from datetime import datetime, timedelta\n from typing import Dict, List, Any\n \n+\n class SampleNotificationData:\n     \"\"\"Sample notification data for testing\"\"\"\n-    \n+\n     @staticmethod\n     def get_user_data() -> Dict[str, Any]:\n         \"\"\"Get sample user data\"\"\"\n         return {\n             \"user_id\": \"12345678-1234-5678-9012-123456789012\",\n@@ -21,42 +22,47 @@\n             \"phone\": \"+1234567890\",\n             \"roles\": [\"user\"],\n             \"permissions\": [\"notification:read\", \"notification:write\"],\n             \"is_active\": True,\n             \"created_at\": datetime.utcnow().isoformat(),\n-            \"expires_at\": (datetime.utcnow() + timedelta(hours=1)).isoformat()\n-        }\n-    \n+            \"expires_at\": (datetime.utcnow() + timedelta(hours=1)).isoformat(),\n+        }\n+\n     @staticmethod\n     def get_admin_user_data() -> Dict[str, Any]:\n         \"\"\"Get sample admin user data\"\"\"\n         return {\n             \"user_id\": \"admin-123-456-789\",\n             \"organization_id\": \"org-admin-987-654\",\n             \"email\": \"admin@example.com\",\n             \"name\": \"Admin User\",\n             \"phone\": \"+1987654321\",\n             \"roles\": [\"admin\", \"user\"],\n-            \"permissions\": [\"notification:read\", \"notification:write\", \"notification:delete\", \"admin\"],\n+            \"permissions\": [\n+                \"notification:read\",\n+                \"notification:write\",\n+                \"notification:delete\",\n+                \"admin\",\n+            ],\n             \"is_active\": True,\n             \"created_at\": datetime.utcnow().isoformat(),\n-            \"expires_at\": (datetime.utcnow() + timedelta(hours=2)).isoformat()\n-        }\n-    \n+            \"expires_at\": (datetime.utcnow() + timedelta(hours=2)).isoformat(),\n+        }\n+\n     @staticmethod\n     def get_notification_category() -> Dict[str, Any]:\n         \"\"\"Get sample notification category\"\"\"\n         return {\n             \"id\": str(uuid.uuid4()),\n             \"name\": \"system\",\n             \"description\": \"System notifications for important updates\",\n             \"default_enabled\": True,\n             \"color\": \"#007bff\",\n             \"created_at\": datetime.utcnow(),\n-            \"updated_at\": datetime.utcnow()\n-        }\n-    \n+            \"updated_at\": datetime.utcnow(),\n+        }\n+\n     @staticmethod\n     def get_notification_template_email() -> Dict[str, Any]:\n         \"\"\"Get sample email notification template\"\"\"\n         return {\n             \"id\": str(uuid.uuid4()),\n@@ -85,19 +91,19 @@\n             Best regards,\n             The {{platform_name}} Team\n             \"\"\",\n             \"variables\": {\n                 \"user_name\": \"string\",\n-                \"user_email\": \"string\", \n+                \"user_email\": \"string\",\n                 \"platform_name\": \"string\",\n                 \"created_date\": \"string\",\n-                \"organization_name\": \"string\"\n-            },\n-            \"created_at\": datetime.utcnow(),\n-            \"updated_at\": datetime.utcnow()\n-        }\n-    \n+                \"organization_name\": \"string\",\n+            },\n+            \"created_at\": datetime.utcnow(),\n+            \"updated_at\": datetime.utcnow(),\n+        }\n+\n     @staticmethod\n     def get_notification_template_sms() -> Dict[str, Any]:\n         \"\"\"Get sample SMS notification template\"\"\"\n         return {\n             \"id\": str(uuid.uuid4()),\n@@ -105,18 +111,15 @@\n             \"category_id\": str(uuid.uuid4()),\n             \"channel\": \"sms\",\n             \"language\": \"en\",\n             \"subject\": \"Verification Code\",\n             \"content\": \"Your verification code is: {{verification_code}}. Valid for {{expiry_minutes}} minutes. Do not share this code.\",\n-            \"variables\": {\n-                \"verification_code\": \"string\",\n-                \"expiry_minutes\": \"integer\"\n-            },\n-            \"created_at\": datetime.utcnow(),\n-            \"updated_at\": datetime.utcnow()\n-        }\n-    \n+            \"variables\": {\"verification_code\": \"string\", \"expiry_minutes\": \"integer\"},\n+            \"created_at\": datetime.utcnow(),\n+            \"updated_at\": datetime.utcnow(),\n+        }\n+\n     @staticmethod\n     def get_notification_template_push() -> Dict[str, Any]:\n         \"\"\"Get sample push notification template\"\"\"\n         return {\n             \"id\": str(uuid.uuid4()),\n@@ -127,16 +130,16 @@\n             \"subject\": \"New message from {{sender_name}}\",\n             \"content\": \"{{message_preview}}\",\n             \"variables\": {\n                 \"sender_name\": \"string\",\n                 \"message_preview\": \"string\",\n-                \"deep_link\": \"string\"\n-            },\n-            \"created_at\": datetime.utcnow(),\n-            \"updated_at\": datetime.utcnow()\n-        }\n-    \n+                \"deep_link\": \"string\",\n+            },\n+            \"created_at\": datetime.utcnow(),\n+            \"updated_at\": datetime.utcnow(),\n+        }\n+\n     @staticmethod\n     def get_notification_email() -> Dict[str, Any]:\n         \"\"\"Get sample email notification\"\"\"\n         return {\n             \"id\": str(uuid.uuid4()),\n@@ -152,18 +155,18 @@\n             \"data\": {\n                 \"user_name\": \"John\",\n                 \"user_email\": \"john@example.com\",\n                 \"platform_name\": \"Our Platform\",\n                 \"created_date\": \"2024-01-15\",\n-                \"organization_name\": \"Test Organization\"\n+                \"organization_name\": \"Test Organization\",\n             },\n             \"created_at\": datetime.utcnow(),\n             \"sent_at\": None,\n             \"external_message_id\": None,\n-            \"error_message\": None\n-        }\n-    \n+            \"error_message\": None,\n+        }\n+\n     @staticmethod\n     def get_notification_sms() -> Dict[str, Any]:\n         \"\"\"Get sample SMS notification\"\"\"\n         return {\n             \"id\": str(uuid.uuid4()),\n@@ -174,20 +177,17 @@\n             \"subject\": \"Verification Code\",\n             \"content\": \"Your verification code is: 123456. Valid for 10 minutes. Do not share this code.\",\n             \"recipient\": \"+1234567890\",\n             \"priority\": \"high\",\n             \"status\": \"pending\",\n-            \"data\": {\n-                \"verification_code\": \"123456\",\n-                \"expiry_minutes\": 10\n-            },\n+            \"data\": {\"verification_code\": \"123456\", \"expiry_minutes\": 10},\n             \"created_at\": datetime.utcnow(),\n             \"sent_at\": None,\n             \"external_message_id\": None,\n-            \"error_message\": None\n-        }\n-    \n+            \"error_message\": None,\n+        }\n+\n     @staticmethod\n     def get_notification_push() -> Dict[str, Any]:\n         \"\"\"Get sample push notification\"\"\"\n         return {\n             \"id\": str(uuid.uuid4()),\n@@ -201,18 +201,18 @@\n             \"priority\": \"normal\",\n             \"status\": \"pending\",\n             \"data\": {\n                 \"sender_name\": \"Alice\",\n                 \"message_preview\": \"Hey there! How are you doing?\",\n-                \"deep_link\": \"/messages/conversation/123\"\n+                \"deep_link\": \"/messages/conversation/123\",\n             },\n             \"created_at\": datetime.utcnow(),\n             \"sent_at\": None,\n             \"external_message_id\": None,\n-            \"error_message\": None\n-        }\n-    \n+            \"error_message\": None,\n+        }\n+\n     @staticmethod\n     def get_notification_in_app() -> Dict[str, Any]:\n         \"\"\"Get sample in-app notification\"\"\"\n         return {\n             \"id\": str(uuid.uuid4()),\n@@ -226,25 +226,25 @@\n             \"priority\": \"normal\",\n             \"status\": \"pending\",\n             \"data\": {\n                 \"maintenance_start\": \"2024-01-16T02:00:00Z\",\n                 \"expected_duration\": \"30 minutes\",\n-                \"affected_services\": [\"api\", \"web_app\"]\n+                \"affected_services\": [\"api\", \"web_app\"],\n             },\n             \"created_at\": datetime.utcnow(),\n             \"sent_at\": None,\n             \"external_message_id\": None,\n-            \"error_message\": None\n-        }\n-    \n+            \"error_message\": None,\n+        }\n+\n     @staticmethod\n     def get_multiple_notifications(count: int = 5) -> List[Dict[str, Any]]:\n         \"\"\"Get multiple sample notifications\"\"\"\n         notifications = []\n         channels = [\"email\", \"sms\", \"push\", \"in_app\"]\n         priorities = [\"low\", \"normal\", \"high\", \"urgent\"]\n-        \n+\n         for i in range(count):\n             notification = {\n                 \"id\": str(uuid.uuid4()),\n                 \"user_id\": \"12345678-1234-5678-9012-123456789012\",\n                 \"category_id\": str(uuid.uuid4()),\n@@ -253,54 +253,50 @@\n                 \"subject\": f\"Test Notification #{i+1}\",\n                 \"content\": f\"This is test notification number {i+1}\",\n                 \"recipient\": f\"recipient{i+1}@example.com\",\n                 \"priority\": priorities[i % len(priorities)],\n                 \"status\": \"pending\",\n-                \"data\": {\n-                    \"sequence_number\": i+1,\n-                    \"test_data\": f\"value_{i+1}\"\n-                },\n-                \"created_at\": datetime.utcnow() - timedelta(minutes=i*5),\n+                \"data\": {\"sequence_number\": i + 1, \"test_data\": f\"value_{i+1}\"},\n+                \"created_at\": datetime.utcnow() - timedelta(minutes=i * 5),\n                 \"sent_at\": None,\n                 \"external_message_id\": None,\n-                \"error_message\": None\n+                \"error_message\": None,\n             }\n             notifications.append(notification)\n-        \n+\n         return notifications\n \n \n class SampleAPIData:\n     \"\"\"Sample API request/response data for testing\"\"\"\n-    \n+\n     @staticmethod\n     def get_send_notification_request() -> Dict[str, Any]:\n         \"\"\"Get sample send notification API request\"\"\"\n         return {\n             \"type\": \"email\",\n             \"to\": \"user@example.com\",\n             \"subject\": \"Test Notification\",\n             \"message\": \"This is a test notification message\",\n             \"priority\": \"normal\",\n             \"template_id\": None,\n-            \"data\": {\n-                \"user_name\": \"Test User\",\n-                \"action\": \"test_action\"\n-            }\n-        }\n-    \n+            \"data\": {\"user_name\": \"Test User\", \"action\": \"test_action\"},\n+        }\n+\n     @staticmethod\n     def get_send_notification_response() -> Dict[str, Any]:\n         \"\"\"Get sample send notification API response\"\"\"\n         return {\n             \"notification_id\": str(uuid.uuid4()),\n             \"status\": \"queued\",\n             \"message\": \"Notification queued for delivery\",\n             \"task_id\": \"task-123-456-789\",\n-            \"estimated_delivery\": (datetime.utcnow() + timedelta(minutes=1)).isoformat()\n-        }\n-    \n+            \"estimated_delivery\": (\n+                datetime.utcnow() + timedelta(minutes=1)\n+            ).isoformat(),\n+        }\n+\n     @staticmethod\n     def get_notification_status_response() -> Dict[str, Any]:\n         \"\"\"Get sample notification status API response\"\"\"\n         return {\n             \"notification_id\": str(uuid.uuid4()),\n@@ -310,13 +306,13 @@\n             \"sent_at\": datetime.utcnow().isoformat(),\n             \"delivered_at\": None,\n             \"read_at\": None,\n             \"external_message_id\": \"msg-ext-123456\",\n             \"error_message\": None,\n-            \"retry_count\": 0\n-        }\n-    \n+            \"retry_count\": 0,\n+        }\n+\n     @staticmethod\n     def get_unread_notifications_response() -> Dict[str, Any]:\n         \"\"\"Get sample unread notifications API response\"\"\"\n         return {\n             \"unread_count\": 3,\n@@ -326,35 +322,37 @@\n                     \"subject\": \"Welcome to our platform!\",\n                     \"content\": \"Thank you for joining us...\",\n                     \"channel\": \"in_app\",\n                     \"created_at\": (datetime.utcnow() - timedelta(hours=2)).isoformat(),\n                     \"is_read\": False,\n-                    \"priority\": \"normal\"\n+                    \"priority\": \"normal\",\n                 },\n                 {\n                     \"id\": str(uuid.uuid4()),\n                     \"subject\": \"New message received\",\n                     \"content\": \"You have a new message from...\",\n                     \"channel\": \"in_app\",\n                     \"created_at\": (datetime.utcnow() - timedelta(hours=1)).isoformat(),\n                     \"is_read\": False,\n-                    \"priority\": \"high\"\n+                    \"priority\": \"high\",\n                 },\n                 {\n                     \"id\": str(uuid.uuid4()),\n                     \"subject\": \"System maintenance notice\",\n                     \"content\": \"Scheduled maintenance tonight...\",\n                     \"channel\": \"in_app\",\n-                    \"created_at\": (datetime.utcnow() - timedelta(minutes=30)).isoformat(),\n+                    \"created_at\": (\n+                        datetime.utcnow() - timedelta(minutes=30)\n+                    ).isoformat(),\n                     \"is_read\": False,\n-                    \"priority\": \"normal\"\n-                }\n+                    \"priority\": \"normal\",\n+                },\n             ],\n             \"has_more\": False,\n-            \"next_page\": None\n-        }\n-    \n+            \"next_page\": None,\n+        }\n+\n     @staticmethod\n     def get_template_create_request() -> Dict[str, Any]:\n         \"\"\"Get sample template creation request\"\"\"\n         return {\n             \"name\": \"user_welcome_email\",\n@@ -365,118 +363,98 @@\n             \"content\": \"Hello {{user_name}},\\n\\nWelcome to {{platform_name}}!\",\n             \"variables\": {\n                 \"user_name\": {\n                     \"type\": \"string\",\n                     \"required\": True,\n-                    \"description\": \"User's display name\"\n+                    \"description\": \"User's display name\",\n                 },\n                 \"platform_name\": {\n-                    \"type\": \"string\", \n+                    \"type\": \"string\",\n                     \"required\": True,\n-                    \"description\": \"Platform name\"\n-                }\n-            },\n-            \"is_active\": True\n-        }\n-    \n+                    \"description\": \"Platform name\",\n+                },\n+            },\n+            \"is_active\": True,\n+        }\n+\n     @staticmethod\n     def get_queue_status_response() -> Dict[str, Any]:\n         \"\"\"Get sample queue status API response\"\"\"\n         return {\n             \"total_pending\": 47,\n             \"queues\": {\n-                \"urgent\": {\n-                    \"pending\": 2,\n-                    \"processing\": 1,\n-                    \"failed\": 0\n-                },\n-                \"high\": {\n-                    \"pending\": 5,\n-                    \"processing\": 2,\n-                    \"failed\": 1\n-                },\n-                \"normal\": {\n-                    \"pending\": 35,\n-                    \"processing\": 3,\n-                    \"failed\": 2\n-                },\n-                \"low\": {\n-                    \"pending\": 5,\n-                    \"processing\": 0,\n-                    \"failed\": 1\n-                }\n+                \"urgent\": {\"pending\": 2, \"processing\": 1, \"failed\": 0},\n+                \"high\": {\"pending\": 5, \"processing\": 2, \"failed\": 1},\n+                \"normal\": {\"pending\": 35, \"processing\": 3, \"failed\": 2},\n+                \"low\": {\"pending\": 5, \"processing\": 0, \"failed\": 1},\n             },\n             \"workers\": {\n                 \"active\": 6,\n                 \"total\": 10,\n-                \"last_heartbeat\": datetime.utcnow().isoformat()\n-            },\n-            \"processing_rate\": {\n-                \"last_minute\": 12,\n-                \"last_hour\": 450,\n-                \"last_day\": 8500\n-            }\n+                \"last_heartbeat\": datetime.utcnow().isoformat(),\n+            },\n+            \"processing_rate\": {\"last_minute\": 12, \"last_hour\": 450, \"last_day\": 8500},\n         }\n \n \n class SampleErrorData:\n     \"\"\"Sample error data for testing error scenarios\"\"\"\n-    \n+\n     @staticmethod\n     def get_validation_error() -> Dict[str, Any]:\n         \"\"\"Get sample validation error\"\"\"\n         return {\n             \"error\": \"validation_error\",\n             \"message\": \"Invalid request data\",\n             \"details\": [\n                 {\n                     \"field\": \"email\",\n                     \"message\": \"Invalid email format\",\n-                    \"code\": \"INVALID_EMAIL\"\n+                    \"code\": \"INVALID_EMAIL\",\n                 },\n                 {\n                     \"field\": \"message\",\n                     \"message\": \"Message content is required\",\n-                    \"code\": \"REQUIRED_FIELD\"\n-                }\n-            ]\n-        }\n-    \n+                    \"code\": \"REQUIRED_FIELD\",\n+                },\n+            ],\n+        }\n+\n     @staticmethod\n     def get_authentication_error() -> Dict[str, Any]:\n         \"\"\"Get sample authentication error\"\"\"\n         return {\n             \"error\": \"authentication_error\",\n             \"message\": \"Invalid or expired token\",\n             \"code\": \"INVALID_TOKEN\",\n-            \"timestamp\": datetime.utcnow().isoformat()\n-        }\n-    \n+            \"timestamp\": datetime.utcnow().isoformat(),\n+        }\n+\n     @staticmethod\n     def get_rate_limit_error() -> Dict[str, Any]:\n         \"\"\"Get sample rate limit error\"\"\"\n         return {\n             \"error\": \"rate_limit_exceeded\",\n             \"message\": \"Too many requests. Please try again later.\",\n             \"code\": \"RATE_LIMIT_EXCEEDED\",\n             \"retry_after\": 60,\n             \"limit\": 100,\n             \"remaining\": 0,\n-            \"reset_time\": (datetime.utcnow() + timedelta(minutes=1)).isoformat()\n-        }\n-    \n+            \"reset_time\": (datetime.utcnow() + timedelta(minutes=1)).isoformat(),\n+        }\n+\n     @staticmethod\n     def get_service_unavailable_error() -> Dict[str, Any]:\n         \"\"\"Get sample service unavailable error\"\"\"\n         return {\n             \"error\": \"service_unavailable\",\n             \"message\": \"Identity service is temporarily unavailable\",\n             \"code\": \"SERVICE_UNAVAILABLE\",\n             \"retry_after\": 30,\n-            \"timestamp\": datetime.utcnow().isoformat()\n-        }\n-    \n+            \"timestamp\": datetime.utcnow().isoformat(),\n+        }\n+\n     @staticmethod\n     def get_notification_delivery_error() -> Dict[str, Any]:\n         \"\"\"Get sample notification delivery error\"\"\"\n         return {\n             \"error\": \"delivery_failed\",\n@@ -484,20 +462,20 @@\n             \"code\": \"DELIVERY_FAILED\",\n             \"details\": {\n                 \"provider\": \"smtp\",\n                 \"provider_code\": \"550\",\n                 \"provider_message\": \"User mailbox unavailable\",\n-                \"retry_possible\": False\n+                \"retry_possible\": False,\n             },\n             \"notification_id\": str(uuid.uuid4()),\n-            \"timestamp\": datetime.utcnow().isoformat()\n+            \"timestamp\": datetime.utcnow().isoformat(),\n         }\n \n \n class SampleProviderData:\n     \"\"\"Sample data for notification provider testing\"\"\"\n-    \n+\n     @staticmethod\n     def get_email_provider_config() -> Dict[str, Any]:\n         \"\"\"Get sample email provider configuration\"\"\"\n         return {\n             \"provider\": \"smtp\",\n@@ -505,53 +483,37 @@\n                 \"host\": \"smtp.example.com\",\n                 \"port\": 587,\n                 \"username\": \"notifications@example.com\",\n                 \"password\": \"secure_password\",\n                 \"use_tls\": True,\n-                \"timeout\": 30\n-            },\n-            \"rate_limits\": {\n-                \"per_second\": 10,\n-                \"per_minute\": 100,\n-                \"per_hour\": 1000\n-            },\n-            \"retry_config\": {\n-                \"max_attempts\": 3,\n-                \"base_delay\": 60,\n-                \"max_delay\": 3600\n-            }\n-        }\n-    \n+                \"timeout\": 30,\n+            },\n+            \"rate_limits\": {\"per_second\": 10, \"per_minute\": 100, \"per_hour\": 1000},\n+            \"retry_config\": {\"max_attempts\": 3, \"base_delay\": 60, \"max_delay\": 3600},\n+        }\n+\n     @staticmethod\n     def get_sms_provider_config() -> Dict[str, Any]:\n         \"\"\"Get sample SMS provider configuration\"\"\"\n         return {\n             \"provider\": \"twilio\",\n             \"settings\": {\n                 \"account_sid\": \"ACxxxxx\",\n                 \"auth_token\": \"secret_token\",\n                 \"from_number\": \"+1234567890\",\n-                \"webhook_url\": \"https://api.example.com/webhooks/sms\"\n-            },\n-            \"rate_limits\": {\n-                \"per_second\": 5,\n-                \"per_minute\": 50,\n-                \"per_hour\": 1000\n-            }\n-        }\n-    \n+                \"webhook_url\": \"https://api.example.com/webhooks/sms\",\n+            },\n+            \"rate_limits\": {\"per_second\": 5, \"per_minute\": 50, \"per_hour\": 1000},\n+        }\n+\n     @staticmethod\n     def get_push_provider_config() -> Dict[str, Any]:\n         \"\"\"Get sample push notification provider configuration\"\"\"\n         return {\n             \"provider\": \"fcm\",\n             \"settings\": {\n                 \"server_key\": \"firebase_server_key\",\n                 \"project_id\": \"firebase_project_id\",\n-                \"endpoint\": \"https://fcm.googleapis.com/fcm/send\"\n-            },\n-            \"rate_limits\": {\n-                \"per_second\": 20,\n-                \"per_minute\": 1000,\n-                \"per_hour\": 50000\n-            }\n-        }\n\\ No newline at end of file\n+                \"endpoint\": \"https://fcm.googleapis.com/fcm/send\",\n+            },\n+            \"rate_limits\": {\"per_second\": 20, \"per_minute\": 1000, \"per_hour\": 50000},\n+        }\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/e2e/test_user_workflows.py\t2025-09-09 18:44:05.535524+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/e2e/test_user_workflows.py\t2025-09-10 11:37:02.325739+00:00\n@@ -10,635 +10,706 @@\n from fastapi.testclient import TestClient\n \n from tests.fixtures.mock_responses import IdentityServiceMocks, EmailProviderMocks\n from tests.fixtures.sample_data import SampleNotificationData\n \n+\n @pytest.mark.e2e\n class TestCompleteNotificationWorkflow:\n     \"\"\"Test complete notification workflows from creation to delivery\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n-    def test_complete_email_notification_workflow(self, mock_identity, client: TestClient):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    def test_complete_email_notification_workflow(\n+        self, mock_identity, client: TestClient\n+    ):\n         \"\"\"Test complete email notification workflow\"\"\"\n         # Setup: Mock all external dependencies\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_response\n-        \n-        with patch('tasks.notification_tasks.send_notification') as mock_task, \\\n-             patch('providers.email.EmailProvider') as mock_email_provider:\n-            \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_response\n+\n+        with patch(\"tasks.notification_tasks.send_notification\") as mock_task, patch(\n+            \"providers.email.EmailProvider\"\n+        ) as mock_email_provider:\n+\n             # Setup mocks\n             mock_result = MagicMock()\n             mock_result.id = \"workflow-task-123\"\n             mock_task.apply_async.return_value = mock_result\n-            \n+\n             mock_email_instance = AsyncMock()\n-            mock_email_instance.send.return_value = EmailProviderMocks.get_successful_send_response()\n+            mock_email_instance.send.return_value = (\n+                EmailProviderMocks.get_successful_send_response()\n+            )\n             mock_email_provider.return_value = mock_email_instance\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-            \n+\n             # Step 1: Create notification\n             notification_data = {\n                 \"type\": \"email\",\n                 \"to\": \"user@example.com\",\n                 \"subject\": \"Welcome to Our Platform!\",\n                 \"message\": \"Thank you for joining us. Get started with these next steps...\",\n                 \"priority\": \"normal\",\n                 \"data\": {\n                     \"user_name\": \"John Doe\",\n                     \"platform\": \"Our Platform\",\n-                    \"next_steps\": [\"Complete profile\", \"Explore features\", \"Join community\"]\n-                }\n+                    \"next_steps\": [\n+                        \"Complete profile\",\n+                        \"Explore features\",\n+                        \"Join community\",\n+                    ],\n+                },\n             }\n-            \n-            response = client.post(\"/api/v1/notifications\",\n-                                  json=notification_data,\n-                                  headers=headers)\n-            \n+\n+            response = client.post(\n+                \"/api/v1/notifications\", json=notification_data, headers=headers\n+            )\n+\n             assert response.status_code == 200\n             result = response.json()\n             notification_id = result[\"notification_id\"]\n             task_id = result[\"task_id\"]\n-            \n+\n             # Step 2: Check notification status\n-            response = client.get(f\"/api/v1/notifications/{notification_id}/status\",\n-                                 headers=headers)\n-            \n+            response = client.get(\n+                f\"/api/v1/notifications/{notification_id}/status\", headers=headers\n+            )\n+\n             assert response.status_code == 200\n             status_result = response.json()\n             assert status_result[\"notification_id\"] == notification_id\n             assert status_result[\"status\"] in [\"pending\", \"queued\", \"sent\"]\n-            \n+\n             # Step 3: Verify task was queued\n             assert task_id == \"workflow-task-123\"\n             mock_task.apply_async.assert_called_once()\n-            \n+\n             # Step 4: Simulate task execution and provider delivery\n             # In real workflow, this would happen asynchronously\n             mock_email_instance.send.assert_not_called()  # Would be called by worker\n-            \n+\n             # Workflow complete - notification created, queued, and ready for delivery\n-    \n-    @patch('httpx.AsyncClient.post')\n-    def test_template_based_notification_workflow(self, mock_identity, client: TestClient, sample_notification_template):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    def test_template_based_notification_workflow(\n+        self, mock_identity, client: TestClient, sample_notification_template\n+    ):\n         \"\"\"Test workflow using notification templates\"\"\"\n         # Mock authentication\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_response\n-        \n-        with patch('tasks.notification_tasks.send_notification') as mock_task, \\\n-             patch('services.template_engine.TemplateEngine') as mock_template_engine:\n-            \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_response\n+\n+        with patch(\"tasks.notification_tasks.send_notification\") as mock_task, patch(\n+            \"services.template_engine.TemplateEngine\"\n+        ) as mock_template_engine:\n+\n             # Setup mocks\n             mock_result = MagicMock()\n             mock_result.id = \"template-task-123\"\n             mock_task.apply_async.return_value = mock_result\n-            \n+\n             mock_engine_instance = MagicMock()\n-            mock_engine_instance.render.return_value = \"Hello John, welcome to Our Platform!\"\n+            mock_engine_instance.render.return_value = (\n+                \"Hello John, welcome to Our Platform!\"\n+            )\n             mock_template_engine.return_value = mock_engine_instance\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-            \n+\n             # Step 1: Create notification with template\n             notification_data = {\n                 \"type\": \"email\",\n                 \"to\": \"john@example.com\",\n                 \"template_id\": sample_notification_template.id,\n                 \"data\": {\n                     \"name\": \"John\",\n                     \"platform\": \"Our Platform\",\n-                    \"action\": \"registration\"\n-                }\n+                    \"action\": \"registration\",\n+                },\n             }\n-            \n-            response = client.post(\"/api/v1/notifications\",\n-                                  json=notification_data,\n-                                  headers=headers)\n-            \n+\n+            response = client.post(\n+                \"/api/v1/notifications\", json=notification_data, headers=headers\n+            )\n+\n             assert response.status_code == 200\n             result = response.json()\n             notification_id = result[\"notification_id\"]\n-            \n+\n             # Step 2: Verify template would be used\n             # In real workflow, template engine would be called during task execution\n             mock_task.apply_async.assert_called_once()\n             task_args = mock_task.apply_async.call_args\n             task_data = task_args[0][0]  # First argument\n-            \n+\n             assert str(sample_notification_template.id) in str(task_data)\n             assert \"name\" in str(task_data)\n             assert \"John\" in str(task_data)\n-    \n-    @patch('httpx.AsyncClient.post')\n-    def test_multi_channel_notification_workflow(self, mock_identity, client: TestClient):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    def test_multi_channel_notification_workflow(\n+        self, mock_identity, client: TestClient\n+    ):\n         \"\"\"Test workflow sending notifications across multiple channels\"\"\"\n         # Mock authentication\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_response\n-        \n-        with patch('tasks.notification_tasks.send_notification') as mock_task:\n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_response\n+\n+        with patch(\"tasks.notification_tasks.send_notification\") as mock_task:\n             mock_result = MagicMock()\n             mock_result.id = \"multi-channel-task\"\n             mock_task.apply_async.return_value = mock_result\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-            \n+\n             channels_data = [\n                 {\n                     \"type\": \"email\",\n                     \"to\": \"user@example.com\",\n                     \"subject\": \"Security Alert\",\n-                    \"message\": \"Suspicious login detected on your account\"\n+                    \"message\": \"Suspicious login detected on your account\",\n                 },\n                 {\n                     \"type\": \"sms\",\n                     \"to\": \"+1234567890\",\n-                    \"message\": \"ALERT: Suspicious login detected. Check your email for details.\"\n+                    \"message\": \"ALERT: Suspicious login detected. Check your email for details.\",\n                 },\n                 {\n                     \"type\": \"push\",\n                     \"to\": \"push-token-123\",\n                     \"title\": \"Security Alert\",\n                     \"message\": \"Suspicious login detected\",\n-                    \"data\": {\"deep_link\": \"/security/alerts\"}\n-                }\n+                    \"data\": {\"deep_link\": \"/security/alerts\"},\n+                },\n             ]\n-            \n+\n             notification_ids = []\n-            \n+\n             # Send notifications across all channels\n             for channel_data in channels_data:\n-                response = client.post(\"/api/v1/notifications\",\n-                                      json=channel_data,\n-                                      headers=headers)\n-                \n+                response = client.post(\n+                    \"/api/v1/notifications\", json=channel_data, headers=headers\n+                )\n+\n                 assert response.status_code == 200\n                 result = response.json()\n                 notification_ids.append(result[\"notification_id\"])\n-            \n+\n             # Verify all notifications were created\n             assert len(notification_ids) == 3\n             assert mock_task.apply_async.call_count == 3\n-            \n+\n             # Each notification should have been queued for delivery\n             for notification_id in notification_ids:\n-                response = client.get(f\"/api/v1/notifications/{notification_id}/status\",\n-                                     headers=headers)\n+                response = client.get(\n+                    f\"/api/v1/notifications/{notification_id}/status\", headers=headers\n+                )\n                 assert response.status_code == 200\n-    \n-    @patch('httpx.AsyncClient.post')\n-    def test_high_priority_notification_workflow(self, mock_identity, client: TestClient):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    def test_high_priority_notification_workflow(\n+        self, mock_identity, client: TestClient\n+    ):\n         \"\"\"Test high priority notification workflow\"\"\"\n         # Mock authentication\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_response\n-        \n-        with patch('tasks.notification_tasks.send_notification') as mock_task:\n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_response\n+\n+        with patch(\"tasks.notification_tasks.send_notification\") as mock_task:\n             mock_result = MagicMock()\n             mock_result.id = \"urgent-task-123\"\n             mock_task.apply_async.return_value = mock_result\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-            \n+\n             # Create urgent notification\n             notification_data = {\n                 \"type\": \"sms\",\n                 \"to\": \"+1234567890\",\n                 \"message\": \"URGENT: Your account has been locked due to suspicious activity. Contact support immediately.\",\n-                \"priority\": \"urgent\"\n+                \"priority\": \"urgent\",\n             }\n-            \n-            response = client.post(\"/api/v1/notifications\",\n-                                  json=notification_data,\n-                                  headers=headers)\n-            \n+\n+            response = client.post(\n+                \"/api/v1/notifications\", json=notification_data, headers=headers\n+            )\n+\n             assert response.status_code == 200\n             result = response.json()\n-            \n+\n             # Verify task was submitted with high priority routing\n             mock_task.apply_async.assert_called_once()\n             call_kwargs = mock_task.apply_async.call_args.kwargs\n-            \n+\n             # Should use urgent queue or high priority\n-            assert \"priority\" in str(call_kwargs) or \"urgent\" in str(call_kwargs) or \\\n-                   any(\"urgent\" in str(arg) for arg in mock_task.apply_async.call_args)\n+            assert (\n+                \"priority\" in str(call_kwargs)\n+                or \"urgent\" in str(call_kwargs)\n+                or any(\"urgent\" in str(arg) for arg in mock_task.apply_async.call_args)\n+            )\n \n \n @pytest.mark.e2e\n class TestUserNotificationPreferencesWorkflow:\n     \"\"\"Test workflows involving user notification preferences\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n-    def test_user_notification_preferences_respected(self, mock_identity, client: TestClient):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    def test_user_notification_preferences_respected(\n+        self, mock_identity, client: TestClient\n+    ):\n         \"\"\"Test that user notification preferences are respected\"\"\"\n         # Mock user with specific preferences\n         user_data = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n         user_data[\"notification_preferences\"] = {\n             \"email\": {\"enabled\": True, \"categories\": [\"security\", \"updates\"]},\n             \"sms\": {\"enabled\": False, \"categories\": []},\n-            \"push\": {\"enabled\": True, \"categories\": [\"security\", \"messages\"]}\n+            \"push\": {\"enabled\": True, \"categories\": [\"security\", \"messages\"]},\n         }\n-        \n+\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = user_data\n         mock_identity.return_value = mock_response\n-        \n+\n         # Mock user contact info endpoint\n-        with patch('httpx.AsyncClient.get') as mock_get:\n+        with patch(\"httpx.AsyncClient.get\") as mock_get:\n             mock_contact_response = AsyncMock()\n             mock_contact_response.status_code = 200\n-            mock_contact_response.json.return_value = IdentityServiceMocks.get_user_contact_info_response()[\"json\"]\n+            mock_contact_response.json.return_value = (\n+                IdentityServiceMocks.get_user_contact_info_response()[\"json\"]\n+            )\n             mock_get.return_value = mock_contact_response\n-            \n-            with patch('tasks.notification_tasks.send_notification') as mock_task:\n+\n+            with patch(\"tasks.notification_tasks.send_notification\") as mock_task:\n                 mock_result = MagicMock()\n                 mock_result.id = \"preference-task-123\"\n                 mock_task.apply_async.return_value = mock_result\n-                \n+\n                 headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-                \n+\n                 # Test 1: Send security notification (should work for email and push)\n                 security_notification = {\n                     \"type\": \"email\",\n                     \"to\": \"user@example.com\",\n                     \"subject\": \"Security Alert\",\n                     \"message\": \"Suspicious activity detected\",\n-                    \"category\": \"security\"\n+                    \"category\": \"security\",\n                 }\n-                \n-                response = client.post(\"/api/v1/notifications\",\n-                                      json=security_notification,\n-                                      headers=headers)\n-                \n+\n+                response = client.post(\n+                    \"/api/v1/notifications\", json=security_notification, headers=headers\n+                )\n+\n                 assert response.status_code == 200  # Should be allowed\n-                \n+\n                 # Test 2: Send SMS (should be blocked due to preferences)\n                 sms_notification = {\n                     \"type\": \"sms\",\n                     \"to\": \"+1234567890\",\n                     \"message\": \"Update available\",\n-                    \"category\": \"updates\"\n+                    \"category\": \"updates\",\n                 }\n-                \n-                response = client.post(\"/api/v1/notifications\",\n-                                      json=sms_notification,\n-                                      headers=headers)\n-                \n+\n+                response = client.post(\n+                    \"/api/v1/notifications\", json=sms_notification, headers=headers\n+                )\n+\n                 # Depending on implementation, might be blocked or queued but filtered\n                 assert response.status_code in [200, 403]\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_notification_frequency_limiting(self, mock_identity, client: TestClient):\n         \"\"\"Test notification frequency limiting\"\"\"\n         # Mock authentication\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_response\n-        \n-        with patch('tasks.notification_tasks.send_notification') as mock_task, \\\n-             patch('services.rate_limiter.RateLimiter') as mock_rate_limiter:\n-            \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_response\n+\n+        with patch(\"tasks.notification_tasks.send_notification\") as mock_task, patch(\n+            \"services.rate_limiter.RateLimiter\"\n+        ) as mock_rate_limiter:\n+\n             mock_result = MagicMock()\n             mock_result.id = \"rate-limited-task\"\n             mock_task.apply_async.return_value = mock_result\n-            \n+\n             mock_limiter_instance = AsyncMock()\n             mock_limiter_instance.is_allowed.return_value = True\n             mock_rate_limiter.return_value = mock_limiter_instance\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-            \n+\n             # Send multiple notifications rapidly\n             for i in range(5):\n                 notification_data = {\n                     \"type\": \"email\",\n                     \"to\": \"user@example.com\",\n                     \"subject\": f\"Notification {i+1}\",\n-                    \"message\": f\"This is notification {i+1}\"\n+                    \"message\": f\"This is notification {i+1}\",\n                 }\n-                \n-                response = client.post(\"/api/v1/notifications\",\n-                                      json=notification_data,\n-                                      headers=headers)\n-                \n+\n+                response = client.post(\n+                    \"/api/v1/notifications\", json=notification_data, headers=headers\n+                )\n+\n                 # First few should succeed, later ones might be rate limited\n                 assert response.status_code in [200, 429]\n-                \n+\n                 if response.status_code == 429:\n                     # Rate limiting detected\n                     assert \"rate limit\" in response.json()[\"detail\"].lower()\n                     break\n \n \n @pytest.mark.e2e\n class TestNotificationDeliveryTrackingWorkflow:\n     \"\"\"Test end-to-end notification delivery and tracking\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n-    def test_notification_delivery_status_tracking(self, mock_identity, client: TestClient, sample_notification):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    def test_notification_delivery_status_tracking(\n+        self, mock_identity, client: TestClient, sample_notification\n+    ):\n         \"\"\"Test tracking notification through complete delivery lifecycle\"\"\"\n         # Mock authentication\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_response\n+\n         headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n         notification_id = str(sample_notification.id)\n-        \n+\n         # Step 1: Check initial status\n-        response = client.get(f\"/api/v1/notifications/{notification_id}/status\",\n-                             headers=headers)\n-        \n+        response = client.get(\n+            f\"/api/v1/notifications/{notification_id}/status\", headers=headers\n+        )\n+\n         assert response.status_code == 200\n         initial_status = response.json()\n         assert initial_status[\"status\"] == \"pending\"\n         assert initial_status[\"sent_at\"] is None\n-        \n+\n         # Step 2: Simulate status updates (would happen via webhooks or worker updates)\n         # This would normally be done by background tasks and webhook handlers\n-        \n+\n         # Step 3: Check updated status\n-        response = client.get(f\"/api/v1/notifications/{notification_id}/status\",\n-                             headers=headers)\n-        \n+        response = client.get(\n+            f\"/api/v1/notifications/{notification_id}/status\", headers=headers\n+        )\n+\n         assert response.status_code == 200\n         updated_status = response.json()\n         assert \"status\" in updated_status\n         assert \"channel\" in updated_status\n         assert updated_status[\"notification_id\"] == notification_id\n-    \n-    @patch('httpx.AsyncClient.post')\n-    def test_failed_notification_retry_workflow(self, mock_identity, client: TestClient, sample_notification):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    def test_failed_notification_retry_workflow(\n+        self, mock_identity, client: TestClient, sample_notification\n+    ):\n         \"\"\"Test retry workflow for failed notifications\"\"\"\n         # Mock authentication\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_response\n+\n         headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n         notification_id = str(sample_notification.id)\n-        \n+\n         # Simulate failed notification (would be set by background task)\n         sample_notification.status = \"failed\"\n         sample_notification.error_message = \"SMTP server unavailable\"\n-        \n+\n         # Step 1: Check failed status\n-        response = client.get(f\"/api/v1/notifications/{notification_id}/status\",\n-                             headers=headers)\n-        \n+        response = client.get(\n+            f\"/api/v1/notifications/{notification_id}/status\", headers=headers\n+        )\n+\n         assert response.status_code == 200\n         failed_status = response.json()\n         assert failed_status[\"status\"] == \"failed\"\n         assert \"error_message\" in failed_status\n-        \n+\n         # Step 2: Retry failed notification\n-        with patch('tasks.notification_tasks.send_notification') as mock_task:\n+        with patch(\"tasks.notification_tasks.send_notification\") as mock_task:\n             mock_result = MagicMock()\n             mock_result.id = \"retry-task-123\"\n             mock_task.apply_async.return_value = mock_result\n-            \n-            response = client.post(f\"/api/v1/notifications/{notification_id}/retry\",\n-                                  headers=headers)\n-            \n+\n+            response = client.post(\n+                f\"/api/v1/notifications/{notification_id}/retry\", headers=headers\n+            )\n+\n             assert response.status_code == 200\n             retry_result = response.json()\n             assert retry_result[\"status\"] == \"queued\"\n             assert \"task_id\" in retry_result\n-            \n+\n             # Verify retry task was submitted\n             mock_task.apply_async.assert_called_once()\n \n \n @pytest.mark.e2e\n class TestNotificationAnalyticsWorkflow:\n     \"\"\"Test notification analytics and reporting workflows\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_notification_analytics_collection(self, mock_identity, client: TestClient):\n         \"\"\"Test that notification analytics are collected\"\"\"\n         # Mock admin user\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_admin_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_admin_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_response\n+\n         headers = {\"Authorization\": \"Bearer admin.jwt.token\"}\n-        \n+\n         # Mock analytics service\n-        with patch('services.analytics.AnalyticsService') as mock_analytics:\n+        with patch(\"services.analytics.AnalyticsService\") as mock_analytics:\n             mock_analytics_instance = AsyncMock()\n             mock_analytics_instance.get_notification_metrics.return_value = {\n                 \"total_sent\": 1250,\n                 \"delivery_rate\": 0.98,\n                 \"open_rate\": 0.45,\n                 \"click_rate\": 0.12,\n                 \"channel_breakdown\": {\n                     \"email\": {\"sent\": 800, \"delivered\": 784},\n                     \"sms\": {\"sent\": 300, \"delivered\": 297},\n-                    \"push\": {\"sent\": 150, \"delivered\": 145}\n+                    \"push\": {\"sent\": 150, \"delivered\": 145},\n                 },\n-                \"period\": \"last_7_days\"\n+                \"period\": \"last_7_days\",\n             }\n             mock_analytics.return_value = mock_analytics_instance\n-            \n+\n             # Get notification analytics\n-            response = client.get(\"/api/v1/analytics/notifications\",\n-                                 headers=headers,\n-                                 params={\"period\": \"7d\"})\n-            \n+            response = client.get(\n+                \"/api/v1/analytics/notifications\",\n+                headers=headers,\n+                params={\"period\": \"7d\"},\n+            )\n+\n             # Depending on implementation, might exist or return 404\n             assert response.status_code in [200, 404]\n-            \n+\n             if response.status_code == 200:\n                 analytics_data = response.json()\n                 assert \"total_sent\" in analytics_data or \"metrics\" in analytics_data\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_user_notification_history(self, mock_identity, client: TestClient):\n         \"\"\"Test retrieving user notification history\"\"\"\n         # Mock authentication\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_response\n+\n         headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        \n+\n         # Mock in-app provider for history\n-        with patch('providers.in_app.InAppProvider') as mock_provider:\n+        with patch(\"providers.in_app.InAppProvider\") as mock_provider:\n             mock_instance = AsyncMock()\n             mock_instance.get_notification_history.return_value = {\n                 \"notifications\": [\n                     {\n                         \"id\": \"notif-1\",\n                         \"subject\": \"Welcome!\",\n                         \"content\": \"Welcome to our platform\",\n-                        \"created_at\": (datetime.utcnow() - timedelta(days=1)).isoformat(),\n+                        \"created_at\": (\n+                            datetime.utcnow() - timedelta(days=1)\n+                        ).isoformat(),\n                         \"is_read\": True,\n-                        \"channel\": \"in_app\"\n+                        \"channel\": \"in_app\",\n                     },\n                     {\n                         \"id\": \"notif-2\",\n                         \"subject\": \"New Feature Available\",\n                         \"content\": \"Check out our latest feature\",\n-                        \"created_at\": (datetime.utcnow() - timedelta(days=2)).isoformat(),\n+                        \"created_at\": (\n+                            datetime.utcnow() - timedelta(days=2)\n+                        ).isoformat(),\n                         \"is_read\": False,\n-                        \"channel\": \"in_app\"\n-                    }\n+                        \"channel\": \"in_app\",\n+                    },\n                 ],\n                 \"total\": 2,\n                 \"page\": 1,\n-                \"has_more\": False\n+                \"has_more\": False,\n             }\n             mock_provider.return_value = mock_instance\n-            \n+\n             # Get user notification history\n-            response = client.get(\"/api/v1/notifications/history\",\n-                                 headers=headers,\n-                                 params={\"page\": 1, \"limit\": 10})\n-            \n+            response = client.get(\n+                \"/api/v1/notifications/history\",\n+                headers=headers,\n+                params={\"page\": 1, \"limit\": 10},\n+            )\n+\n             # Depending on implementation, might exist or return 404\n             assert response.status_code in [200, 404]\n-            \n+\n             if response.status_code == 200:\n                 history_data = response.json()\n                 assert \"notifications\" in history_data or \"history\" in history_data\n \n \n @pytest.mark.e2e\n class TestSystemIntegrationWorkflow:\n     \"\"\"Test integration with external systems\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n-    def test_webhook_notification_delivery_confirmation(self, mock_identity, client: TestClient):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    def test_webhook_notification_delivery_confirmation(\n+        self, mock_identity, client: TestClient\n+    ):\n         \"\"\"Test webhook handling for delivery confirmations\"\"\"\n         # Test webhook endpoint that would receive delivery confirmations\n         webhook_data = {\n             \"event\": \"delivered\",\n             \"message_id\": \"email-123456\",\n             \"recipient\": \"user@example.com\",\n             \"timestamp\": datetime.utcnow().isoformat(),\n-            \"provider\": \"sendgrid\"\n+            \"provider\": \"sendgrid\",\n         }\n-        \n+\n         # Mock webhook signature validation\n-        with patch('utils.webhook_validator.validate_signature') as mock_validator:\n+        with patch(\"utils.webhook_validator.validate_signature\") as mock_validator:\n             mock_validator.return_value = True\n-            \n-            response = client.post(\"/webhooks/email/delivery\",\n-                                  json=webhook_data,\n-                                  headers={\"X-Signature\": \"mock-signature\"})\n-            \n+\n+            response = client.post(\n+                \"/webhooks/email/delivery\",\n+                json=webhook_data,\n+                headers={\"X-Signature\": \"mock-signature\"},\n+            )\n+\n             # Depending on implementation, webhook endpoint might exist\n             assert response.status_code in [200, 404]\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_external_service_failure_handling(self, mock_identity, client: TestClient):\n         \"\"\"Test handling of external service failures\"\"\"\n         # Mock Identity Service failure\n         mock_identity.side_effect = Exception(\"Identity service unavailable\")\n-        \n+\n         headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n         notification_data = {\n             \"type\": \"email\",\n             \"to\": \"test@example.com\",\n-            \"message\": \"Test message\"\n+            \"message\": \"Test message\",\n         }\n-        \n-        response = client.post(\"/api/v1/notifications\",\n-                              json=notification_data,\n-                              headers=headers)\n-        \n+\n+        response = client.post(\n+            \"/api/v1/notifications\", json=notification_data, headers=headers\n+        )\n+\n         # Should handle external service failure gracefully\n         assert response.status_code == 503\n         assert \"service temporarily unavailable\" in response.json()[\"detail\"].lower()\n \n \n @pytest.mark.e2e\n @pytest.mark.slow\n class TestHighVolumeNotificationWorkflow:\n     \"\"\"Test high volume notification scenarios\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_bulk_notification_processing(self, mock_identity, client: TestClient):\n         \"\"\"Test processing large volumes of notifications\"\"\"\n         # Mock authentication\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_response\n-        \n-        with patch('tasks.notification_tasks.send_notification') as mock_task:\n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_response\n+\n+        with patch(\"tasks.notification_tasks.send_notification\") as mock_task:\n             mock_result = MagicMock()\n             mock_result.id = \"bulk-task\"\n             mock_task.apply_async.return_value = mock_result\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-            \n+\n             # Submit many notifications rapidly\n             notification_ids = []\n             batch_size = 10  # Reduced for testing\n-            \n+\n             for i in range(batch_size):\n                 notification_data = {\n                     \"type\": \"email\",\n                     \"to\": f\"user{i}@example.com\",\n                     \"subject\": f\"Bulk Notification {i+1}\",\n-                    \"message\": f\"This is bulk notification {i+1}\"\n+                    \"message\": f\"This is bulk notification {i+1}\",\n                 }\n-                \n-                response = client.post(\"/api/v1/notifications\",\n-                                      json=notification_data,\n-                                      headers=headers)\n-                \n+\n+                response = client.post(\n+                    \"/api/v1/notifications\", json=notification_data, headers=headers\n+                )\n+\n                 if response.status_code == 200:\n                     result = response.json()\n                     notification_ids.append(result[\"notification_id\"])\n                 elif response.status_code == 429:\n                     # Rate limited - acceptable for bulk processing\n                     break\n                 else:\n                     # Other error\n                     assert False, f\"Unexpected response: {response.status_code}\"\n-            \n+\n             # Should have processed at least some notifications\n             assert len(notification_ids) > 0\n             assert mock_task.apply_async.call_count >= len(notification_ids)\n-    \n+\n     def test_system_performance_under_load(self, client: TestClient):\n         \"\"\"Test system performance metrics under load\"\"\"\n         import time\n-        \n+\n         # Test health endpoint response time under load\n         start_time = time.time()\n-        \n+\n         responses = []\n         for _ in range(20):  # Make multiple rapid requests\n             response = client.get(\"/health\")\n             responses.append(response)\n-        \n+\n         end_time = time.time()\n         total_time = end_time - start_time\n-        \n+\n         # All health checks should succeed\n         assert all(r.status_code == 200 for r in responses)\n-        \n+\n         # Should complete reasonably quickly\n         assert total_time < 5.0, f\"Health checks took too long: {total_time}s\"\n-        \n+\n         # Average response time should be reasonable\n         avg_response_time = total_time / len(responses)\n-        assert avg_response_time < 0.5, f\"Average response time too slow: {avg_response_time}s\"\n\\ No newline at end of file\n+        assert (\n+            avg_response_time < 0.5\n+        ), f\"Average response time too slow: {avg_response_time}s\"\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/integration/test_database_migrations.py\t2025-09-09 19:31:35.769293+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/integration/test_database_migrations.py\t2025-09-10 11:37:02.328768+00:00\n@@ -14,157 +14,179 @@\n from alembic.config import Config\n from alembic.migration import MigrationContext\n from alembic.operations import Operations\n from alembic.runtime.environment import EnvironmentContext\n \n-from database.models import Base, NotificationCategory, NotificationTemplate, Notification\n+from database.models import (\n+    Base,\n+    NotificationCategory,\n+    NotificationTemplate,\n+    Notification,\n+)\n from database.connection import get_database_session\n \n \n-@pytest.mark.integration \n+@pytest.mark.integration\n @pytest.mark.requires_db\n class TestDatabaseMigrationIntegrity:\n     \"\"\"Test database migrations for integrity and rollback capability\"\"\"\n-    \n+\n     @pytest.fixture\n     async def migration_engine(self):\n         \"\"\"Create a separate database engine for migration testing\"\"\"\n         test_db_url = \"postgresql+asyncpg://test:test@localhost:5432/communication_test_migrations\"\n         engine = create_async_engine(test_db_url, echo=True)\n-        \n+\n         # Create test database if it doesn't exist\n         sync_engine = create_engine(test_db_url.replace(\"+asyncpg\", \"\"))\n         try:\n             async with engine.begin() as conn:\n-                await conn.execute(text(\"CREATE DATABASE communication_test_migrations\"))\n+                await conn.execute(\n+                    text(\"CREATE DATABASE communication_test_migrations\")\n+                )\n         except Exception:\n             pass  # Database might already exist\n-        \n+\n         yield engine\n-        \n+\n         # Cleanup\n         await engine.dispose()\n-    \n+\n     @pytest.fixture\n     async def alembic_config(self):\n         \"\"\"Create Alembic configuration for testing\"\"\"\n         config = Config()\n         config.set_main_option(\"script_location\", \"alembic\")\n-        config.set_main_option(\"sqlalchemy.url\", \"postgresql://test:test@localhost:5432/communication_test_migrations\")\n-        \n+        config.set_main_option(\n+            \"sqlalchemy.url\",\n+            \"postgresql://test:test@localhost:5432/communication_test_migrations\",\n+        )\n+\n         return config\n-    \n-    async def test_migration_upgrade_and_rollback_cycle(self, migration_engine, alembic_config):\n+\n+    async def test_migration_upgrade_and_rollback_cycle(\n+        self, migration_engine, alembic_config\n+    ):\n         \"\"\"Test complete migration upgrade and rollback cycle\"\"\"\n-        \n+\n         # Get current migration head\n         script_dir = script.ScriptDirectory.from_config(alembic_config)\n         head_revision = script_dir.get_current_head()\n-        \n+\n         with migration_engine.sync_engine.connect() as connection:\n             context = MigrationContext.configure(connection)\n             current_revision = context.get_current_revision()\n-            \n+\n             # Test upgrade to head\n             command.upgrade(alembic_config, \"head\")\n-            \n+\n             # Verify all tables are created\n             inspector = inspect(connection)\n             table_names = inspector.get_table_names()\n-            \n+\n             expected_tables = [\n                 \"notification_categories\",\n-                \"notification_templates\", \n+                \"notification_templates\",\n                 \"notifications\",\n-                \"alembic_version\"\n+                \"alembic_version\",\n             ]\n-            \n+\n             for table in expected_tables:\n-                assert table in table_names, f\"Table {table} not created after migration\"\n-            \n+                assert (\n+                    table in table_names\n+                ), f\"Table {table} not created after migration\"\n+\n             # Test rollback to previous revision\n             if current_revision and current_revision != head_revision:\n                 command.downgrade(alembic_config, current_revision)\n-                \n+\n                 # Verify rollback worked\n                 context_after_rollback = MigrationContext.configure(connection)\n                 revision_after_rollback = context_after_rollback.get_current_revision()\n                 assert revision_after_rollback == current_revision\n-    \n-    async def test_migration_data_integrity_during_schema_changes(self, migration_engine, alembic_config):\n+\n+    async def test_migration_data_integrity_during_schema_changes(\n+        self, migration_engine, alembic_config\n+    ):\n         \"\"\"Test that data integrity is maintained during schema migrations\"\"\"\n-        \n+\n         # Create initial schema\n         command.upgrade(alembic_config, \"head\")\n-        \n+\n         async with AsyncSession(migration_engine) as session:\n             # Insert test data\n             test_category = NotificationCategory(\n                 name=\"test_category\",\n                 description=\"Test category for migration testing\",\n-                organization_id=\"org-123\"\n+                organization_id=\"org-123\",\n             )\n             session.add(test_category)\n-            \n+\n             test_template = NotificationTemplate(\n                 name=\"test_template\",\n                 subject=\"Test Subject {{ name }}\",\n                 content=\"Hello {{ name }}, this is a test template.\",\n                 channel=\"email\",\n                 organization_id=\"org-123\",\n-                category_id=None  # Will be set after commit\n+                category_id=None,  # Will be set after commit\n             )\n             session.add(test_template)\n-            \n+\n             await session.commit()\n             await session.refresh(test_category)\n-            \n+\n             test_template.category_id = test_category.id\n             await session.commit()\n-            \n+\n             template_id = test_template.id\n             category_id = test_category.id\n-        \n+\n         # Simulate a migration that adds a new column\n         with migration_engine.sync_engine.connect() as connection:\n             context = MigrationContext.configure(connection)\n             op = Operations(context)\n-            \n+\n             # Add a new column\n             try:\n-                op.add_column('notification_templates', \n-                             Column('priority_level', String(20), default='normal'))\n+                op.add_column(\n+                    \"notification_templates\",\n+                    Column(\"priority_level\", String(20), default=\"normal\"),\n+                )\n             except Exception:\n                 pass  # Column might already exist\n-        \n+\n         # Verify data is still intact after schema change\n         async with AsyncSession(migration_engine) as session:\n             # Check that existing data is preserved\n             category = await session.get(NotificationCategory, category_id)\n             template = await session.get(NotificationTemplate, template_id)\n-            \n+\n             assert category is not None\n             assert template is not None\n             assert category.name == \"test_category\"\n             assert template.name == \"test_template\"\n             assert template.category_id == category_id\n-            \n+\n             # Verify new column exists and has default value\n             result = await session.execute(\n-                text(\"SELECT priority_level FROM notification_templates WHERE id = :id\"),\n-                {\"id\": template_id}\n+                text(\n+                    \"SELECT priority_level FROM notification_templates WHERE id = :id\"\n+                ),\n+                {\"id\": template_id},\n             )\n             priority_level = result.scalar()\n-            assert priority_level in ['normal', None]  # Default or NULL\n-    \n-    async def test_migration_rollback_data_preservation(self, migration_engine, alembic_config):\n+            assert priority_level in [\"normal\", None]  # Default or NULL\n+\n+    async def test_migration_rollback_data_preservation(\n+        self, migration_engine, alembic_config\n+    ):\n         \"\"\"Test that data is preserved during migration rollbacks\"\"\"\n-        \n+\n         # Start with a clean state\n         command.downgrade(alembic_config, \"base\")\n         command.upgrade(alembic_config, \"head\")\n-        \n+\n         # Insert test data\n         async with AsyncSession(migration_engine) as session:\n             test_notification = Notification(\n                 recipient=\"test@example.com\",\n                 subject=\"Migration Test\",\n@@ -172,127 +194,131 @@\n                 channel=\"email\",\n                 status=\"delivered\",\n                 organization_id=\"org-123\",\n                 user_id=\"user-123\",\n                 provider_message_id=\"test-msg-123\",\n-                metadata_={\"test\": \"data\"}\n+                metadata_={\"test\": \"data\"},\n             )\n             session.add(test_notification)\n             await session.commit()\n             notification_id = test_notification.id\n-        \n+\n         # Get current revision\n         with migration_engine.sync_engine.connect() as connection:\n             context = MigrationContext.configure(connection)\n             current_revision = context.get_current_revision()\n-        \n+\n         # Get revision history\n         script_dir = script.ScriptDirectory.from_config(alembic_config)\n         revisions = list(script_dir.walk_revisions())\n-        \n+\n         if len(revisions) > 1:\n             # Get previous revision\n             previous_revision = None\n             for i, rev in enumerate(revisions):\n                 if rev.revision == current_revision and i < len(revisions) - 1:\n                     previous_revision = revisions[i + 1].revision\n                     break\n-            \n+\n             if previous_revision:\n                 # Rollback to previous revision\n                 command.downgrade(alembic_config, previous_revision)\n-                \n+\n                 # Verify data still exists (if table structure allows)\n                 try:\n                     async with AsyncSession(migration_engine) as session:\n                         notification = await session.get(Notification, notification_id)\n                         if notification:  # Data preserved if table/columns still exist\n                             assert notification.recipient == \"test@example.com\"\n                             assert notification.subject == \"Migration Test\"\n                 except Exception:\n                     # Table structure changed too much, which is acceptable\n                     pass\n-                \n+\n                 # Upgrade back to head\n                 command.upgrade(alembic_config, \"head\")\n-    \n-    async def test_migration_foreign_key_constraints(self, migration_engine, alembic_config):\n+\n+    async def test_migration_foreign_key_constraints(\n+        self, migration_engine, alembic_config\n+    ):\n         \"\"\"Test that foreign key constraints are properly maintained during migrations\"\"\"\n-        \n+\n         command.upgrade(alembic_config, \"head\")\n-        \n+\n         async with AsyncSession(migration_engine) as session:\n             # Create category first\n             category = NotificationCategory(\n                 name=\"fk_test_category\",\n-                description=\"Foreign key test category\", \n-                organization_id=\"org-fk-test\"\n+                description=\"Foreign key test category\",\n+                organization_id=\"org-fk-test\",\n             )\n             session.add(category)\n             await session.commit()\n             await session.refresh(category)\n-            \n+\n             # Create template with valid foreign key\n             template = NotificationTemplate(\n                 name=\"fk_test_template\",\n                 subject=\"FK Test\",\n                 content=\"Testing foreign keys\",\n                 channel=\"email\",\n                 organization_id=\"org-fk-test\",\n-                category_id=category.id\n+                category_id=category.id,\n             )\n             session.add(template)\n             await session.commit()\n-            \n+\n             # Try to create template with invalid foreign key (should fail)\n             invalid_template = NotificationTemplate(\n                 name=\"invalid_fk_template\",\n-                subject=\"Invalid FK Test\", \n+                subject=\"Invalid FK Test\",\n                 content=\"This should fail\",\n                 channel=\"email\",\n                 organization_id=\"org-fk-test\",\n-                category_id=99999  # Non-existent category\n+                category_id=99999,  # Non-existent category\n             )\n             session.add(invalid_template)\n-            \n+\n             with pytest.raises(Exception):  # Should raise foreign key constraint error\n                 await session.commit()\n-    \n-    async def test_migration_index_creation_and_performance(self, migration_engine, alembic_config):\n+\n+    async def test_migration_index_creation_and_performance(\n+        self, migration_engine, alembic_config\n+    ):\n         \"\"\"Test that database indexes are created properly and improve performance\"\"\"\n-        \n+\n         command.upgrade(alembic_config, \"head\")\n-        \n+\n         with migration_engine.sync_engine.connect() as connection:\n             inspector = inspect(connection)\n-            \n+\n             # Check that expected indexes exist\n             notification_indexes = inspector.get_indexes(\"notifications\")\n-            index_names = [idx['name'] for idx in notification_indexes]\n-            \n+            index_names = [idx[\"name\"] for idx in notification_indexes]\n+\n             # Expected performance indexes\n             expected_indexes = [\n                 \"idx_notifications_organization_id\",\n-                \"idx_notifications_user_id\", \n+                \"idx_notifications_user_id\",\n                 \"idx_notifications_status\",\n                 \"idx_notifications_channel\",\n-                \"idx_notifications_created_at\"\n+                \"idx_notifications_created_at\",\n             ]\n-            \n+\n             for expected_idx in expected_indexes:\n                 # Check if any index exists that could serve the same purpose\n                 found = any(expected_idx in name for name in index_names)\n                 if not found:\n                     # Check if columns are indexed (might have different naming)\n                     column_indexed = False\n                     for idx in notification_indexes:\n-                        if any(col in expected_idx for col in idx['column_names']):\n+                        if any(col in expected_idx for col in idx[\"column_names\"]):\n                             column_indexed = True\n                             break\n-                    \n+\n                     assert column_indexed, f\"No index found for {expected_idx}\"\n-        \n+\n         # Test query performance with indexes\n         async with AsyncSession(migration_engine) as session:\n             # Insert test data for performance testing\n             notifications = []\n             for i in range(100):\n@@ -301,147 +327,172 @@\n                     subject=f\"Performance Test {i}\",\n                     content=f\"Testing query performance {i}\",\n                     channel=\"email\" if i % 2 == 0 else \"sms\",\n                     status=\"delivered\" if i % 3 == 0 else \"pending\",\n                     organization_id=f\"org-{i % 10}\",\n-                    user_id=f\"user-{i % 20}\"\n+                    user_id=f\"user-{i % 20}\",\n                 )\n                 notifications.append(notification)\n-            \n+\n             session.add_all(notifications)\n             await session.commit()\n-            \n+\n             # Test indexed query performance\n             import time\n-            \n+\n             start_time = time.time()\n             result = await session.execute(\n-                text(\"\"\"\n+                text(\n+                    \"\"\"\n                     SELECT COUNT(*) FROM notifications \n                     WHERE organization_id = :org_id \n                     AND status = :status\n-                \"\"\"),\n-                {\"org_id\": \"org-1\", \"status\": \"delivered\"}\n+                \"\"\"\n+                ),\n+                {\"org_id\": \"org-1\", \"status\": \"delivered\"},\n             )\n             query_time = time.time() - start_time\n-            \n+\n             # Query should be fast with proper indexing\n             assert query_time < 0.1, f\"Indexed query too slow: {query_time}s\"\n             assert result.scalar() >= 0\n \n \n @pytest.mark.integration\n-@pytest.mark.requires_db  \n+@pytest.mark.requires_db\n class TestMigrationScripts:\n     \"\"\"Test individual migration scripts for correctness\"\"\"\n-    \n+\n     async def test_initial_migration_creates_all_tables(self, alembic_config):\n         \"\"\"Test that initial migration creates all required tables\"\"\"\n-        \n+\n         # Start from clean state\n         command.downgrade(alembic_config, \"base\")\n-        \n+\n         # Apply first migration\n         command.upgrade(alembic_config, \"+1\")  # Apply next migration\n-        \n+\n         # Check tables are created correctly\n         engine = create_engine(alembic_config.get_main_option(\"sqlalchemy.url\"))\n         with engine.connect() as connection:\n             inspector = inspect(connection)\n             tables = inspector.get_table_names()\n-            \n+\n             # At minimum, should have alembic_version\n             assert \"alembic_version\" in tables\n-            \n+\n             # Check for main tables (depending on migration order)\n-            expected_base_tables = [\"notification_categories\", \"notification_templates\", \"notifications\"]\n-            created_tables = [table for table in expected_base_tables if table in tables]\n+            expected_base_tables = [\n+                \"notification_categories\",\n+                \"notification_templates\",\n+                \"notifications\",\n+            ]\n+            created_tables = [\n+                table for table in expected_base_tables if table in tables\n+            ]\n             assert len(created_tables) > 0, \"No main tables created in first migration\"\n-    \n+\n     async def test_migration_script_syntax_and_execution(self, alembic_config):\n         \"\"\"Test that all migration scripts have valid syntax and can execute\"\"\"\n-        \n+\n         script_dir = script.ScriptDirectory.from_config(alembic_config)\n-        \n+\n         # Test each migration script\n         for revision in script_dir.walk_revisions():\n             # Check upgrade function exists\n-            assert hasattr(revision.module, 'upgrade'), f\"Migration {revision.revision} missing upgrade function\"\n-            \n-            # Check downgrade function exists  \n-            assert hasattr(revision.module, 'downgrade'), f\"Migration {revision.revision} missing downgrade function\"\n-            \n+            assert hasattr(\n+                revision.module, \"upgrade\"\n+            ), f\"Migration {revision.revision} missing upgrade function\"\n+\n+            # Check downgrade function exists\n+            assert hasattr(\n+                revision.module, \"downgrade\"\n+            ), f\"Migration {revision.revision} missing downgrade function\"\n+\n             # Verify imports are correct\n             try:\n                 # Test that the module can be imported without errors\n                 upgrade_func = revision.module.upgrade\n                 downgrade_func = revision.module.downgrade\n-                \n-                assert callable(upgrade_func), f\"Upgrade function not callable in {revision.revision}\"\n-                assert callable(downgrade_func), f\"Downgrade function not callable in {revision.revision}\"\n-                \n+\n+                assert callable(\n+                    upgrade_func\n+                ), f\"Upgrade function not callable in {revision.revision}\"\n+                assert callable(\n+                    downgrade_func\n+                ), f\"Downgrade function not callable in {revision.revision}\"\n+\n             except Exception as e:\n                 pytest.fail(f\"Migration {revision.revision} has syntax errors: {e}\")\n-    \n+\n     async def test_migration_dependencies_and_ordering(self, alembic_config):\n         \"\"\"Test that migration dependencies are correctly specified\"\"\"\n-        \n+\n         script_dir = script.ScriptDirectory.from_config(alembic_config)\n         revisions = list(script_dir.walk_revisions())\n-        \n+\n         # Check revision dependencies\n         for revision in revisions:\n             if revision.down_revision:\n                 # Find the dependency\n                 dependency_exists = any(\n-                    rev.revision == revision.down_revision \n-                    for rev in revisions\n-                )\n-                assert dependency_exists, f\"Migration {revision.revision} depends on non-existent {revision.down_revision}\"\n-        \n+                    rev.revision == revision.down_revision for rev in revisions\n+                )\n+                assert (\n+                    dependency_exists\n+                ), f\"Migration {revision.revision} depends on non-existent {revision.down_revision}\"\n+\n         # Check for circular dependencies\n         visited = set()\n         for revision in revisions:\n             path = []\n             current = revision\n-            \n+\n             while current and current.revision not in visited:\n                 if current.revision in path:\n-                    pytest.fail(f\"Circular dependency detected involving {current.revision}\")\n-                \n+                    pytest.fail(\n+                        f\"Circular dependency detected involving {current.revision}\"\n+                    )\n+\n                 path.append(current.revision)\n-                current = script_dir.get_revision(current.down_revision) if current.down_revision else None\n-            \n+                current = (\n+                    script_dir.get_revision(current.down_revision)\n+                    if current.down_revision\n+                    else None\n+                )\n+\n             visited.update(path)\n \n \n @pytest.mark.integration\n @pytest.mark.slow\n class TestMigrationPerformance:\n     \"\"\"Test migration performance and handle large datasets\"\"\"\n-    \n-    async def test_migration_performance_with_large_dataset(self, migration_engine, alembic_config):\n+\n+    async def test_migration_performance_with_large_dataset(\n+        self, migration_engine, alembic_config\n+    ):\n         \"\"\"Test migration performance with large amounts of existing data\"\"\"\n-        \n+\n         # Create initial schema\n         command.upgrade(alembic_config, \"head\")\n-        \n+\n         # Insert large dataset\n         async with AsyncSession(migration_engine) as session:\n             # Create categories\n             categories = []\n             for i in range(10):\n                 category = NotificationCategory(\n                     name=f\"perf_category_{i}\",\n                     description=f\"Performance test category {i}\",\n-                    organization_id=f\"org-perf-{i % 3}\"\n+                    organization_id=f\"org-perf-{i % 3}\",\n                 )\n                 categories.append(category)\n-            \n+\n             session.add_all(categories)\n             await session.commit()\n-            \n+\n             # Create large number of notifications\n             notifications = []\n             for i in range(1000):  # Reduced for test speed\n                 notification = Notification(\n                     recipient=f\"perf{i}@example.com\",\n@@ -450,98 +501,107 @@\n                     channel=\"email\" if i % 2 == 0 else \"sms\",\n                     status=\"delivered\" if i % 3 == 0 else \"pending\",\n                     organization_id=f\"org-perf-{i % 3}\",\n                     user_id=f\"user-perf-{i % 100}\",\n                     provider_message_id=f\"perf-msg-{i}\",\n-                    metadata_={f\"key_{i}\": f\"value_{i}\"}\n+                    metadata_={f\"key_{i}\": f\"value_{i}\"},\n                 )\n                 notifications.append(notification)\n-                \n+\n                 # Batch insert to avoid memory issues\n                 if len(notifications) >= 100:\n                     session.add_all(notifications)\n                     await session.commit()\n                     notifications = []\n-            \n+\n             if notifications:\n                 session.add_all(notifications)\n                 await session.commit()\n-        \n+\n         # Test migration performance\n         import time\n-        \n+\n         start_time = time.time()\n-        \n+\n         # Simulate adding a new column migration\n         with migration_engine.sync_engine.connect() as connection:\n             context = MigrationContext.configure(connection)\n             op = Operations(context)\n-            \n+\n             try:\n-                op.add_column('notifications', \n-                             Column('priority_score', Integer, default=0))\n-                \n+                op.add_column(\n+                    \"notifications\", Column(\"priority_score\", Integer, default=0)\n+                )\n+\n                 # Update existing records with default value\n                 connection.execute(\n-                    text(\"UPDATE notifications SET priority_score = 0 WHERE priority_score IS NULL\")\n-                )\n-                \n+                    text(\n+                        \"UPDATE notifications SET priority_score = 0 WHERE priority_score IS NULL\"\n+                    )\n+                )\n+\n             except Exception:\n                 pass  # Column might already exist\n-        \n+\n         migration_time = time.time() - start_time\n-        \n+\n         # Migration should complete in reasonable time even with large dataset\n         assert migration_time < 30, f\"Migration took too long: {migration_time}s\"\n-        \n+\n         # Verify data integrity after migration\n         async with AsyncSession(migration_engine) as session:\n-            count_result = await session.execute(text(\"SELECT COUNT(*) FROM notifications\"))\n+            count_result = await session.execute(\n+                text(\"SELECT COUNT(*) FROM notifications\")\n+            )\n             count = count_result.scalar()\n-            assert count == 1000, f\"Data loss during migration: expected 1000, got {count}\"\n-    \n-    async def test_migration_rollback_performance(self, migration_engine, alembic_config):\n+            assert (\n+                count == 1000\n+            ), f\"Data loss during migration: expected 1000, got {count}\"\n+\n+    async def test_migration_rollback_performance(\n+        self, migration_engine, alembic_config\n+    ):\n         \"\"\"Test rollback performance and data consistency\"\"\"\n-        \n+\n         # Ensure we're at head\n         command.upgrade(alembic_config, \"head\")\n-        \n+\n         # Get current revision\n         with migration_engine.sync_engine.connect() as connection:\n             context = MigrationContext.configure(connection)\n             current_revision = context.get_current_revision()\n-        \n+\n         # Get script directory and find previous revision\n         script_dir = script.ScriptDirectory.from_config(alembic_config)\n         revisions = list(script_dir.walk_revisions())\n-        \n+\n         previous_revision = None\n         for i, rev in enumerate(revisions):\n             if rev.revision == current_revision and i < len(revisions) - 1:\n                 previous_revision = revisions[i + 1].revision\n                 break\n-        \n+\n         if previous_revision:\n             # Test rollback performance\n             import time\n-            \n+\n             start_time = time.time()\n             command.downgrade(alembic_config, previous_revision)\n             rollback_time = time.time() - start_time\n-            \n+\n             # Rollback should be reasonably fast\n             assert rollback_time < 10, f\"Rollback took too long: {rollback_time}s\"\n-            \n+\n             # Verify system is still functional after rollback\n             with migration_engine.sync_engine.connect() as connection:\n                 inspector = inspect(connection)\n                 tables = inspector.get_table_names()\n-                \n+\n                 # Should still have basic functionality\n                 assert \"alembic_version\" in tables\n-                \n+\n                 # Context should reflect the rollback\n                 context = MigrationContext.configure(connection)\n                 assert context.get_current_revision() == previous_revision\n-            \n+\n             # Upgrade back to head\n-            command.upgrade(alembic_config, \"head\")\n\\ No newline at end of file\n+            command.upgrade(alembic_config, \"head\")\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_database.py\t2025-09-09 13:33:06.881040+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_database.py\t2025-09-10 11:37:02.395690+00:00\n@@ -1,256 +1,294 @@\n \"\"\"\n Tests for database configuration and connection management\n \"\"\"\n+\n import pytest\n from unittest.mock import patch, MagicMock\n import os\n \n from database import DatabaseConfig, get_db_session, init_database, DatabaseUtils\n from models import NotificationCategory\n \n+\n class TestDatabaseConfig:\n     \"\"\"Test DatabaseConfig class\"\"\"\n-    \n+\n     def test_database_url_from_env(self):\n         \"\"\"Test database URL configuration from environment\"\"\"\n-        with patch.dict(os.environ, {'DATABASE_URL': 'postgresql://test:pass@localhost:5432/test_db'}):\n-            config = DatabaseConfig()\n-            assert config.database_url == 'postgresql://test:pass@localhost:5432/test_db'\n-    \n+        with patch.dict(\n+            os.environ,\n+            {\"DATABASE_URL\": \"postgresql://test:pass@localhost:5432/test_db\"},\n+        ):\n+            config = DatabaseConfig()\n+            assert (\n+                config.database_url == \"postgresql://test:pass@localhost:5432/test_db\"\n+            )\n+\n     def test_database_url_from_components(self):\n         \"\"\"Test database URL construction from components\"\"\"\n         env_vars = {\n-            'DATABASE_HOST': 'test-host',\n-            'DATABASE_PORT': '5433',\n-            'DATABASE_USER': 'test_user',\n-            'DATABASE_PASSWORD': 'test_pass',\n-            'DATABASE_NAME': 'test_db'\n+            \"DATABASE_HOST\": \"test-host\",\n+            \"DATABASE_PORT\": \"5433\",\n+            \"DATABASE_USER\": \"test_user\",\n+            \"DATABASE_PASSWORD\": \"test_pass\",\n+            \"DATABASE_NAME\": \"test_db\",\n         }\n-        \n+\n         with patch.dict(os.environ, env_vars, clear=True):\n             config = DatabaseConfig()\n-            expected_url = 'postgresql://test_user:test_pass@test-host:5433/test_db'\n+            expected_url = \"postgresql://test_user:test_pass@test-host:5433/test_db\"\n             assert config.database_url == expected_url\n-    \n+\n     def test_default_database_url(self):\n         \"\"\"Test default database URL when no env vars set\"\"\"\n         # Clear relevant environment variables\n         env_vars_to_clear = [\n-            'DATABASE_URL', 'DATABASE_HOST', 'DATABASE_PORT', \n-            'DATABASE_USER', 'DATABASE_PASSWORD', 'DATABASE_NAME'\n+            \"DATABASE_URL\",\n+            \"DATABASE_HOST\",\n+            \"DATABASE_PORT\",\n+            \"DATABASE_USER\",\n+            \"DATABASE_PASSWORD\",\n+            \"DATABASE_NAME\",\n         ]\n-        \n+\n         with patch.dict(os.environ, {}, clear=True):\n             config = DatabaseConfig()\n-            expected_url = 'postgresql://comm_user:comm_pass@localhost:5435/communication_service'\n+            expected_url = (\n+                \"postgresql://comm_user:comm_pass@localhost:5435/communication_service\"\n+            )\n             assert config.database_url == expected_url\n-    \n+\n     def test_engine_configuration(self):\n         \"\"\"Test SQLAlchemy engine configuration\"\"\"\n-        with patch('database.create_engine') as mock_create_engine:\n-            config = DatabaseConfig()\n-            \n+        with patch(\"database.create_engine\") as mock_create_engine:\n+            config = DatabaseConfig()\n+\n             mock_create_engine.assert_called_once()\n             call_args = mock_create_engine.call_args\n-            \n+\n             # Check that engine is created with correct parameters\n-            assert 'pool_size' in call_args.kwargs\n-            assert 'max_overflow' in call_args.kwargs\n-            assert 'pool_timeout' in call_args.kwargs\n-            assert 'pool_recycle' in call_args.kwargs\n-            assert call_args.kwargs['pool_pre_ping'] is True\n-    \n+            assert \"pool_size\" in call_args.kwargs\n+            assert \"max_overflow\" in call_args.kwargs\n+            assert \"pool_timeout\" in call_args.kwargs\n+            assert \"pool_recycle\" in call_args.kwargs\n+            assert call_args.kwargs[\"pool_pre_ping\"] is True\n+\n     def test_health_check_success(self, mock_redis):\n         \"\"\"Test successful database health check\"\"\"\n-        with patch('database.db_config') as mock_db_config:\n-            mock_session = MagicMock()\n-            mock_db_config.get_session.return_value.__enter__.return_value = mock_session\n-            \n+        with patch(\"database.db_config\") as mock_db_config:\n+            mock_session = MagicMock()\n+            mock_db_config.get_session.return_value.__enter__.return_value = (\n+                mock_session\n+            )\n+\n             result = mock_db_config.health_check.return_value = True\n             assert result is True\n-    \n+\n     def test_health_check_failure(self):\n         \"\"\"Test failed database health check\"\"\"\n         config = DatabaseConfig()\n-        \n+\n         # Mock get_session to raise an exception\n-        with patch.object(config, 'get_session') as mock_get_session:\n+        with patch.object(config, \"get_session\") as mock_get_session:\n             mock_get_session.side_effect = Exception(\"Connection failed\")\n-            \n+\n             result = config.health_check()\n             assert result is False\n \n+\n class TestDatabaseSession:\n     \"\"\"Test database session management\"\"\"\n-    \n+\n     def test_get_db_session_success(self, db_session):\n         \"\"\"Test successful database session retrieval\"\"\"\n         # This test uses the fixture which already tests the session\n         assert db_session is not None\n-        \n+\n         # Test that we can perform a basic query\n         result = db_session.execute(\"SELECT 1\").scalar()\n         assert result == 1\n-    \n+\n     def test_get_db_session_dependency(self):\n         \"\"\"Test FastAPI dependency for database session\"\"\"\n-        with patch('database.db_config') as mock_db_config:\n+        with patch(\"database.db_config\") as mock_db_config:\n             mock_session = MagicMock()\n             mock_db_config.get_session_direct.return_value = mock_session\n-            \n+\n             # Test the generator function\n             gen = get_db_session()\n             session = next(gen)\n-            \n+\n             assert session == mock_session\n-            \n+\n             # Test cleanup\n             try:\n                 next(gen)\n             except StopIteration:\n                 pass  # Expected behavior\n-            \n+\n             mock_session.close.assert_called_once()\n+\n \n class TestDatabaseInitialization:\n     \"\"\"Test database initialization functions\"\"\"\n-    \n+\n     def test_init_database(self):\n         \"\"\"Test database initialization\"\"\"\n-        with patch('database.db_config') as mock_db_config, \\\n-             patch('database.get_db') as mock_get_db, \\\n-             patch('database.create_default_categories') as mock_create_categories:\n-            \n-            mock_session = MagicMock()\n-            mock_get_db.return_value.__enter__.return_value = mock_session\n-            \n+        with patch(\"database.db_config\") as mock_db_config, patch(\n+            \"database.get_db\"\n+        ) as mock_get_db, patch(\n+            \"database.create_default_categories\"\n+        ) as mock_create_categories:\n+\n+            mock_session = MagicMock()\n+            mock_get_db.return_value.__enter__.return_value = mock_session\n+\n             # Mock that no categories exist\n             mock_session.query.return_value.count.return_value = 0\n-            \n+\n             # Mock default categories\n             mock_categories = [MagicMock() for _ in range(5)]\n             mock_create_categories.return_value = mock_categories\n-            \n+\n             init_database()\n-            \n+\n             # Verify tables are created\n             mock_db_config.create_tables.assert_called_once()\n-            \n+\n             # Verify default categories are added\n             for category in mock_categories:\n                 mock_session.add.assert_any_call(category)\n-            \n+\n             mock_session.commit.assert_called()\n-    \n+\n     def test_init_database_with_existing_categories(self):\n         \"\"\"Test database initialization when categories already exist\"\"\"\n-        with patch('database.db_config') as mock_db_config, \\\n-             patch('database.get_db') as mock_get_db:\n-            \n-            mock_session = MagicMock()\n-            mock_get_db.return_value.__enter__.return_value = mock_session\n-            \n+        with patch(\"database.db_config\") as mock_db_config, patch(\n+            \"database.get_db\"\n+        ) as mock_get_db:\n+\n+            mock_session = MagicMock()\n+            mock_get_db.return_value.__enter__.return_value = mock_session\n+\n             # Mock that categories already exist\n             mock_session.query.return_value.count.return_value = 3\n-            \n+\n             init_database()\n-            \n+\n             # Verify tables are still created but no categories added\n             mock_db_config.create_tables.assert_called_once()\n             mock_session.add.assert_not_called()\n \n+\n class TestDatabaseUtils:\n     \"\"\"Test DatabaseUtils utility functions\"\"\"\n-    \n+\n     def test_get_table_counts(self):\n         \"\"\"Test getting table row counts\"\"\"\n-        with patch('database.get_db') as mock_get_db:\n-            mock_session = MagicMock()\n-            mock_get_db.return_value.__enter__.return_value = mock_session\n-            \n+        with patch(\"database.get_db\") as mock_get_db:\n+            mock_session = MagicMock()\n+            mock_get_db.return_value.__enter__.return_value = mock_session\n+\n             # Mock query counts\n             count_values = [5, 10, 20, 3, 8, 15, 50]\n             mock_session.query.return_value.count.side_effect = count_values\n-            \n+\n             counts = DatabaseUtils.get_table_counts()\n-            \n+\n             expected_tables = [\n-                \"categories\", \"templates\", \"notifications\", \"preferences\",\n-                \"conversations\", \"participants\", \"messages\"\n+                \"categories\",\n+                \"templates\",\n+                \"notifications\",\n+                \"preferences\",\n+                \"conversations\",\n+                \"participants\",\n+                \"messages\",\n             ]\n-            \n+\n             for table in expected_tables:\n                 assert table in counts\n                 assert isinstance(counts[table], int)\n-    \n+\n     def test_cleanup_old_notifications(self):\n         \"\"\"Test cleanup of old notifications\"\"\"\n-        with patch('database.get_db') as mock_get_db:\n-            mock_session = MagicMock()\n-            mock_get_db.return_value.__enter__.return_value = mock_session\n-            \n+        with patch(\"database.get_db\") as mock_get_db:\n+            mock_session = MagicMock()\n+            mock_get_db.return_value.__enter__.return_value = mock_session\n+\n             # Mock query chain\n             mock_query = MagicMock()\n             mock_session.query.return_value = mock_query\n             mock_query.filter.return_value = mock_query\n             mock_query.delete.return_value = 5  # 5 notifications deleted\n-            \n+\n             deleted_count = DatabaseUtils.cleanup_old_notifications(days=30)\n-            \n+\n             assert deleted_count == 5\n             mock_session.commit.assert_called_once()\n-    \n+\n     def test_get_database_stats(self):\n         \"\"\"Test getting comprehensive database statistics\"\"\"\n-        with patch.object(DatabaseUtils, 'get_table_counts') as mock_get_counts:\n+        with patch.object(DatabaseUtils, \"get_table_counts\") as mock_get_counts:\n             mock_get_counts.return_value = {\"notifications\": 100, \"messages\": 50}\n-            \n-            with patch('database.db_config') as mock_db_config:\n+\n+            with patch(\"database.db_config\") as mock_db_config:\n                 # Mock pool methods\n                 mock_pool = MagicMock()\n                 mock_pool.size.return_value = 10\n                 mock_pool.checkedout.return_value = 2\n                 mock_pool.overflow.return_value = 0\n                 mock_pool.checkedin.return_value = 8\n                 mock_db_config.engine.pool = mock_pool\n-                \n+\n                 stats = DatabaseUtils.get_database_stats()\n-                \n+\n                 assert \"table_counts\" in stats\n                 assert \"connection_info\" in stats\n                 assert stats[\"table_counts\"][\"notifications\"] == 100\n                 assert stats[\"connection_info\"][\"pool_size\"] == 10\n \n+\n class TestDatabaseIntegration:\n     \"\"\"Integration tests for database functionality\"\"\"\n-    \n+\n     def test_full_database_flow(self, db_session):\n         \"\"\"Test complete database flow with real session\"\"\"\n         # Create a category\n         category = NotificationCategory(\n-            name=\"integration_test\",\n-            description=\"Integration test category\"\n+            name=\"integration_test\", description=\"Integration test category\"\n         )\n         db_session.add(category)\n         db_session.commit()\n-        \n+\n         # Verify it was created\n-        retrieved = db_session.query(NotificationCategory).filter_by(name=\"integration_test\").first()\n+        retrieved = (\n+            db_session.query(NotificationCategory)\n+            .filter_by(name=\"integration_test\")\n+            .first()\n+        )\n         assert retrieved is not None\n         assert retrieved.description == \"Integration test category\"\n-        \n+\n         # Update it\n         retrieved.description = \"Updated description\"\n         db_session.commit()\n-        \n+\n         # Verify update\n-        updated = db_session.query(NotificationCategory).filter_by(name=\"integration_test\").first()\n+        updated = (\n+            db_session.query(NotificationCategory)\n+            .filter_by(name=\"integration_test\")\n+            .first()\n+        )\n         assert updated.description == \"Updated description\"\n-        \n+\n         # Delete it\n         db_session.delete(updated)\n         db_session.commit()\n-        \n+\n         # Verify deletion\n-        deleted = db_session.query(NotificationCategory).filter_by(name=\"integration_test\").first()\n-        assert deleted is None\n\\ No newline at end of file\n+        deleted = (\n+            db_session.query(NotificationCategory)\n+            .filter_by(name=\"integration_test\")\n+            .first()\n+        )\n+        assert deleted is None\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_auth_failures.py\t2025-09-09 13:56:15.013820+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_auth_failures.py\t2025-09-10 11:37:02.421133+00:00\n@@ -1,363 +1,388 @@\n \"\"\"\n Test Authentication Failure Scenarios\n Comprehensive testing of authentication error handling and edge cases\n \"\"\"\n+\n import pytest\n import httpx\n from unittest.mock import patch, AsyncMock, MagicMock\n from fastapi.testclient import TestClient\n from main import app\n \n+\n class TestTokenValidationFailures:\n     \"\"\"Test various token validation failure scenarios\"\"\"\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_malformed_token_handling(self, mock_client):\n         \"\"\"Test handling of malformed JWT tokens\"\"\"\n         # Mock Identity Service response for malformed token\n         mock_response = AsyncMock()\n         mock_response.status_code = 400\n         mock_response.json.return_value = {\"detail\": \"Malformed token\"}\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n         client = TestClient(app)\n         malformed_tokens = [\n             \"not.a.token\",\n             \"too.few.parts\",\n             \"too.many.parts.in.this.token.here\",\n             \"invalid-base64-@#$%\",\n-            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid-payload.signature\"\n+            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid-payload.signature\",\n         ]\n-        \n+\n         for token in malformed_tokens:\n             response = client.get(\n-                \"/api/v1/templates\",\n-                headers={\"Authorization\": f\"Bearer {token}\"}\n+                \"/api/v1/templates\", headers={\"Authorization\": f\"Bearer {token}\"}\n             )\n-            \n-            assert response.status_code == 401, f\"Malformed token should be rejected: {token}\"\n+\n+            assert (\n+                response.status_code == 401\n+            ), f\"Malformed token should be rejected: {token}\"\n             assert \"Token validation failed\" in response.json()[\"detail\"]\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_expired_token_handling(self, mock_client):\n         \"\"\"Test handling of expired JWT tokens\"\"\"\n         # Mock Identity Service response for expired token\n         mock_response = AsyncMock()\n         mock_response.status_code = 401\n         mock_response.json.return_value = {\"detail\": \"Token expired\"}\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n-        client = TestClient(app)\n-        expired_token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MDA5NjQ4MDB9.signature\"\n-        \n-        response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": f\"Bearer {expired_token}\"}\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n+        client = TestClient(app)\n+        expired_token = (\n+            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MDA5NjQ4MDB9.signature\"\n+        )\n+\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": f\"Bearer {expired_token}\"}\n+        )\n+\n         assert response.status_code == 401\n         assert \"Invalid or expired token\" in response.json()[\"detail\"]\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_revoked_token_handling(self, mock_client):\n         \"\"\"Test handling of revoked JWT tokens\"\"\"\n         # Mock Identity Service response for revoked token\n         mock_response = AsyncMock()\n         mock_response.status_code = 401\n         mock_response.json.return_value = {\"detail\": \"Token revoked\"}\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n         client = TestClient(app)\n         revoked_token = \"valid.format.but.revoked\"\n-        \n-        response = client.get(\n-            \"/api/v1/templates\", \n-            headers={\"Authorization\": f\"Bearer {revoked_token}\"}\n-        )\n-        \n+\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": f\"Bearer {revoked_token}\"}\n+        )\n+\n         assert response.status_code == 401\n         assert \"Invalid or expired token\" in response.json()[\"detail\"]\n+\n \n class TestNetworkFailureScenarios:\n     \"\"\"Test network-related authentication failures\"\"\"\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_identity_service_connection_refused(self, mock_client):\n         \"\"\"Test handling when Identity Service connection is refused\"\"\"\n-        mock_client.return_value.__aenter__.return_value.post.side_effect = httpx.ConnectError(\"Connection refused\")\n-        \n-        client = TestClient(app)\n-        response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer valid.token\"}\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.side_effect = (\n+            httpx.ConnectError(\"Connection refused\")\n+        )\n+\n+        client = TestClient(app)\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer valid.token\"}\n+        )\n+\n         assert response.status_code == 503\n         assert \"unavailable\" in response.json()[\"detail\"].lower()\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_identity_service_dns_resolution_failure(self, mock_client):\n         \"\"\"Test handling of DNS resolution failures\"\"\"\n-        mock_client.return_value.__aenter__.return_value.post.side_effect = httpx.ConnectError(\"DNS resolution failed\")\n-        \n-        client = TestClient(app)\n-        response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer valid.token\"}\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.side_effect = (\n+            httpx.ConnectError(\"DNS resolution failed\")\n+        )\n+\n+        client = TestClient(app)\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer valid.token\"}\n+        )\n+\n         assert response.status_code == 503\n         assert \"unavailable\" in response.json()[\"detail\"].lower()\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_identity_service_read_timeout(self, mock_client):\n         \"\"\"Test handling of read timeouts\"\"\"\n-        mock_client.return_value.__aenter__.return_value.post.side_effect = httpx.ReadTimeout(\"Read timeout\")\n-        \n-        client = TestClient(app)\n-        response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer valid.token\"}\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.side_effect = (\n+            httpx.ReadTimeout(\"Read timeout\")\n+        )\n+\n+        client = TestClient(app)\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer valid.token\"}\n+        )\n+\n         assert response.status_code == 503\n         assert \"temporarily unavailable\" in response.json()[\"detail\"]\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_identity_service_pool_timeout(self, mock_client):\n         \"\"\"Test handling of connection pool timeouts\"\"\"\n-        mock_client.return_value.__aenter__.return_value.post.side_effect = httpx.PoolTimeout(\"Pool timeout\")\n-        \n-        client = TestClient(app)\n-        response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer valid.token\"}\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.side_effect = (\n+            httpx.PoolTimeout(\"Pool timeout\")\n+        )\n+\n+        client = TestClient(app)\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer valid.token\"}\n+        )\n+\n         assert response.status_code == 503\n         assert \"temporarily unavailable\" in response.json()[\"detail\"]\n+\n \n class TestIdentityServiceErrorResponses:\n     \"\"\"Test handling of various Identity Service error responses\"\"\"\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_identity_service_internal_error(self, mock_client):\n         \"\"\"Test handling of Identity Service 500 errors\"\"\"\n         mock_response = AsyncMock()\n         mock_response.status_code = 500\n         mock_response.json.return_value = {\"detail\": \"Internal server error\"}\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n-        client = TestClient(app)\n-        response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer valid.token\"}\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n+        client = TestClient(app)\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer valid.token\"}\n+        )\n+\n         assert response.status_code == 401\n         assert \"Token validation failed\" in response.json()[\"detail\"]\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_identity_service_bad_gateway(self, mock_client):\n         \"\"\"Test handling of Identity Service 502 errors\"\"\"\n         mock_response = AsyncMock()\n         mock_response.status_code = 502\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n-        client = TestClient(app)\n-        response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer valid.token\"}\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n+        client = TestClient(app)\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer valid.token\"}\n+        )\n+\n         assert response.status_code == 401\n         assert \"Token validation failed\" in response.json()[\"detail\"]\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_identity_service_rate_limit(self, mock_client):\n         \"\"\"Test handling of Identity Service 429 rate limit errors\"\"\"\n         mock_response = AsyncMock()\n         mock_response.status_code = 429\n         mock_response.json.return_value = {\"detail\": \"Rate limit exceeded\"}\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n-        client = TestClient(app)\n-        response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer valid.token\"}\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n+        client = TestClient(app)\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer valid.token\"}\n+        )\n+\n         assert response.status_code == 401\n         assert \"Token validation failed\" in response.json()[\"detail\"]\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_identity_service_invalid_json_response(self, mock_client):\n         \"\"\"Test handling of Identity Service returning invalid JSON\"\"\"\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.side_effect = ValueError(\"Invalid JSON\")\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n-        client = TestClient(app)\n-        response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer valid.token\"}\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n+        client = TestClient(app)\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer valid.token\"}\n+        )\n+\n         assert response.status_code == 401\n         assert \"Token validation failed\" in response.json()[\"detail\"]\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_identity_service_empty_response(self, mock_client):\n         \"\"\"Test handling of Identity Service returning empty response\"\"\"\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = {}\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n-        client = TestClient(app)\n-        response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer valid.token\"}\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n+        client = TestClient(app)\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer valid.token\"}\n+        )\n+\n         # Should still work, but user_id will be 'unknown' in logs\n         assert response.status_code == 200\n \n+\n class TestEdgeCaseScenarios:\n     \"\"\"Test edge cases and unusual scenarios\"\"\"\n-    \n+\n     def test_extremely_long_token(self):\n         \"\"\"Test handling of extremely long JWT tokens\"\"\"\n         client = TestClient(app)\n-        \n+\n         # Create an extremely long token (10KB)\n         long_token = \"a\" * 10240\n-        \n-        response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": f\"Bearer {long_token}\"}\n-        )\n-        \n+\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": f\"Bearer {long_token}\"}\n+        )\n+\n         # Should handle gracefully without crashing\n         assert response.status_code in [401, 403, 422]\n-    \n+\n     def test_special_characters_in_token(self):\n         \"\"\"Test handling of tokens with special characters\"\"\"\n         client = TestClient(app)\n-        \n+\n         special_tokens = [\n             \"token.with.unicode.\u00f1\",\n             \"token-with-dashes\",\n             \"token_with_underscores\",\n             \"token+with+plus\",\n             \"token/with/slashes\",\n-            \"token=with=equals\"\n+            \"token=with=equals\",\n         ]\n-        \n+\n         for token in special_tokens:\n             response = client.get(\n-                \"/api/v1/templates\",\n-                headers={\"Authorization\": f\"Bearer {token}\"}\n+                \"/api/v1/templates\", headers={\"Authorization\": f\"Bearer {token}\"}\n             )\n-            \n+\n             # Should handle gracefully\n             assert response.status_code in [401, 403, 422]\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_partial_user_data_response(self, mock_client):\n         \"\"\"Test handling of partial user data from Identity Service\"\"\"\n         # Mock response with only minimal user data\n         mock_user_data = {\n             \"user_id\": \"test-user-123\"\n             # Missing organization_id, email, roles, etc.\n         }\n-        \n+\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = mock_user_data\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n-        client = TestClient(app)\n-        response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer valid.token\"}\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n+        client = TestClient(app)\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer valid.token\"}\n+        )\n+\n         assert response.status_code == 200\n         response_data = response.json()\n-        \n+\n         # Should handle missing optional fields gracefully\n         assert \"user_id\" in response_data or \"requested_by\" in response_data\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_memory_exhaustion_protection(self, mock_client):\n         \"\"\"Test protection against memory exhaustion attacks\"\"\"\n         # Mock response with extremely large user data\n         large_data = \"x\" * 1000000  # 1MB string\n-        mock_user_data = {\n-            \"user_id\": \"test-user\",\n-            \"large_field\": large_data\n-        }\n-        \n+        mock_user_data = {\"user_id\": \"test-user\", \"large_field\": large_data}\n+\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = mock_user_data\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n-        client = TestClient(app)\n-        response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer valid.token\"}\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n+        client = TestClient(app)\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer valid.token\"}\n+        )\n+\n         # Should handle large responses without crashing\n         assert response.status_code in [200, 401, 422]\n \n+\n class TestAuthenticationLogging:\n     \"\"\"Test authentication-related logging behavior\"\"\"\n-    \n-    @patch('main.httpx.AsyncClient')\n-    @patch('main.logger')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n+    @patch(\"main.logger\")\n     def test_authentication_error_logging(self, mock_logger, mock_client):\n         \"\"\"Test that authentication errors are properly logged\"\"\"\n-        mock_client.return_value.__aenter__.return_value.post.side_effect = httpx.TimeoutException(\"Timeout\")\n-        \n-        client = TestClient(app)\n-        response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer valid.token\"}\n-        )\n-        \n-        assert response.status_code == 503\n-        mock_logger.error.assert_called_with(\"Timeout calling Identity Service for token validation\")\n-    \n-    @patch('main.httpx.AsyncClient')\n-    @patch('main.logger')\n+        mock_client.return_value.__aenter__.return_value.post.side_effect = (\n+            httpx.TimeoutException(\"Timeout\")\n+        )\n+\n+        client = TestClient(app)\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer valid.token\"}\n+        )\n+\n+        assert response.status_code == 503\n+        mock_logger.error.assert_called_with(\n+            \"Timeout calling Identity Service for token validation\"\n+        )\n+\n+    @patch(\"main.httpx.AsyncClient\")\n+    @patch(\"main.logger\")\n     def test_no_sensitive_data_in_logs(self, mock_logger, mock_client):\n         \"\"\"Test that sensitive data is not logged\"\"\"\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = {\n             \"user_id\": \"test-user-123\",\n             \"email\": \"test@example.com\",\n             \"password\": \"should-not-be-logged\",\n-            \"secret_key\": \"should-not-be-logged\"\n+            \"secret_key\": \"should-not-be-logged\",\n         }\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n-        client = TestClient(app)\n-        response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer valid.token\"}\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n+        client = TestClient(app)\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer valid.token\"}\n+        )\n+\n         assert response.status_code == 200\n-        \n+\n         # Verify no sensitive data in logs\n         logged_calls = [call[0][0] for call in mock_logger.info.call_args_list]\n         logged_text = \" \".join(logged_calls).lower()\n-        \n+\n         assert \"password\" not in logged_text\n         assert \"secret\" not in logged_text\n-        assert \"token\" not in logged_text or \"validated\" in logged_text  # Token can appear in \"Token validated\" message\n\\ No newline at end of file\n+        assert (\n+            \"token\" not in logged_text or \"validated\" in logged_text\n+        )  # Token can appear in \"Token validated\" message\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_auth_integration.py\t2025-09-09 13:55:42.503854+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_auth_integration.py\t2025-09-10 11:37:02.488218+00:00\n@@ -1,356 +1,379 @@\n \"\"\"\n Tests for JWT Authentication Integration\n Following the JWT_AUTHENTICATION_INTEGRATION_GUIDE.md\n \"\"\"\n+\n import pytest\n import httpx\n from unittest.mock import patch, AsyncMock, MagicMock\n from fastapi.testclient import TestClient\n from main import app\n \n+\n class TestJWTAuthentication:\n     \"\"\"Test JWT token validation integration\"\"\"\n \n-    @patch('main.httpx.AsyncClient')\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_valid_token_authentication(self, mock_client):\n         \"\"\"Test successful authentication with valid token\"\"\"\n         # Mock user data\n         mock_user_data = {\n             \"user_id\": \"12345678-1234-5678-9012-123456789012\",\n             \"organization_id\": \"87654321-4321-8765-2109-876543210987\",\n             \"email\": \"test@example.com\",\n             \"roles\": [\"user\"],\n             \"permissions\": [\"read\", \"write\"],\n             \"is_verified\": True,\n-            \"expires_at\": \"2025-12-31T23:59:59Z\"\n+            \"expires_at\": \"2025-12-31T23:59:59Z\",\n         }\n-        \n+\n         # Mock Identity Service response\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = mock_user_data\n-        \n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n-        client = TestClient(app)\n-        valid_token = \"valid.jwt.token\"\n-        \n+\n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n+        client = TestClient(app)\n+        valid_token = \"valid.jwt.token\"\n+\n         # Test protected endpoint\n         response = client.post(\n             \"/api/v1/notifications\",\n             headers={\"Authorization\": f\"Bearer {valid_token}\"},\n             json={\n                 \"type\": \"email\",\n                 \"to\": \"test@example.com\",\n-                \"message\": \"Test notification\"\n-            }\n-        )\n-        \n+                \"message\": \"Test notification\",\n+            },\n+        )\n+\n         assert response.status_code == 200\n         response_data = response.json()\n         assert response_data[\"sent_by\"] == mock_user_data[\"user_id\"]\n         assert response_data[\"organization\"] == mock_user_data[\"organization_id\"]\n-        \n+\n         # Verify Identity Service was called correctly\n         mock_client.return_value.__aenter__.return_value.post.assert_called_once_with(\n             \"http://localhost:8001/auth/validate\",\n             headers={\"Authorization\": f\"Bearer {valid_token}\"},\n-            timeout=5.0\n-        )\n-\n-    @patch('main.httpx.AsyncClient')\n+            timeout=5.0,\n+        )\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_invalid_token_authentication(self, mock_client):\n         \"\"\"Test authentication failure with invalid token\"\"\"\n         # Mock Identity Service rejection\n         mock_response = AsyncMock()\n         mock_response.status_code = 401\n         mock_response.json.return_value = {\"detail\": \"Invalid token\"}\n-        \n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n+\n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n         client = TestClient(app)\n         invalid_token = \"invalid.jwt.token\"\n-        \n+\n         # Test protected endpoint\n         response = client.post(\n             \"/api/v1/notifications\",\n             headers={\"Authorization\": f\"Bearer {invalid_token}\"},\n             json={\n                 \"type\": \"email\",\n                 \"to\": \"test@example.com\",\n-                \"message\": \"Test notification\"\n-            }\n-        )\n-        \n+                \"message\": \"Test notification\",\n+            },\n+        )\n+\n         assert response.status_code == 401\n         assert \"Invalid or expired token\" in response.json()[\"detail\"]\n         assert \"WWW-Authenticate\" in response.headers\n         assert response.headers[\"WWW-Authenticate\"] == \"Bearer\"\n \n     def test_missing_token_authentication(self):\n         \"\"\"Test authentication failure with no token\"\"\"\n         client = TestClient(app)\n-        \n-        response = client.post(\n-            \"/api/v1/notifications\",\n-            json={\n-                \"type\": \"email\",\n-                \"to\": \"test@example.com\",\n-                \"message\": \"Test notification\"\n-            }\n-        )\n-        \n-        assert response.status_code in [401, 403]  # FastAPI HTTPBearer returns 403 for missing auth\n+\n+        response = client.post(\n+            \"/api/v1/notifications\",\n+            json={\n+                \"type\": \"email\",\n+                \"to\": \"test@example.com\",\n+                \"message\": \"Test notification\",\n+            },\n+        )\n+\n+        assert response.status_code in [\n+            401,\n+            403,\n+        ]  # FastAPI HTTPBearer returns 403 for missing auth\n         assert \"Not authenticated\" in response.json()[\"detail\"]\n \n-    @patch('main.httpx.AsyncClient')\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_identity_service_timeout(self, mock_client):\n         \"\"\"Test handling of Identity Service timeout\"\"\"\n         # Mock timeout exception\n-        mock_client.return_value.__aenter__.return_value.post.side_effect = httpx.TimeoutException(\"Timeout\")\n-        \n-        client = TestClient(app)\n-        valid_token = \"valid.jwt.token\"\n-        \n-        response = client.post(\n-            \"/api/v1/notifications\", \n-            headers={\"Authorization\": f\"Bearer {valid_token}\"},\n-            json={\n-                \"type\": \"email\",\n-                \"to\": \"test@example.com\",\n-                \"message\": \"Test notification\"\n-            }\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.side_effect = (\n+            httpx.TimeoutException(\"Timeout\")\n+        )\n+\n+        client = TestClient(app)\n+        valid_token = \"valid.jwt.token\"\n+\n+        response = client.post(\n+            \"/api/v1/notifications\",\n+            headers={\"Authorization\": f\"Bearer {valid_token}\"},\n+            json={\n+                \"type\": \"email\",\n+                \"to\": \"test@example.com\",\n+                \"message\": \"Test notification\",\n+            },\n+        )\n+\n         assert response.status_code == 503\n         assert \"temporarily unavailable\" in response.json()[\"detail\"]\n \n-    @patch('main.httpx.AsyncClient')\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_identity_service_network_error(self, mock_client):\n         \"\"\"Test handling of Identity Service network errors\"\"\"\n         # Mock network exception\n-        mock_client.return_value.__aenter__.return_value.post.side_effect = httpx.RequestError(\"Network error\")\n-        \n-        client = TestClient(app)\n-        valid_token = \"valid.jwt.token\"\n-        \n-        response = client.post(\n-            \"/api/v1/notifications\",\n-            headers={\"Authorization\": f\"Bearer {valid_token}\"},\n-            json={\n-                \"type\": \"email\", \n-                \"to\": \"test@example.com\",\n-                \"message\": \"Test notification\"\n-            }\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.side_effect = (\n+            httpx.RequestError(\"Network error\")\n+        )\n+\n+        client = TestClient(app)\n+        valid_token = \"valid.jwt.token\"\n+\n+        response = client.post(\n+            \"/api/v1/notifications\",\n+            headers={\"Authorization\": f\"Bearer {valid_token}\"},\n+            json={\n+                \"type\": \"email\",\n+                \"to\": \"test@example.com\",\n+                \"message\": \"Test notification\",\n+            },\n+        )\n+\n         assert response.status_code == 503\n         assert \"unavailable\" in response.json()[\"detail\"]\n \n-    @patch('main.httpx.AsyncClient')\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_identity_service_unexpected_status(self, mock_client):\n         \"\"\"Test handling of unexpected status codes from Identity Service\"\"\"\n         # Mock unexpected status code\n         mock_response = AsyncMock()\n         mock_response.status_code = 500\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n-        client = TestClient(app)\n-        valid_token = \"valid.jwt.token\"\n-        \n-        response = client.post(\n-            \"/api/v1/notifications\",\n-            headers={\"Authorization\": f\"Bearer {valid_token}\"},\n-            json={\n-                \"type\": \"email\",\n-                \"to\": \"test@example.com\", \n-                \"message\": \"Test notification\"\n-            }\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n+        client = TestClient(app)\n+        valid_token = \"valid.jwt.token\"\n+\n+        response = client.post(\n+            \"/api/v1/notifications\",\n+            headers={\"Authorization\": f\"Bearer {valid_token}\"},\n+            json={\n+                \"type\": \"email\",\n+                \"to\": \"test@example.com\",\n+                \"message\": \"Test notification\",\n+            },\n+        )\n+\n         assert response.status_code == 401\n         assert \"Token validation failed\" in response.json()[\"detail\"]\n \n-    @patch('main.httpx.AsyncClient')\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_general_exception_handling(self, mock_client):\n         \"\"\"Test handling of general exceptions during token validation\"\"\"\n         # Mock general exception\n-        mock_client.return_value.__aenter__.return_value.post.side_effect = Exception(\"Unexpected error\")\n-        \n-        client = TestClient(app)\n-        valid_token = \"valid.jwt.token\"\n-        \n-        response = client.post(\n-            \"/api/v1/notifications\",\n-            headers={\"Authorization\": f\"Bearer {valid_token}\"},\n-            json={\n-                \"type\": \"email\",\n-                \"to\": \"test@example.com\",\n-                \"message\": \"Test notification\"\n-            }\n-        )\n-        \n+        mock_client.return_value.__aenter__.return_value.post.side_effect = Exception(\n+            \"Unexpected error\"\n+        )\n+\n+        client = TestClient(app)\n+        valid_token = \"valid.jwt.token\"\n+\n+        response = client.post(\n+            \"/api/v1/notifications\",\n+            headers={\"Authorization\": f\"Bearer {valid_token}\"},\n+            json={\n+                \"type\": \"email\",\n+                \"to\": \"test@example.com\",\n+                \"message\": \"Test notification\",\n+            },\n+        )\n+\n         assert response.status_code == 401\n         assert \"Token validation failed\" in response.json()[\"detail\"]\n \n-    @patch('main.httpx.AsyncClient')  \n+    @patch(\"main.httpx.AsyncClient\")\n     def test_user_context_in_endpoints(self, mock_client):\n         \"\"\"Test that user context is properly available in endpoints\"\"\"\n         # Mock user data\n         mock_user_data = {\n             \"user_id\": \"user-123\",\n-            \"organization_id\": \"org-456\", \n+            \"organization_id\": \"org-456\",\n             \"email\": \"test@example.com\",\n             \"roles\": [\"admin\", \"user\"],\n-            \"permissions\": [\"read\", \"write\", \"admin\"]\n+            \"permissions\": [\"read\", \"write\", \"admin\"],\n         }\n-        \n+\n         # Mock successful auth\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = mock_user_data\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n-        client = TestClient(app)\n-        valid_token = \"valid.jwt.token\"\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n+        client = TestClient(app)\n+        valid_token = \"valid.jwt.token\"\n+\n         # Test different endpoints to verify user context\n         endpoints_to_test = [\n             (\"/api/v1/notifications/unread\", \"GET\", None),\n             (\"/api/v1/conversations\", \"GET\", None),\n             (\"/api/v1/templates\", \"GET\", None),\n             (\"/api/v1/queue/status\", \"GET\", None),\n         ]\n-        \n+\n         for endpoint, method, data in endpoints_to_test:\n             if method == \"GET\":\n                 response = client.get(\n-                    endpoint,\n-                    headers={\"Authorization\": f\"Bearer {valid_token}\"}\n+                    endpoint, headers={\"Authorization\": f\"Bearer {valid_token}\"}\n                 )\n             elif method == \"POST\":\n                 response = client.post(\n                     endpoint,\n                     headers={\"Authorization\": f\"Bearer {valid_token}\"},\n-                    json=data\n+                    json=data,\n                 )\n-            \n+\n             # Should not be authentication error\n             assert response.status_code != 401\n-            \n+\n             # Verify user context is included in response\n             response_data = response.json()\n             if \"user_id\" in response_data:\n                 assert response_data[\"user_id\"] == mock_user_data[\"user_id\"]\n             if \"organization\" in response_data:\n-                assert response_data[\"organization\"] == mock_user_data[\"organization_id\"]\n+                assert (\n+                    response_data[\"organization\"] == mock_user_data[\"organization_id\"]\n+                )\n             if \"user_roles\" in response_data:\n                 assert response_data[\"user_roles\"] == mock_user_data[\"roles\"]\n \n+\n class TestAuthenticationLogging:\n     \"\"\"Test authentication logging behavior\"\"\"\n-    \n-    @patch('main.httpx.AsyncClient')\n-    @patch('main.logger')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n+    @patch(\"main.logger\")\n     def test_successful_authentication_logging(self, mock_logger, mock_client):\n         \"\"\"Test that successful authentication is logged\"\"\"\n         # Mock user data\n-        mock_user_data = {\n-            \"user_id\": \"test-user-123\",\n-            \"email\": \"test@example.com\"\n-        }\n-        \n+        mock_user_data = {\"user_id\": \"test-user-123\", \"email\": \"test@example.com\"}\n+\n         # Mock successful response\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = mock_user_data\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n         client = TestClient(app)\n         response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer valid.token\"}\n-        )\n-        \n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer valid.token\"}\n+        )\n+\n         # Verify logging was called\n         mock_logger.info.assert_called_with(\"Token validated for user: test-user-123\")\n-    \n-    @patch('main.httpx.AsyncClient')\n-    @patch('main.logger') \n+\n+    @patch(\"main.httpx.AsyncClient\")\n+    @patch(\"main.logger\")\n     def test_authentication_failure_logging(self, mock_logger, mock_client):\n         \"\"\"Test that authentication failures are logged\"\"\"\n         # Mock rejection response\n         mock_response = AsyncMock()\n         mock_response.status_code = 401\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n         client = TestClient(app)\n         response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer invalid.token\"}\n-        )\n-        \n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer invalid.token\"}\n+        )\n+\n         # Verify warning was logged\n         mock_logger.warning.assert_called_with(\"Invalid or expired token provided\")\n \n+\n class TestAuthenticationPerformance:\n     \"\"\"Test authentication performance\"\"\"\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_auth_response_time(self, mock_client):\n         \"\"\"Test that authentication doesn't add excessive latency\"\"\"\n         import time\n-        \n+\n         # Mock fast Identity Service response\n-        mock_user_data = {\n-            \"user_id\": \"user-123\",\n-            \"organization_id\": \"org-456\"\n-        }\n-        \n+        mock_user_data = {\"user_id\": \"user-123\", \"organization_id\": \"org-456\"}\n+\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = mock_user_data\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n-        client = TestClient(app)\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n+        client = TestClient(app)\n+\n         start_time = time.time()\n         response = client.get(\n             \"/api/v1/notifications/unread\",\n-            headers={\"Authorization\": \"Bearer valid.jwt.token\"}\n+            headers={\"Authorization\": \"Bearer valid.jwt.token\"},\n         )\n         end_time = time.time()\n-        \n+\n         # Authentication should add minimal overhead (< 1 second in test environment)\n         assert (end_time - start_time) < 1.0\n         assert response.status_code != 401\n \n+\n class TestAuthenticationConfiguration:\n     \"\"\"Test authentication configuration\"\"\"\n-    \n-    @patch.dict('os.environ', {'IDENTITY_SERVICE_URL': 'http://custom-identity:9001'})\n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch.dict(\"os.environ\", {\"IDENTITY_SERVICE_URL\": \"http://custom-identity:9001\"})\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_custom_identity_service_url(self, mock_client):\n         \"\"\"Test that custom Identity Service URL is used\"\"\"\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = {\"user_id\": \"test\"}\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n         # Import main after setting environment variable\n         from importlib import reload\n         import main\n+\n         reload(main)\n-        \n+\n         client = TestClient(main.app)\n         response = client.get(\n-            \"/api/v1/templates\",\n-            headers={\"Authorization\": \"Bearer test.token\"}\n-        )\n-        \n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer test.token\"}\n+        )\n+\n         # Verify custom URL was used\n         mock_client.return_value.__aenter__.return_value.post.assert_called_with(\n             \"http://custom-identity:9001/auth/validate\",\n             headers={\"Authorization\": \"Bearer test.token\"},\n-            timeout=5.0\n-        )\n\\ No newline at end of file\n+            timeout=5.0,\n+        )\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/integration/test_auth_integration.py\t2025-09-09 18:39:26.532468+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/integration/test_auth_integration.py\t2025-09-10 11:37:02.508239+00:00\n@@ -8,391 +8,409 @@\n from unittest.mock import patch, AsyncMock, MagicMock\n from fastapi.testclient import TestClient\n \n from tests.fixtures.mock_responses import IdentityServiceMocks\n \n+\n @pytest.mark.auth\n @pytest.mark.integration\n class TestJWTAuthentication:\n     \"\"\"Test JWT token validation with Identity Service\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_jwt_validation_success(self, mock_post, client: TestClient):\n         \"\"\"Test successful JWT token validation\"\"\"\n         # Mock successful Identity Service response\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n-        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n+        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n+\n         # Should succeed with valid token\n         assert response.status_code == 200\n-        \n+\n         # Verify Identity Service was called correctly\n         mock_post.assert_called_once()\n         call_args = mock_post.call_args\n         assert \"auth/validate\" in str(call_args) or \"validate\" in str(call_args)\n-        \n+\n         # Should include JWT token in request\n         auth_header = None\n-        if call_args.kwargs.get('headers'):\n-            auth_header = call_args.kwargs['headers'].get('Authorization')\n+        if call_args.kwargs.get(\"headers\"):\n+            auth_header = call_args.kwargs[\"headers\"].get(\"Authorization\")\n         assert auth_header == \"Bearer valid.jwt.token\"\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_jwt_validation_invalid_token(self, mock_post, client: TestClient):\n         \"\"\"Test JWT validation with invalid token\"\"\"\n         # Mock invalid token response\n         mock_response = AsyncMock()\n         mock_response.status_code = 401\n-        mock_response.json.return_value = IdentityServiceMocks.get_invalid_token_response()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_invalid_token_response()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         headers = {\"Authorization\": \"Bearer invalid.jwt.token\"}\n         response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n-        \n+\n         # Should fail with 401\n         assert response.status_code == 401\n         error_data = response.json()\n         assert \"detail\" in error_data\n-        assert \"invalid\" in error_data[\"detail\"].lower() or \"expired\" in error_data[\"detail\"].lower()\n-        \n+        assert (\n+            \"invalid\" in error_data[\"detail\"].lower()\n+            or \"expired\" in error_data[\"detail\"].lower()\n+        )\n+\n         # Should have WWW-Authenticate header\n         assert \"WWW-Authenticate\" in response.headers\n         assert response.headers[\"WWW-Authenticate\"] == \"Bearer\"\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_jwt_validation_expired_token(self, mock_post, client: TestClient):\n         \"\"\"Test JWT validation with expired token\"\"\"\n         # Mock expired token response\n         mock_response = AsyncMock()\n         mock_response.status_code = 401\n-        mock_response.json.return_value = IdentityServiceMocks.get_expired_token_response()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_expired_token_response()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         headers = {\"Authorization\": \"Bearer expired.jwt.token\"}\n         response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n-        \n+\n         # Should fail with 401\n         assert response.status_code == 401\n         error_data = response.json()\n         assert \"expired\" in error_data[\"detail\"].lower()\n-    \n+\n     def test_missing_authorization_header(self, client: TestClient):\n         \"\"\"Test request without Authorization header\"\"\"\n         response = client.get(\"/api/v1/notifications/unread\")\n-        \n+\n         assert response.status_code == 401\n         error_data = response.json()\n         assert \"not authenticated\" in error_data[\"detail\"].lower()\n-        \n+\n         # Should have WWW-Authenticate header\n         assert \"WWW-Authenticate\" in response.headers\n         assert response.headers[\"WWW-Authenticate\"] == \"Bearer\"\n-    \n+\n     def test_malformed_authorization_headers(self, client: TestClient):\n         \"\"\"Test various malformed Authorization headers\"\"\"\n         malformed_headers = [\n-            {\"Authorization\": \"invalid-header\"},          # No Bearer prefix\n-            {\"Authorization\": \"Bearer\"},                  # Missing token\n-            {\"Authorization\": \"Basic dXNlcjpwYXNz\"},     # Wrong scheme\n-            {\"Authorization\": \"Bearer \"},                # Empty token\n-            {\"Authorization\": \" Bearer valid.token\"},    # Leading space\n-            {\"Authorization\": \"bearer valid.token\"},     # Lowercase bearer\n+            {\"Authorization\": \"invalid-header\"},  # No Bearer prefix\n+            {\"Authorization\": \"Bearer\"},  # Missing token\n+            {\"Authorization\": \"Basic dXNlcjpwYXNz\"},  # Wrong scheme\n+            {\"Authorization\": \"Bearer \"},  # Empty token\n+            {\"Authorization\": \" Bearer valid.token\"},  # Leading space\n+            {\"Authorization\": \"bearer valid.token\"},  # Lowercase bearer\n         ]\n-        \n+\n         for headers in malformed_headers:\n             response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n             assert response.status_code == 401, f\"Should fail for header: {headers}\"\n-            \n+\n             error_data = response.json()\n             assert \"detail\" in error_data\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_jwt_validation_timeout_handling(self, mock_post, client: TestClient):\n         \"\"\"Test handling JWT validation timeout\"\"\"\n         # Mock timeout exception\n         import httpx\n+\n         mock_post.side_effect = httpx.TimeoutException(\"Request timeout\")\n-        \n-        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n-        \n+\n+        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n+\n         # Should return 503 Service Unavailable\n         assert response.status_code == 503\n         error_data = response.json()\n         assert \"service temporarily unavailable\" in error_data[\"detail\"].lower()\n-        assert \"timeout\" in error_data[\"detail\"].lower() or \"unavailable\" in error_data[\"detail\"].lower()\n-    \n-    @patch('httpx.AsyncClient.post')\n+        assert (\n+            \"timeout\" in error_data[\"detail\"].lower()\n+            or \"unavailable\" in error_data[\"detail\"].lower()\n+        )\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_jwt_validation_connection_error(self, mock_post, client: TestClient):\n         \"\"\"Test handling Identity Service connection error\"\"\"\n         # Mock connection error\n         import httpx\n+\n         mock_post.side_effect = httpx.ConnectError(\"Connection refused\")\n-        \n-        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n-        \n+\n+        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n+\n         # Should return 503 Service Unavailable\n         assert response.status_code == 503\n         error_data = response.json()\n         assert \"service temporarily unavailable\" in error_data[\"detail\"].lower()\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_jwt_validation_network_error(self, mock_post, client: TestClient):\n         \"\"\"Test handling network errors during validation\"\"\"\n         # Mock network error\n         import httpx\n+\n         mock_post.side_effect = httpx.RequestError(\"Network error\")\n-        \n-        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n-        \n+\n+        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n+\n         # Should return 503 Service Unavailable\n         assert response.status_code == 503\n         error_data = response.json()\n         assert \"service temporarily unavailable\" in error_data[\"detail\"].lower()\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_identity_service_500_error(self, mock_post, client: TestClient):\n         \"\"\"Test handling Identity Service internal server error\"\"\"\n         # Mock 500 response\n         mock_response = AsyncMock()\n         mock_response.status_code = 500\n         mock_response.json.return_value = {\"detail\": \"Internal server error\"}\n         mock_post.return_value = mock_response\n-        \n-        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n-        \n+\n+        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n+\n         # Should return 503 Service Unavailable\n         assert response.status_code == 503\n         error_data = response.json()\n         assert \"service temporarily unavailable\" in error_data[\"detail\"].lower()\n \n \n @pytest.mark.auth\n @pytest.mark.integration\n class TestUserContextExtraction:\n     \"\"\"Test user context extraction from JWT tokens\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_user_context_in_notification_creation(self, mock_post, client: TestClient):\n         \"\"\"Test user context is properly extracted in notification creation\"\"\"\n         # Mock Identity Service response with specific user data\n         user_data = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = user_data\n         mock_post.return_value = mock_response\n-        \n+\n         # Mock Celery task\n-        with patch('tasks.notification_tasks.send_notification') as mock_task:\n+        with patch(\"tasks.notification_tasks.send_notification\") as mock_task:\n             mock_result = MagicMock()\n             mock_result.id = \"task-123\"\n             mock_task.apply_async.return_value = mock_result\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n             notification_data = {\n                 \"type\": \"email\",\n                 \"to\": \"test@example.com\",\n-                \"message\": \"Test message\"\n+                \"message\": \"Test message\",\n             }\n-            \n-            response = client.post(\"/api/v1/notifications\",\n-                                  json=notification_data,\n-                                  headers=headers)\n-            \n+\n+            response = client.post(\n+                \"/api/v1/notifications\", json=notification_data, headers=headers\n+            )\n+\n             assert response.status_code == 200\n-            \n+\n             # Verify user context was passed to task\n             mock_task.apply_async.assert_called_once()\n             call_args = mock_task.apply_async.call_args\n             task_kwargs = call_args[1] if len(call_args) > 1 else call_args.kwargs\n-            \n+\n             # Should contain user information from JWT\n-            assert any(user_data[\"user_id\"] in str(arg) for arg in [call_args, task_kwargs])\n-    \n-    @patch('httpx.AsyncClient.post')\n+            assert any(\n+                user_data[\"user_id\"] in str(arg) for arg in [call_args, task_kwargs]\n+            )\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_organization_context_isolation(self, mock_post, client: TestClient):\n         \"\"\"Test organization context isolation\"\"\"\n         # Mock user from specific organization\n         user_data = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n         user_data[\"organization_id\"] = \"specific-org-123\"\n-        \n-        mock_response = AsyncMock()\n-        mock_response.status_code = 200\n-        mock_response.json.return_value = user_data\n-        mock_post.return_value = mock_response\n-        \n+\n+        mock_response = AsyncMock()\n+        mock_response.status_code = 200\n+        mock_response.json.return_value = user_data\n+        mock_post.return_value = mock_response\n+\n         # Mock in-app provider to verify organization filtering\n-        with patch('providers.in_app.InAppProvider') as mock_provider:\n+        with patch(\"providers.in_app.InAppProvider\") as mock_provider:\n             mock_instance = AsyncMock()\n             mock_instance.get_unread_notifications.return_value = []\n             mock_instance.get_unread_count.return_value = 0\n             mock_provider.return_value = mock_instance\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n             response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n-            \n+\n             assert response.status_code == 200\n-            \n+\n             # Verify provider was called with correct organization context\n             mock_instance.get_unread_notifications.assert_called_once()\n             call_args = mock_instance.get_unread_notifications.call_args\n-            \n+\n             # Should include organization_id in the call\n             assert any(\"specific-org-123\" in str(arg) for arg in call_args)\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_user_permissions_validation(self, mock_post, client: TestClient):\n         \"\"\"Test user permissions are properly validated\"\"\"\n         # Mock user with limited permissions\n         user_data = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n         user_data[\"permissions\"] = [\"notification:read\"]  # No write permission\n-        \n-        mock_response = AsyncMock()\n-        mock_response.status_code = 200\n-        mock_response.json.return_value = user_data\n-        mock_post.return_value = mock_response\n-        \n-        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        \n+\n+        mock_response = AsyncMock()\n+        mock_response.status_code = 200\n+        mock_response.json.return_value = user_data\n+        mock_post.return_value = mock_response\n+\n+        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+\n         # Should succeed for read operation\n         response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n         assert response.status_code == 200\n-        \n+\n         # Should potentially fail for write operation (if permissions are checked)\n         notification_data = {\n             \"type\": \"email\",\n             \"to\": \"test@example.com\",\n-            \"message\": \"Test message\"\n+            \"message\": \"Test message\",\n         }\n-        \n-        with patch('tasks.notification_tasks.send_notification'):\n-            response = client.post(\"/api/v1/notifications\",\n-                                  json=notification_data,\n-                                  headers=headers)\n-            \n+\n+        with patch(\"tasks.notification_tasks.send_notification\"):\n+            response = client.post(\n+                \"/api/v1/notifications\", json=notification_data, headers=headers\n+            )\n+\n             # Depending on implementation, might succeed or fail\n             # This test documents expected behavior\n             assert response.status_code in [200, 403]\n \n \n @pytest.mark.auth\n @pytest.mark.integration\n class TestRoleBasedAccess:\n     \"\"\"Test role-based access control\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_admin_access_to_queue_status(self, mock_post, client: TestClient):\n         \"\"\"Test admin can access queue status\"\"\"\n         # Mock admin user\n         admin_data = IdentityServiceMocks.get_admin_token_validation()[\"json\"]\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = admin_data\n         mock_post.return_value = mock_response\n-        \n+\n         # Mock queue manager\n-        with patch('services.queue_manager.QueueManager') as mock_queue:\n+        with patch(\"services.queue_manager.QueueManager\") as mock_queue:\n             mock_instance = AsyncMock()\n             mock_instance.get_queue_status.return_value = {\n                 \"total_pending\": 10,\n-                \"queues\": {\"normal\": {\"pending\": 10}}\n+                \"queues\": {\"normal\": {\"pending\": 10}},\n             }\n             mock_queue.return_value = mock_instance\n-            \n+\n             headers = {\"Authorization\": \"Bearer admin.jwt.token\"}\n             response = client.get(\"/api/v1/queue/status\", headers=headers)\n-            \n+\n             assert response.status_code == 200\n             result = response.json()\n             assert \"total_pending\" in result\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_regular_user_denied_queue_access(self, mock_post, client: TestClient):\n         \"\"\"Test regular user cannot access queue status\"\"\"\n         # Mock regular user\n         user_data = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = user_data\n         mock_post.return_value = mock_response\n-        \n+\n         headers = {\"Authorization\": \"Bearer user.jwt.token\"}\n         response = client.get(\"/api/v1/queue/status\", headers=headers)\n-        \n+\n         # Should be denied access\n         assert response.status_code == 403\n         error_data = response.json()\n-        assert \"insufficient permissions\" in error_data[\"detail\"].lower() or \\\n-               \"forbidden\" in error_data[\"detail\"].lower()\n-    \n-    @patch('httpx.AsyncClient.post')\n+        assert (\n+            \"insufficient permissions\" in error_data[\"detail\"].lower()\n+            or \"forbidden\" in error_data[\"detail\"].lower()\n+        )\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_admin_template_management(self, mock_post, client: TestClient):\n         \"\"\"Test admin can manage templates\"\"\"\n         # Mock admin user\n         admin_data = IdentityServiceMocks.get_admin_token_validation()[\"json\"]\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = admin_data\n         mock_post.return_value = mock_response\n-        \n+\n         headers = {\"Authorization\": \"Bearer admin.jwt.token\"}\n         template_data = {\n             \"name\": \"test_template\",\n             \"category\": \"system\",\n             \"channel\": \"email\",\n             \"subject\": \"Test {{name}}\",\n-            \"content\": \"Hello {{name}}!\"\n+            \"content\": \"Hello {{name}}!\",\n         }\n-        \n-        response = client.post(\"/api/v1/templates\",\n-                              json=template_data,\n-                              headers=headers)\n-        \n+\n+        response = client.post(\"/api/v1/templates\", json=template_data, headers=headers)\n+\n         # Should succeed for admin\n         assert response.status_code in [200, 201]\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_regular_user_denied_template_creation(self, mock_post, client: TestClient):\n         \"\"\"Test regular user cannot create templates\"\"\"\n         # Mock regular user\n         user_data = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = user_data\n         mock_post.return_value = mock_response\n-        \n+\n         headers = {\"Authorization\": \"Bearer user.jwt.token\"}\n         template_data = {\n             \"name\": \"test_template\",\n-            \"category\": \"system\", \n+            \"category\": \"system\",\n             \"channel\": \"email\",\n             \"subject\": \"Test\",\n-            \"content\": \"Content\"\n+            \"content\": \"Content\",\n         }\n-        \n-        response = client.post(\"/api/v1/templates\",\n-                              json=template_data,\n-                              headers=headers)\n-        \n+\n+        response = client.post(\"/api/v1/templates\", json=template_data, headers=headers)\n+\n         # Should be denied\n         assert response.status_code == 403\n \n \n @pytest.mark.auth\n-@pytest.mark.integration  \n+@pytest.mark.integration\n class TestProtectedEndpoints:\n     \"\"\"Test that all protected endpoints require authentication\"\"\"\n-    \n-    def test_all_protected_endpoints_require_auth(self, client: TestClient, protected_endpoints):\n+\n+    def test_all_protected_endpoints_require_auth(\n+        self, client: TestClient, protected_endpoints\n+    ):\n         \"\"\"Test all protected endpoints reject unauthenticated requests\"\"\"\n         for method, endpoint, data in protected_endpoints:\n             if method == \"GET\":\n                 response = client.get(endpoint)\n             elif method == \"POST\":\n@@ -403,57 +421,61 @@\n                 response = client.delete(endpoint)\n             elif method == \"PATCH\":\n                 response = client.patch(endpoint, json=data)\n             else:\n                 continue\n-            \n-            assert response.status_code == 401, f\"{method} {endpoint} should require authentication\"\n-            \n+\n+            assert (\n+                response.status_code == 401\n+            ), f\"{method} {endpoint} should require authentication\"\n+\n             error_data = response.json()\n             assert \"detail\" in error_data\n             assert \"not authenticated\" in error_data[\"detail\"].lower()\n-            \n+\n             # Should have WWW-Authenticate header\n             assert \"WWW-Authenticate\" in response.headers\n             assert response.headers[\"WWW-Authenticate\"] == \"Bearer\"\n-    \n-    @patch('httpx.AsyncClient.post')\n-    def test_protected_endpoints_with_valid_auth(self, mock_post, client: TestClient, protected_endpoints):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    def test_protected_endpoints_with_valid_auth(\n+        self, mock_post, client: TestClient, protected_endpoints\n+    ):\n         \"\"\"Test protected endpoints accept valid authentication\"\"\"\n         # Mock successful authentication\n         user_data = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = user_data\n         mock_post.return_value = mock_response\n-        \n+\n         # Mock dependencies for endpoints that need them\n-        with patch('tasks.notification_tasks.send_notification') as mock_task, \\\n-             patch('providers.in_app.InAppProvider') as mock_provider, \\\n-             patch('services.queue_manager.QueueManager') as mock_queue:\n-            \n+        with patch(\"tasks.notification_tasks.send_notification\") as mock_task, patch(\n+            \"providers.in_app.InAppProvider\"\n+        ) as mock_provider, patch(\"services.queue_manager.QueueManager\") as mock_queue:\n+\n             # Setup mocks\n             mock_task_result = MagicMock()\n             mock_task_result.id = \"task-123\"\n             mock_task.apply_async.return_value = mock_task_result\n-            \n+\n             mock_provider_instance = AsyncMock()\n             mock_provider_instance.get_unread_notifications.return_value = []\n             mock_provider_instance.get_unread_count.return_value = 0\n             mock_provider.return_value = mock_provider_instance\n-            \n+\n             mock_queue_instance = AsyncMock()\n             mock_queue_instance.get_queue_status.return_value = {\"total_pending\": 0}\n             mock_queue.return_value = mock_queue_instance\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-            \n+\n             for method, endpoint, data in protected_endpoints:\n                 # Skip admin-only endpoints for regular user\n                 if \"/queue/\" in endpoint:\n                     continue\n-                    \n+\n                 if method == \"GET\":\n                     response = client.get(endpoint, headers=headers)\n                 elif method == \"POST\":\n                     response = client.post(endpoint, json=data, headers=headers)\n                 elif method == \"PUT\":\n@@ -462,140 +484,148 @@\n                     response = client.delete(endpoint, headers=headers)\n                 elif method == \"PATCH\":\n                     response = client.patch(endpoint, json=data, headers=headers)\n                 else:\n                     continue\n-                \n+\n                 # Should not be 401 (authentication should pass)\n-                assert response.status_code != 401, f\"{method} {endpoint} should accept valid auth\"\n-                \n+                assert (\n+                    response.status_code != 401\n+                ), f\"{method} {endpoint} should accept valid auth\"\n+\n                 # May be 403 (authorization), 404 (not found), 422 (validation), etc.\n                 # but should not be 401 (authentication)\n                 assert response.status_code in [200, 201, 202, 403, 404, 422, 500]\n \n \n @pytest.mark.auth\n @pytest.mark.integration\n class TestAuthenticationPerformance:\n     \"\"\"Test authentication performance and caching\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_jwt_validation_performance(self, mock_post, client: TestClient):\n         \"\"\"Test JWT validation doesn't add excessive latency\"\"\"\n         # Mock successful validation\n         user_data = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = user_data\n         mock_post.return_value = mock_response\n-        \n+\n         import time\n-        \n-        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        \n+\n+        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+\n         # Make multiple requests to test performance\n         start_time = time.time()\n-        \n+\n         for _ in range(5):\n             response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n             assert response.status_code == 200\n-        \n+\n         end_time = time.time()\n         total_time = end_time - start_time\n-        \n+\n         # Should complete 5 requests reasonably quickly (adjust threshold as needed)\n-        assert total_time < 5.0, f\"Authentication took too long: {total_time}s for 5 requests\"\n-        \n+        assert (\n+            total_time < 5.0\n+        ), f\"Authentication took too long: {total_time}s for 5 requests\"\n+\n         # Should have made 5 calls to Identity Service (unless cached)\n         assert mock_post.call_count <= 5\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_concurrent_authentication_requests(self, mock_post, client: TestClient):\n         \"\"\"Test handling concurrent authentication requests\"\"\"\n         import asyncio\n         import concurrent.futures\n-        \n+\n         # Mock successful validation\n         user_data = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = user_data\n         mock_post.return_value = mock_response\n-        \n+\n         def make_request():\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n             return client.get(\"/api/v1/notifications/unread\", headers=headers)\n-        \n+\n         # Make concurrent requests\n         with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n             futures = [executor.submit(make_request) for _ in range(10)]\n-            responses = [future.result() for future in concurrent.futures.as_completed(futures)]\n-        \n+            responses = [\n+                future.result() for future in concurrent.futures.as_completed(futures)\n+            ]\n+\n         # All requests should succeed\n         for response in responses:\n             assert response.status_code == 200\n-        \n+\n         # Should have handled concurrent requests properly\n         assert len(responses) == 10\n \n \n @pytest.mark.auth\n @pytest.mark.integration\n class TestTokenEdgeCases:\n     \"\"\"Test edge cases in token handling\"\"\"\n-    \n+\n     def test_extremely_long_token(self, client: TestClient):\n         \"\"\"Test handling extremely long JWT tokens\"\"\"\n         # Create very long token\n         long_token = \"a\" * 10000\n         headers = {\"Authorization\": f\"Bearer {long_token}\"}\n-        \n-        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n-        \n+\n+        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n+\n         # Should handle gracefully (reject or process)\n         assert response.status_code in [401, 413, 422]\n-    \n+\n     def test_token_with_special_characters(self, client: TestClient):\n         \"\"\"Test tokens with special characters\"\"\"\n         special_tokens = [\n             \"token.with.dots\",\n-            \"token-with-dashes\", \n+            \"token-with-dashes\",\n             \"token_with_underscores\",\n             \"token+with+plus\",\n             \"token/with/slashes\",\n-            \"token=with=equals\"\n+            \"token=with=equals\",\n         ]\n-        \n+\n         for token in special_tokens:\n             headers = {\"Authorization\": f\"Bearer {token}\"}\n             response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n-            \n+\n             # Should handle gracefully (likely 401 for invalid tokens)\n             assert response.status_code in [401, 422]\n-    \n+\n     def test_multiple_authorization_headers(self, client: TestClient):\n         \"\"\"Test handling multiple Authorization headers\"\"\"\n         headers = {\n             \"Authorization\": \"Bearer first.token\",\n             # Note: This is tricky to test with standard HTTP libraries\n             # as they typically merge duplicate headers\n         }\n-        \n-        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n-        \n+\n+        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n+\n         # Should handle gracefully\n         assert response.status_code in [401, 422]\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_token_validation_response_malformed(self, mock_post, client: TestClient):\n         \"\"\"Test handling malformed validation response from Identity Service\"\"\"\n         # Mock malformed response\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = {\"invalid\": \"response_format\"}  # Missing required fields\n-        mock_post.return_value = mock_response\n-        \n-        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n-        \n+        mock_response.json.return_value = {\n+            \"invalid\": \"response_format\"\n+        }  # Missing required fields\n+        mock_post.return_value = mock_response\n+\n+        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+        response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n+\n         # Should handle malformed response gracefully\n-        assert response.status_code in [401, 503]\n\\ No newline at end of file\n+        assert response.status_code in [401, 503]\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/performance/run_performance_tests.py\t2025-09-09 19:37:33.351565+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/performance/run_performance_tests.py\t2025-09-10 11:37:02.637969+00:00\n@@ -21,451 +21,468 @@\n from concurrent.futures import ThreadPoolExecutor\n \n \n class PerformanceTestRunner:\n     \"\"\"Comprehensive performance test runner and analyzer\"\"\"\n-    \n+\n     def __init__(self, service_url: str = \"http://localhost:8002\"):\n         self.service_url = service_url\n         self.results_dir = Path(\"performance_results\")\n         self.results_dir.mkdir(exist_ok=True)\n         self.test_timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n-        \n+\n     def run_all_performance_tests(self) -> Dict:\n         \"\"\"Run comprehensive performance test suite\"\"\"\n         print(\"\ud83d\ude80 Starting Communication Service Performance Test Suite\")\n         print(f\"\u23f0 Test timestamp: {self.test_timestamp}\")\n         print(f\"\ud83c\udfaf Target service: {self.service_url}\")\n         print(\"=\" * 60)\n-        \n+\n         results = {\n             \"timestamp\": self.test_timestamp,\n             \"service_url\": self.service_url,\n             \"system_info\": self.get_system_info(),\n-            \"tests\": {}\n+            \"tests\": {},\n         }\n-        \n+\n         # 1. Unit performance tests\n         print(\"\\n\ud83d\udcca Running unit performance tests...\")\n         results[\"tests\"][\"unit_performance\"] = self.run_unit_performance_tests()\n-        \n+\n         # 2. API endpoint benchmarks\n         print(\"\\n\ud83c\udf10 Running API endpoint benchmarks...\")\n         results[\"tests\"][\"api_benchmarks\"] = self.run_api_benchmarks()\n-        \n+\n         # 3. Database performance tests\n         print(\"\\n\ud83d\uddc4\ufe0f Running database performance tests...\")\n         results[\"tests\"][\"database_performance\"] = self.run_database_performance_tests()\n-        \n+\n         # 4. Queue performance tests\n         print(\"\\n\ud83d\udcec Running queue performance tests...\")\n         results[\"tests\"][\"queue_performance\"] = self.run_queue_performance_tests()\n-        \n+\n         # 5. Load testing with Locust\n         print(\"\\n\ud83d\udd25 Running load tests...\")\n         results[\"tests\"][\"load_testing\"] = self.run_load_tests()\n-        \n+\n         # 6. Memory and resource monitoring\n         print(\"\\n\ud83d\udcbe Running memory and resource tests...\")\n         results[\"tests\"][\"resource_monitoring\"] = self.run_resource_tests()\n-        \n+\n         # 7. Generate performance report\n         print(\"\\n\ud83d\udcc8 Generating performance report...\")\n         self.generate_performance_report(results)\n-        \n+\n         print(f\"\\n\u2705 Performance testing complete! Results saved to {self.results_dir}\")\n         return results\n-    \n+\n     def get_system_info(self) -> Dict:\n         \"\"\"Collect system information for performance context\"\"\"\n         return {\n             \"cpu_count\": psutil.cpu_count(),\n             \"cpu_percent\": psutil.cpu_percent(interval=1),\n             \"memory_total\": psutil.virtual_memory().total / (1024**3),  # GB\n             \"memory_available\": psutil.virtual_memory().available / (1024**3),  # GB\n             \"python_version\": sys.version,\n-            \"platform\": sys.platform\n+            \"platform\": sys.platform,\n         }\n-    \n+\n     def run_unit_performance_tests(self) -> Dict:\n         \"\"\"Run pytest-based performance tests\"\"\"\n         try:\n             # Run performance-marked tests\n             cmd = [\n-                \"pytest\", \n+                \"pytest\",\n                 \"tests/performance/test_load_testing.py\",\n-                \"-m\", \"performance\",\n+                \"-m\",\n+                \"performance\",\n                 \"-v\",\n                 \"--tb=short\",\n-                \"--benchmark-json=performance_results/benchmark_results.json\"\n+                \"--benchmark-json=performance_results/benchmark_results.json\",\n             ]\n-            \n+\n             result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)\n-            \n+\n             return {\n                 \"status\": \"completed\" if result.returncode == 0 else \"failed\",\n                 \"exit_code\": result.returncode,\n                 \"stdout\": result.stdout,\n                 \"stderr\": result.stderr,\n-                \"duration\": \"5m\"  # Approximate\n+                \"duration\": \"5m\",  # Approximate\n             }\n         except Exception as e:\n-            return {\n-                \"status\": \"error\",\n-                \"error\": str(e)\n-            }\n-    \n+            return {\"status\": \"error\", \"error\": str(e)}\n+\n     def run_api_benchmarks(self) -> Dict:\n         \"\"\"Benchmark API endpoint performance\"\"\"\n         import httpx\n-        \n+\n         endpoints = [\n             {\n                 \"name\": \"health_check\",\n                 \"method\": \"GET\",\n                 \"url\": \"/health\",\n-                \"auth_required\": False\n+                \"auth_required\": False,\n             },\n             {\n                 \"name\": \"metrics\",\n-                \"method\": \"GET\", \n+                \"method\": \"GET\",\n                 \"url\": \"/metrics\",\n-                \"auth_required\": False\n+                \"auth_required\": False,\n             },\n             {\n                 \"name\": \"send_notification\",\n                 \"method\": \"POST\",\n                 \"url\": \"/api/v1/notifications\",\n                 \"auth_required\": True,\n                 \"data\": {\n                     \"type\": \"email\",\n                     \"to\": \"benchmark@example.com\",\n                     \"subject\": \"Benchmark Test\",\n-                    \"message\": \"API benchmark testing\"\n-                }\n-            }\n+                    \"message\": \"API benchmark testing\",\n+                },\n+            },\n         ]\n-        \n+\n         results = {}\n         headers = {\"Authorization\": \"Bearer benchmark.test.token\"}\n-        \n+\n         for endpoint in endpoints:\n             print(f\"  \ud83d\udccd Benchmarking {endpoint['name']}...\")\n-            \n+\n             response_times = []\n             success_count = 0\n-            \n+\n             try:\n                 with httpx.Client(base_url=self.service_url, timeout=10.0) as client:\n                     for i in range(20):  # 20 requests per endpoint\n                         start_time = time.time()\n-                        \n+\n                         if endpoint[\"method\"] == \"GET\":\n                             response = client.get(\n                                 endpoint[\"url\"],\n-                                headers=headers if endpoint[\"auth_required\"] else None\n+                                headers=headers if endpoint[\"auth_required\"] else None,\n                             )\n                         else:  # POST\n                             response = client.post(\n                                 endpoint[\"url\"],\n                                 json=endpoint.get(\"data\", {}),\n-                                headers=headers if endpoint[\"auth_required\"] else None\n+                                headers=headers if endpoint[\"auth_required\"] else None,\n                             )\n-                        \n+\n                         response_time = time.time() - start_time\n                         response_times.append(response_time)\n-                        \n+\n                         if response.status_code < 400:\n                             success_count += 1\n-                \n+\n                 results[endpoint[\"name\"]] = {\n                     \"avg_response_time\": statistics.mean(response_times),\n                     \"min_response_time\": min(response_times),\n                     \"max_response_time\": max(response_times),\n                     \"p95_response_time\": statistics.quantiles(response_times, n=20)[18],\n                     \"success_rate\": success_count / len(response_times) * 100,\n-                    \"total_requests\": len(response_times)\n+                    \"total_requests\": len(response_times),\n                 }\n-                \n+\n             except Exception as e:\n-                results[endpoint[\"name\"]] = {\n-                    \"error\": str(e),\n-                    \"status\": \"failed\"\n-                }\n-        \n+                results[endpoint[\"name\"]] = {\"error\": str(e), \"status\": \"failed\"}\n+\n         return results\n-    \n+\n     def run_database_performance_tests(self) -> Dict:\n         \"\"\"Run database-specific performance tests\"\"\"\n         try:\n             cmd = [\n                 \"pytest\",\n                 \"tests/performance/test_load_testing.py::TestDatabasePerformance\",\n                 \"-v\",\n-                \"--tb=short\"\n+                \"--tb=short\",\n             ]\n-            \n+\n             result = subprocess.run(cmd, capture_output=True, text=True, timeout=180)\n-            \n+\n             return {\n                 \"status\": \"completed\" if result.returncode == 0 else \"failed\",\n                 \"exit_code\": result.returncode,\n                 \"summary\": \"Database performance tests completed\",\n-                \"details\": result.stdout\n+                \"details\": result.stdout,\n             }\n         except Exception as e:\n-            return {\n-                \"status\": \"error\",\n-                \"error\": str(e)\n-            }\n-    \n+            return {\"status\": \"error\", \"error\": str(e)}\n+\n     def run_queue_performance_tests(self) -> Dict:\n         \"\"\"Run Celery queue performance tests\"\"\"\n         try:\n             cmd = [\n                 \"pytest\",\n                 \"tests/performance/test_load_testing.py::TestCeleryQueuePerformance\",\n                 \"-v\",\n-                \"--tb=short\"\n+                \"--tb=short\",\n             ]\n-            \n+\n             result = subprocess.run(cmd, capture_output=True, text=True, timeout=180)\n-            \n+\n             return {\n                 \"status\": \"completed\" if result.returncode == 0 else \"failed\",\n                 \"exit_code\": result.returncode,\n                 \"summary\": \"Queue performance tests completed\",\n-                \"details\": result.stdout\n+                \"details\": result.stdout,\n             }\n         except Exception as e:\n-            return {\n-                \"status\": \"error\", \n-                \"error\": str(e)\n-            }\n-    \n+            return {\"status\": \"error\", \"error\": str(e)}\n+\n     def run_load_tests(self) -> Dict:\n         \"\"\"Run Locust-based load testing\"\"\"\n         load_test_results = {}\n-        \n+\n         test_scenarios = [\n             {\n                 \"name\": \"baseline_load\",\n                 \"users\": 10,\n                 \"spawn_rate\": 2,\n                 \"duration\": \"2m\",\n-                \"description\": \"Baseline load test\"\n+                \"description\": \"Baseline load test\",\n             },\n             {\n-                \"name\": \"moderate_load\", \n+                \"name\": \"moderate_load\",\n                 \"users\": 50,\n                 \"spawn_rate\": 5,\n                 \"duration\": \"3m\",\n-                \"description\": \"Moderate load test\"\n+                \"description\": \"Moderate load test\",\n             },\n             {\n                 \"name\": \"spike_test\",\n                 \"users\": 100,\n                 \"spawn_rate\": 25,\n                 \"duration\": \"1m\",\n-                \"description\": \"Spike load test\"\n-            }\n+                \"description\": \"Spike load test\",\n+            },\n         ]\n-        \n+\n         for scenario in test_scenarios:\n             print(f\"  \ud83d\udd25 Running {scenario['name']} ({scenario['description']})...\")\n-            \n+\n             try:\n                 cmd = [\n                     \"locust\",\n-                    \"-f\", \"tests/performance/locustfile.py\",\n-                    \"--host\", self.service_url,\n-                    \"--users\", str(scenario[\"users\"]),\n-                    \"--spawn-rate\", str(scenario[\"spawn_rate\"]),\n-                    \"-t\", scenario[\"duration\"],\n+                    \"-f\",\n+                    \"tests/performance/locustfile.py\",\n+                    \"--host\",\n+                    self.service_url,\n+                    \"--users\",\n+                    str(scenario[\"users\"]),\n+                    \"--spawn-rate\",\n+                    str(scenario[\"spawn_rate\"]),\n+                    \"-t\",\n+                    scenario[\"duration\"],\n                     \"--headless\",\n-                    \"--csv\", f\"performance_results/{scenario['name']}_{self.test_timestamp}\"\n+                    \"--csv\",\n+                    f\"performance_results/{scenario['name']}_{self.test_timestamp}\",\n                 ]\n-                \n-                result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)\n-                \n+\n+                result = subprocess.run(\n+                    cmd, capture_output=True, text=True, timeout=300\n+                )\n+\n                 load_test_results[scenario[\"name\"]] = {\n                     \"status\": \"completed\" if result.returncode == 0 else \"failed\",\n                     \"exit_code\": result.returncode,\n                     \"users\": scenario[\"users\"],\n                     \"spawn_rate\": scenario[\"spawn_rate\"],\n                     \"duration\": scenario[\"duration\"],\n-                    \"output\": result.stdout\n+                    \"output\": result.stdout,\n                 }\n-                \n+\n                 # Parse CSV results if available\n-                csv_file = Path(f\"performance_results/{scenario['name']}_{self.test_timestamp}_stats.csv\")\n+                csv_file = Path(\n+                    f\"performance_results/{scenario['name']}_{self.test_timestamp}_stats.csv\"\n+                )\n                 if csv_file.exists():\n                     load_test_results[scenario[\"name\"]][\"csv_results\"] = str(csv_file)\n-                \n+\n             except Exception as e:\n                 load_test_results[scenario[\"name\"]] = {\n                     \"status\": \"error\",\n-                    \"error\": str(e)\n+                    \"error\": str(e),\n                 }\n-        \n+\n         return load_test_results\n-    \n+\n     def run_resource_tests(self) -> Dict:\n         \"\"\"Monitor resource usage during performance tests\"\"\"\n         # Start monitoring\n         process = psutil.Process(os.getpid())\n         initial_memory = process.memory_info().rss / 1024 / 1024  # MB\n         initial_cpu = process.cpu_percent()\n-        \n+\n         # Wait a bit to measure baseline\n         time.sleep(2)\n-        \n+\n         # Measure resource usage\n         memory_samples = []\n         cpu_samples = []\n-        \n+\n         for _ in range(30):  # Sample for 30 seconds\n             memory_samples.append(process.memory_info().rss / 1024 / 1024)\n             cpu_samples.append(process.cpu_percent())\n             time.sleep(1)\n-        \n+\n         return {\n             \"initial_memory_mb\": initial_memory,\n             \"avg_memory_mb\": statistics.mean(memory_samples),\n             \"max_memory_mb\": max(memory_samples),\n             \"memory_growth_mb\": max(memory_samples) - initial_memory,\n             \"avg_cpu_percent\": statistics.mean(cpu_samples),\n             \"max_cpu_percent\": max(cpu_samples),\n-            \"monitoring_duration\": \"30s\"\n+            \"monitoring_duration\": \"30s\",\n         }\n-    \n+\n     def generate_performance_report(self, results: Dict) -> None:\n         \"\"\"Generate comprehensive performance report\"\"\"\n-        report_file = self.results_dir / f\"performance_report_{self.test_timestamp}.json\"\n-        \n+        report_file = (\n+            self.results_dir / f\"performance_report_{self.test_timestamp}.json\"\n+        )\n+\n         # Save detailed results\n-        with open(report_file, 'w') as f:\n+        with open(report_file, \"w\") as f:\n             json.dump(results, f, indent=2, default=str)\n-        \n+\n         # Generate summary report\n-        summary_file = self.results_dir / f\"performance_summary_{self.test_timestamp}.md\"\n-        \n-        with open(summary_file, 'w') as f:\n+        summary_file = (\n+            self.results_dir / f\"performance_summary_{self.test_timestamp}.md\"\n+        )\n+\n+        with open(summary_file, \"w\") as f:\n             f.write(f\"# Communication Service Performance Report\\n\\n\")\n             f.write(f\"**Generated:** {results['timestamp']}\\n\")\n             f.write(f\"**Service URL:** {results['service_url']}\\n\\n\")\n-            \n+\n             # System info\n             f.write(\"## System Information\\n\\n\")\n-            sys_info = results['system_info']\n+            sys_info = results[\"system_info\"]\n             f.write(f\"- **CPU Cores:** {sys_info['cpu_count']}\\n\")\n             f.write(f\"- **Memory Total:** {sys_info['memory_total']:.1f} GB\\n\")\n             f.write(f\"- **Memory Available:** {sys_info['memory_available']:.1f} GB\\n\")\n             f.write(f\"- **Python Version:** {sys_info['python_version']}\\n\\n\")\n-            \n+\n             # API benchmarks\n-            if 'api_benchmarks' in results['tests']:\n+            if \"api_benchmarks\" in results[\"tests\"]:\n                 f.write(\"## API Performance Benchmarks\\n\\n\")\n-                for endpoint, metrics in results['tests']['api_benchmarks'].items():\n-                    if 'avg_response_time' in metrics:\n+                for endpoint, metrics in results[\"tests\"][\"api_benchmarks\"].items():\n+                    if \"avg_response_time\" in metrics:\n                         f.write(f\"### {endpoint}\\n\")\n-                        f.write(f\"- **Average Response Time:** {metrics['avg_response_time']:.3f}s\\n\")\n-                        f.write(f\"- **95th Percentile:** {metrics['p95_response_time']:.3f}s\\n\")\n-                        f.write(f\"- **Success Rate:** {metrics['success_rate']:.1f}%\\n\\n\")\n-            \n+                        f.write(\n+                            f\"- **Average Response Time:** {metrics['avg_response_time']:.3f}s\\n\"\n+                        )\n+                        f.write(\n+                            f\"- **95th Percentile:** {metrics['p95_response_time']:.3f}s\\n\"\n+                        )\n+                        f.write(\n+                            f\"- **Success Rate:** {metrics['success_rate']:.1f}%\\n\\n\"\n+                        )\n+\n             # Load test results\n-            if 'load_testing' in results['tests']:\n+            if \"load_testing\" in results[\"tests\"]:\n                 f.write(\"## Load Testing Results\\n\\n\")\n-                for test_name, test_results in results['tests']['load_testing'].items():\n-                    if test_results['status'] == 'completed':\n+                for test_name, test_results in results[\"tests\"][\"load_testing\"].items():\n+                    if test_results[\"status\"] == \"completed\":\n                         f.write(f\"### {test_name}\\n\")\n                         f.write(f\"- **Users:** {test_results['users']}\\n\")\n                         f.write(f\"- **Duration:** {test_results['duration']}\\n\")\n                         f.write(f\"- **Status:** \u2705 {test_results['status']}\\n\\n\")\n-            \n+\n             # Resource monitoring\n-            if 'resource_monitoring' in results['tests']:\n+            if \"resource_monitoring\" in results[\"tests\"]:\n                 f.write(\"## Resource Monitoring\\n\\n\")\n-                res_mon = results['tests']['resource_monitoring']\n-                f.write(f\"- **Average Memory Usage:** {res_mon['avg_memory_mb']:.1f} MB\\n\")\n+                res_mon = results[\"tests\"][\"resource_monitoring\"]\n+                f.write(\n+                    f\"- **Average Memory Usage:** {res_mon['avg_memory_mb']:.1f} MB\\n\"\n+                )\n                 f.write(f\"- **Peak Memory Usage:** {res_mon['max_memory_mb']:.1f} MB\\n\")\n                 f.write(f\"- **Memory Growth:** {res_mon['memory_growth_mb']:.1f} MB\\n\")\n-                f.write(f\"- **Average CPU Usage:** {res_mon['avg_cpu_percent']:.1f}%\\n\\n\")\n-            \n+                f.write(\n+                    f\"- **Average CPU Usage:** {res_mon['avg_cpu_percent']:.1f}%\\n\\n\"\n+                )\n+\n             # Performance recommendations\n             f.write(\"## Performance Recommendations\\n\\n\")\n             f.write(self.generate_recommendations(results))\n-        \n+\n         print(f\"  \ud83d\udcc4 Detailed report: {report_file}\")\n         print(f\"  \ud83d\udccb Summary report: {summary_file}\")\n-    \n+\n     def generate_recommendations(self, results: Dict) -> str:\n         \"\"\"Generate performance recommendations based on test results\"\"\"\n         recommendations = []\n-        \n+\n         # Check API performance\n-        if 'api_benchmarks' in results['tests']:\n-            for endpoint, metrics in results['tests']['api_benchmarks'].items():\n-                if isinstance(metrics, dict) and 'avg_response_time' in metrics:\n-                    if metrics['avg_response_time'] > 0.5:\n+        if \"api_benchmarks\" in results[\"tests\"]:\n+            for endpoint, metrics in results[\"tests\"][\"api_benchmarks\"].items():\n+                if isinstance(metrics, dict) and \"avg_response_time\" in metrics:\n+                    if metrics[\"avg_response_time\"] > 0.5:\n                         recommendations.append(\n                             f\"\u26a0\ufe0f **{endpoint}** response time is high ({metrics['avg_response_time']:.3f}s). \"\n                             \"Consider optimization or caching.\"\n                         )\n-                    if metrics['success_rate'] < 95:\n+                    if metrics[\"success_rate\"] < 95:\n                         recommendations.append(\n                             f\"\ud83d\udea8 **{endpoint}** success rate is low ({metrics['success_rate']:.1f}%). \"\n                             \"Investigate error handling and stability.\"\n                         )\n-        \n+\n         # Check resource usage\n-        if 'resource_monitoring' in results['tests']:\n-            res_mon = results['tests']['resource_monitoring']\n-            if res_mon['memory_growth_mb'] > 50:\n+        if \"resource_monitoring\" in results[\"tests\"]:\n+            res_mon = results[\"tests\"][\"resource_monitoring\"]\n+            if res_mon[\"memory_growth_mb\"] > 50:\n                 recommendations.append(\n                     f\"\ud83d\udcbe High memory growth detected ({res_mon['memory_growth_mb']:.1f} MB). \"\n                     \"Check for memory leaks.\"\n                 )\n-            if res_mon['max_cpu_percent'] > 80:\n+            if res_mon[\"max_cpu_percent\"] > 80:\n                 recommendations.append(\n                     f\"\ud83d\udd25 High CPU usage detected ({res_mon['max_cpu_percent']:.1f}%). \"\n                     \"Consider performance optimization.\"\n                 )\n-        \n+\n         if not recommendations:\n-            recommendations.append(\"\u2705 All performance metrics are within acceptable ranges.\")\n-        \n+            recommendations.append(\n+                \"\u2705 All performance metrics are within acceptable ranges.\"\n+            )\n+\n         return \"\\n\".join([f\"- {rec}\" for rec in recommendations])\n \n \n def main():\n     \"\"\"Main performance testing entry point\"\"\"\n-    parser = argparse.ArgumentParser(description=\"Communication Service Performance Testing\")\n+    parser = argparse.ArgumentParser(\n+        description=\"Communication Service Performance Testing\"\n+    )\n     parser.add_argument(\n-        \"--service-url\", \n+        \"--service-url\",\n         default=\"http://localhost:8002\",\n-        help=\"URL of the communication service to test\"\n+        help=\"URL of the communication service to test\",\n     )\n     parser.add_argument(\n         \"--test-type\",\n         choices=[\"all\", \"unit\", \"api\", \"load\", \"database\", \"queue\", \"resources\"],\n         default=\"all\",\n-        help=\"Type of performance tests to run\"\n+        help=\"Type of performance tests to run\",\n     )\n     parser.add_argument(\n         \"--output-dir\",\n         default=\"performance_results\",\n-        help=\"Directory to store performance test results\"\n+        help=\"Directory to store performance test results\",\n     )\n-    \n+\n     args = parser.parse_args()\n-    \n+\n     # Create performance test runner\n     runner = PerformanceTestRunner(service_url=args.service_url)\n     runner.results_dir = Path(args.output_dir)\n     runner.results_dir.mkdir(exist_ok=True)\n-    \n+\n     # Run selected tests\n     if args.test_type == \"all\":\n         results = runner.run_all_performance_tests()\n     else:\n         # Run specific test type\n@@ -480,19 +497,21 @@\n             results = {\"database_performance\": runner.run_database_performance_tests()}\n         elif args.test_type == \"queue\":\n             results = {\"queue_performance\": runner.run_queue_performance_tests()}\n         elif args.test_type == \"resources\":\n             results = {\"resource_monitoring\": runner.run_resource_tests()}\n-        \n-        runner.generate_performance_report({\n-            \"timestamp\": runner.test_timestamp,\n-            \"service_url\": args.service_url,\n-            \"system_info\": runner.get_system_info(),\n-            \"tests\": results\n-        })\n-    \n+\n+        runner.generate_performance_report(\n+            {\n+                \"timestamp\": runner.test_timestamp,\n+                \"service_url\": args.service_url,\n+                \"system_info\": runner.get_system_info(),\n+                \"tests\": results,\n+            }\n+        )\n+\n     print(\"\\n\ud83c\udf89 Performance testing completed successfully!\")\n     return 0\n \n \n if __name__ == \"__main__\":\n-    sys.exit(main())\n\\ No newline at end of file\n+    sys.exit(main())\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_endpoints_security.py\t2025-09-09 13:55:54.641518+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_endpoints_security.py\t2025-09-10 11:37:02.708549+00:00\n@@ -1,217 +1,254 @@\n \"\"\"\n Test Endpoint Security and Protection\n Ensures all API endpoints properly enforce authentication\n \"\"\"\n+\n import pytest\n from fastapi.testclient import TestClient\n from unittest.mock import patch, AsyncMock\n from main import app\n \n+\n class TestEndpointProtection:\n     \"\"\"Test that all endpoints require authentication except health\"\"\"\n-    \n+\n     def test_health_endpoint_no_auth_required(self):\n         \"\"\"Test that /health endpoint is accessible without authentication\"\"\"\n         client = TestClient(app)\n         response = client.get(\"/health\")\n-        \n+\n         # Health endpoint should work without auth\n         assert response.status_code == 200\n         assert \"service\" in response.json()\n         assert response.json()[\"service\"] == \"communication-service\"\n-    \n+\n     def test_protected_endpoints_require_auth(self):\n         \"\"\"Test that all API endpoints require authentication\"\"\"\n         client = TestClient(app)\n-        \n+\n         # List all protected endpoints\n         protected_endpoints = [\n-            (\"POST\", \"/api/v1/notifications\", {\"type\": \"email\", \"to\": \"test@example.com\", \"message\": \"test\"}),\n+            (\n+                \"POST\",\n+                \"/api/v1/notifications\",\n+                {\"type\": \"email\", \"to\": \"test@example.com\", \"message\": \"test\"},\n+            ),\n             (\"GET\", \"/api/v1/notifications/unread\", None),\n             (\"POST\", \"/api/v1/messages\", {\"to_user_id\": \"123\", \"message\": \"test\"}),\n             (\"GET\", \"/api/v1/conversations\", None),\n             (\"GET\", \"/api/v1/conversations/test-id\", None),\n             (\"POST\", \"/api/v1/templates\", {\"name\": \"test\"}),\n             (\"GET\", \"/api/v1/templates\", None),\n             (\"GET\", \"/api/v1/queue/status\", None),\n         ]\n-        \n+\n         for method, endpoint, data in protected_endpoints:\n             if method == \"GET\":\n                 response = client.get(endpoint)\n             elif method == \"POST\":\n                 response = client.post(endpoint, json=data)\n-            \n+\n             # All should return 401 or 403 without auth (FastAPI HTTPBearer behavior)\n-            assert response.status_code in [401, 403], f\"Endpoint {method} {endpoint} should require authentication\"\n+            assert response.status_code in [\n+                401,\n+                403,\n+            ], f\"Endpoint {method} {endpoint} should require authentication\"\n             assert \"Not authenticated\" in response.json().get(\"detail\", \"\")\n-    \n+\n     def test_invalid_auth_header_format(self):\n         \"\"\"Test various invalid Authorization header formats\"\"\"\n         client = TestClient(app)\n-        \n+\n         invalid_headers = [\n             {\"Authorization\": \"InvalidFormat token\"},\n             {\"Authorization\": \"Bearer\"},  # Missing token\n             {\"Authorization\": \"Bearer \"},  # Empty token\n             {\"Authorization\": \"Basic dGVzdA==\"},  # Wrong auth type\n             {\"Authorization\": \"\"},  # Empty header\n         ]\n-        \n+\n         for headers in invalid_headers:\n             response = client.get(\"/api/v1/templates\", headers=headers)\n-            assert response.status_code == 422 or response.status_code == 401, f\"Invalid header should be rejected: {headers}\"\n-    \n-    @patch('main.httpx.AsyncClient')\n+            assert (\n+                response.status_code == 422 or response.status_code == 401\n+            ), f\"Invalid header should be rejected: {headers}\"\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_all_endpoints_use_user_context(self, mock_client):\n         \"\"\"Test that all authenticated endpoints receive and use user context\"\"\"\n         # Mock successful authentication\n         mock_user_data = {\n             \"user_id\": \"test-user-123\",\n             \"organization_id\": \"org-456\",\n             \"email\": \"test@example.com\",\n             \"roles\": [\"user\"],\n-            \"permissions\": [\"read\", \"write\"]\n+            \"permissions\": [\"read\", \"write\"],\n         }\n-        \n+\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = mock_user_data\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n         client = TestClient(app)\n         headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        \n+\n         # Test endpoints that should include user context in response\n         test_cases = [\n-            (\"POST\", \"/api/v1/notifications\", {\"type\": \"email\", \"to\": \"test@example.com\", \"message\": \"test\"}),\n+            (\n+                \"POST\",\n+                \"/api/v1/notifications\",\n+                {\"type\": \"email\", \"to\": \"test@example.com\", \"message\": \"test\"},\n+            ),\n             (\"GET\", \"/api/v1/notifications/unread\", None),\n             (\"POST\", \"/api/v1/messages\", {\"to_user_id\": \"123\", \"message\": \"test\"}),\n             (\"GET\", \"/api/v1/conversations\", None),\n             (\"GET\", \"/api/v1/conversations/test-id\", None),\n             (\"POST\", \"/api/v1/templates\", {\"name\": \"test\"}),\n             (\"GET\", \"/api/v1/templates\", None),\n             (\"GET\", \"/api/v1/queue/status\", None),\n         ]\n-        \n+\n         for method, endpoint, data in test_cases:\n             if method == \"GET\":\n                 response = client.get(endpoint, headers=headers)\n             elif method == \"POST\":\n                 response = client.post(endpoint, headers=headers, json=data)\n-            \n-            assert response.status_code == 200, f\"Endpoint {method} {endpoint} should accept valid auth\"\n-            \n+\n+            assert (\n+                response.status_code == 200\n+            ), f\"Endpoint {method} {endpoint} should accept valid auth\"\n+\n             # Verify user context is included in response\n             response_data = response.json()\n-            assert \"user_id\" in response_data or \"sent_by\" in response_data or \"requested_by\" in response_data, \\\n-                f\"Endpoint {method} {endpoint} should include user context\"\n+            assert (\n+                \"user_id\" in response_data\n+                or \"sent_by\" in response_data\n+                or \"requested_by\" in response_data\n+            ), f\"Endpoint {method} {endpoint} should include user context\"\n+\n \n class TestAuthorizationHeaders:\n     \"\"\"Test WWW-Authenticate headers in responses\"\"\"\n-    \n+\n     def test_unauthorized_responses_include_www_authenticate(self):\n         \"\"\"Test that 401 responses include proper WWW-Authenticate header\"\"\"\n         client = TestClient(app)\n-        \n+\n         endpoints_to_test = [\n             \"/api/v1/notifications\",\n-            \"/api/v1/notifications/unread\", \n-            \"/api/v1/templates\"\n-        ]\n-        \n+            \"/api/v1/notifications/unread\",\n+            \"/api/v1/templates\",\n+        ]\n+\n         for endpoint in endpoints_to_test:\n             response = client.get(endpoint)\n-            \n+\n             # FastAPI HTTPBearer returns 403 for missing auth, 401 for invalid auth\n             assert response.status_code in [401, 403]\n             # WWW-Authenticate header might not be present for 403 responses\n             if response.status_code == 401:\n                 assert \"WWW-Authenticate\" in response.headers\n                 assert response.headers[\"WWW-Authenticate\"] == \"Bearer\"\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_identity_service_401_preserves_www_authenticate(self, mock_client):\n         \"\"\"Test that Identity Service 401 responses preserve WWW-Authenticate header\"\"\"\n         # Mock Identity Service rejection\n         mock_response = AsyncMock()\n         mock_response.status_code = 401\n         mock_response.json.return_value = {\"detail\": \"Invalid token\"}\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n-        client = TestClient(app)\n-        response = client.get(\"/api/v1/templates\", headers={\"Authorization\": \"Bearer invalid.token\"})\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n+        client = TestClient(app)\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer invalid.token\"}\n+        )\n+\n         assert response.status_code == 401\n         assert \"WWW-Authenticate\" in response.headers\n         assert response.headers[\"WWW-Authenticate\"] == \"Bearer\"\n \n+\n class TestSecurityHeaders:\n     \"\"\"Test security-related headers and responses\"\"\"\n-    \n+\n     def test_no_sensitive_data_in_error_responses(self):\n         \"\"\"Test that error responses don't leak sensitive information\"\"\"\n         client = TestClient(app)\n-        \n+\n         response = client.get(\"/api/v1/templates\")\n-        \n+\n         assert response.status_code in [401, 403]  # FastAPI HTTPBearer behavior\n         error_detail = response.json().get(\"detail\", \"\")\n-        \n+\n         # Ensure no sensitive data is leaked\n         assert \"password\" not in error_detail.lower()\n         assert \"secret\" not in error_detail.lower()\n         assert \"key\" not in error_detail.lower()\n-        assert \"token\" not in error_detail.lower() or \"token\" in error_detail.lower()  # \"token\" can appear in error message\n-    \n-    @patch('main.httpx.AsyncClient')\n+        assert (\n+            \"token\" not in error_detail.lower() or \"token\" in error_detail.lower()\n+        )  # \"token\" can appear in error message\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_user_data_not_logged_in_errors(self, mock_client):\n         \"\"\"Test that user data is not exposed in error conditions\"\"\"\n         # Mock network error\n-        mock_client.return_value.__aenter__.return_value.post.side_effect = Exception(\"Network error\")\n-        \n-        client = TestClient(app)\n-        response = client.get(\"/api/v1/templates\", headers={\"Authorization\": \"Bearer some.token\"})\n-        \n+        mock_client.return_value.__aenter__.return_value.post.side_effect = Exception(\n+            \"Network error\"\n+        )\n+\n+        client = TestClient(app)\n+        response = client.get(\n+            \"/api/v1/templates\", headers={\"Authorization\": \"Bearer some.token\"}\n+        )\n+\n         assert response.status_code == 401\n-        \n+\n         # Response should not contain any user data\n         response_text = response.text.lower()\n         assert \"user_id\" not in response_text\n         assert \"email\" not in response_text\n         assert \"organization\" not in response_text\n \n+\n class TestConcurrentAuthentication:\n     \"\"\"Test authentication under concurrent load\"\"\"\n-    \n-    @patch('main.httpx.AsyncClient')\n+\n+    @patch(\"main.httpx.AsyncClient\")\n     def test_concurrent_auth_requests(self, mock_client):\n         \"\"\"Test that concurrent authentication requests are handled properly\"\"\"\n         import asyncio\n         import httpx\n-        \n+\n         # Mock successful response\n         mock_user_data = {\"user_id\": \"test-user\", \"organization_id\": \"org-123\"}\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = mock_user_data\n-        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response\n-        \n+        mock_client.return_value.__aenter__.return_value.post.return_value = (\n+            mock_response\n+        )\n+\n         client = TestClient(app)\n         headers = {\"Authorization\": \"Bearer valid.token\"}\n-        \n+\n         # Make multiple concurrent requests\n         async def make_request():\n             async with httpx.AsyncClient(app=app) as async_client:\n                 return await async_client.get(\"/api/v1/templates\", headers=headers)\n-        \n+\n         # Test concurrent authentication (simplified for sync test environment)\n         response = client.get(\"/api/v1/templates\", headers=headers)\n         assert response.status_code == 200\n-        \n+\n         # Verify Identity Service was called\n         mock_client.return_value.__aenter__.return_value.post.assert_called_with(\n             \"http://localhost:8001/auth/validate\",\n             headers={\"Authorization\": \"Bearer valid.token\"},\n-            timeout=5.0\n-        )\n\\ No newline at end of file\n+            timeout=5.0,\n+        )\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/integration/test_end_to_end_flows.py\t2025-09-09 19:28:08.547947+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/integration/test_end_to_end_flows.py\t2025-09-10 11:37:02.707452+00:00\n@@ -11,50 +11,55 @@\n from unittest.mock import patch, AsyncMock, MagicMock, call\n from fastapi.testclient import TestClient\n \n from tests.fixtures.sample_data import SampleNotificationData, SampleAPIData\n from tests.fixtures.mock_responses import (\n-    IdentityServiceMocks, \n-    EmailProviderMocks, \n+    IdentityServiceMocks,\n+    EmailProviderMocks,\n     SMSProviderMocks,\n-    PushProviderMocks\n+    PushProviderMocks,\n )\n \n \n @pytest.mark.integration\n @pytest.mark.e2e\n class TestCompleteNotificationFlows:\n     \"\"\"End-to-end tests for complete notification delivery flows\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n-    @patch('providers.email.EmailProvider.send')\n-    @patch('tasks.notification_tasks.send_notification')\n-    def test_complete_email_notification_flow(self, mock_task, mock_email_send, mock_identity, client: TestClient):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    @patch(\"providers.email.EmailProvider.send\")\n+    @patch(\"tasks.notification_tasks.send_notification\")\n+    def test_complete_email_notification_flow(\n+        self, mock_task, mock_email_send, mock_identity, client: TestClient\n+    ):\n         \"\"\"Test complete email notification flow from API to delivery confirmation\"\"\"\n         # Step 1: Mock Identity Service validation\n         mock_identity_response = AsyncMock()\n         mock_identity_response.status_code = 200\n-        mock_identity_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_identity_response\n-        \n+        mock_identity_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_identity_response\n+\n         # Step 2: Mock successful email provider response\n         mock_email_send.return_value = {\n             \"success\": True,\n             \"provider_message_id\": \"email-123-456\",\n-            \"delivery_status\": \"queued\"\n-        }\n-        \n+            \"delivery_status\": \"queued\",\n+        }\n+\n         # Step 3: Mock Celery task execution\n         mock_task_result = MagicMock()\n         mock_task_result.id = \"task-email-e2e-123\"\n         mock_task.apply_async.return_value = mock_task_result\n-        \n+\n         # Execute the task synchronously for testing\n         def execute_task(*args, **kwargs):\n             return mock_email_send.return_value\n+\n         mock_task.apply_async.side_effect = execute_task\n-        \n+\n         # Step 4: Send notification request\n         headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n         notification_data = {\n             \"type\": \"email\",\n             \"to\": \"user@example.com\",\n@@ -62,584 +67,674 @@\n             \"message\": \"Thank you for joining our platform!\",\n             \"priority\": \"normal\",\n             \"data\": {\n                 \"user_name\": \"John Doe\",\n                 \"platform_name\": \"Medical Hub\",\n-                \"login_url\": \"https://medicalhub.com/login\"\n-            }\n-        }\n-        \n+                \"login_url\": \"https://medicalhub.com/login\",\n+            },\n+        }\n+\n         # Step 5: Submit notification\n-        response = client.post(\"/api/v1/notifications\", \n-                              json=notification_data, \n-                              headers=headers)\n-        \n+        response = client.post(\n+            \"/api/v1/notifications\", json=notification_data, headers=headers\n+        )\n+\n         # Step 6: Verify immediate response\n         assert response.status_code == 200\n         result = response.json()\n         assert \"notification_id\" in result\n         assert \"task_id\" in result\n         assert result[\"status\"] == \"queued\"\n-        \n+\n         notification_id = result[\"notification_id\"]\n-        \n+\n         # Step 7: Verify notification status after processing\n-        status_response = client.get(f\"/api/v1/notifications/{notification_id}/status\",\n-                                   headers=headers)\n-        \n+        status_response = client.get(\n+            f\"/api/v1/notifications/{notification_id}/status\", headers=headers\n+        )\n+\n         assert status_response.status_code == 200\n         status_result = status_response.json()\n         assert status_result[\"notification_id\"] == notification_id\n         assert status_result[\"channel\"] == \"email\"\n-        \n+\n         # Step 8: Verify all mocks were called correctly\n         mock_identity.assert_called_once()\n         mock_task.apply_async.assert_called_once()\n-        \n+\n         # Step 9: Verify task execution would call email provider\n         expected_call_args = mock_task.apply_async.call_args\n         assert expected_call_args is not None\n-    \n-    @patch('httpx.AsyncClient.post')\n-    @patch('providers.sms.SMSProvider.send')\n-    @patch('tasks.notification_tasks.send_notification')\n-    def test_complete_sms_notification_flow(self, mock_task, mock_sms_send, mock_identity, client: TestClient):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    @patch(\"providers.sms.SMSProvider.send\")\n+    @patch(\"tasks.notification_tasks.send_notification\")\n+    def test_complete_sms_notification_flow(\n+        self, mock_task, mock_sms_send, mock_identity, client: TestClient\n+    ):\n         \"\"\"Test complete SMS notification flow with delivery tracking\"\"\"\n         # Step 1: Mock Identity Service validation\n         mock_identity_response = AsyncMock()\n         mock_identity_response.status_code = 200\n-        mock_identity_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_identity_response\n-        \n+        mock_identity_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_identity_response\n+\n         # Step 2: Mock SMS provider response with delivery tracking\n         mock_sms_send.return_value = {\n             \"success\": True,\n             \"provider_message_id\": \"sms-twilio-789\",\n             \"delivery_status\": \"sent\",\n             \"cost\": 0.0075,\n-            \"segments\": 1\n-        }\n-        \n+            \"segments\": 1,\n+        }\n+\n         # Step 3: Mock Celery task\n         mock_task_result = MagicMock()\n         mock_task_result.id = \"task-sms-e2e-456\"\n         mock_task.apply_async.return_value = mock_task_result\n-        \n+\n         # Step 4: Send SMS notification\n         headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n         notification_data = {\n             \"type\": \"sms\",\n             \"to\": \"+1234567890\",\n             \"message\": \"Your verification code is 123456. Valid for 10 minutes.\",\n             \"priority\": \"high\",\n-            \"data\": {\n-                \"code\": \"123456\",\n-                \"expires_in\": \"10 minutes\"\n-            }\n-        }\n-        \n-        response = client.post(\"/api/v1/notifications\",\n-                              json=notification_data,\n-                              headers=headers)\n-        \n+            \"data\": {\"code\": \"123456\", \"expires_in\": \"10 minutes\"},\n+        }\n+\n+        response = client.post(\n+            \"/api/v1/notifications\", json=notification_data, headers=headers\n+        )\n+\n         # Step 5: Verify response\n         assert response.status_code == 200\n         result = response.json()\n         assert result[\"status\"] == \"queued\"\n         notification_id = result[\"notification_id\"]\n-        \n+\n         # Step 6: Simulate webhook delivery confirmation\n         webhook_data = {\n             \"message_id\": \"sms-twilio-789\",\n             \"status\": \"delivered\",\n             \"delivered_at\": datetime.utcnow().isoformat(),\n-            \"provider\": \"twilio\"\n-        }\n-        \n-        webhook_response = client.post(\"/webhooks/sms/status\",\n-                                      json=webhook_data,\n-                                      headers={\"X-Webhook-Source\": \"twilio\"})\n-        \n+            \"provider\": \"twilio\",\n+        }\n+\n+        webhook_response = client.post(\n+            \"/webhooks/sms/status\",\n+            json=webhook_data,\n+            headers={\"X-Webhook-Source\": \"twilio\"},\n+        )\n+\n         # Step 7: Verify webhook processing\n         assert webhook_response.status_code == 200\n-        \n+\n         # Step 8: Verify final notification status includes delivery confirmation\n-        final_status = client.get(f\"/api/v1/notifications/{notification_id}/status\",\n-                                 headers=headers)\n-        \n+        final_status = client.get(\n+            f\"/api/v1/notifications/{notification_id}/status\", headers=headers\n+        )\n+\n         assert final_status.status_code == 200\n         final_result = final_status.json()\n         assert final_result[\"channel\"] == \"sms\"\n-    \n-    @patch('httpx.AsyncClient.post')\n-    @patch('providers.push.PushProvider.send')\n-    @patch('tasks.notification_tasks.send_notification')  \n-    def test_complete_push_notification_flow(self, mock_task, mock_push_send, mock_identity, client: TestClient):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    @patch(\"providers.push.PushProvider.send\")\n+    @patch(\"tasks.notification_tasks.send_notification\")\n+    def test_complete_push_notification_flow(\n+        self, mock_task, mock_push_send, mock_identity, client: TestClient\n+    ):\n         \"\"\"Test complete push notification flow with FCM integration\"\"\"\n         # Step 1: Mock Identity Service\n         mock_identity_response = AsyncMock()\n         mock_identity_response.status_code = 200\n-        mock_identity_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_identity_response\n-        \n+        mock_identity_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_identity_response\n+\n         # Step 2: Mock FCM response\n         mock_push_send.return_value = {\n             \"success\": True,\n             \"provider_message_id\": \"fcm-message-abc123\",\n             \"delivery_status\": \"sent\",\n             \"tokens_processed\": 1,\n             \"tokens_succeeded\": 1,\n-            \"tokens_failed\": 0\n-        }\n-        \n+            \"tokens_failed\": 0,\n+        }\n+\n         # Step 3: Mock task\n         mock_task_result = MagicMock()\n         mock_task_result.id = \"task-push-e2e-789\"\n         mock_task.apply_async.return_value = mock_task_result\n-        \n+\n         # Step 4: Send push notification\n         headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n         notification_data = {\n             \"type\": \"push\",\n             \"to\": \"fcm-device-token-xyz789\",\n             \"title\": \"New Message Received\",\n             \"message\": \"You have a new message from Dr. Smith\",\n             \"data\": {\n                 \"deep_link\": \"/messages/456\",\n                 \"sender_id\": \"dr-smith-123\",\n-                \"message_type\": \"appointment_reminder\"\n-            }\n-        }\n-        \n-        response = client.post(\"/api/v1/notifications\",\n-                              json=notification_data,\n-                              headers=headers)\n-        \n+                \"message_type\": \"appointment_reminder\",\n+            },\n+        }\n+\n+        response = client.post(\n+            \"/api/v1/notifications\", json=notification_data, headers=headers\n+        )\n+\n         # Step 5: Verify response\n         assert response.status_code == 200\n         result = response.json()\n         notification_id = result[\"notification_id\"]\n-        \n+\n         # Step 6: Test push notification feedback webhook\n         feedback_data = {\n             \"message_id\": \"fcm-message-abc123\",\n-            \"status\": \"delivered\", \n+            \"status\": \"delivered\",\n             \"delivered_at\": datetime.utcnow().isoformat(),\n-            \"device_token\": \"fcm-device-token-xyz789\"\n-        }\n-        \n-        feedback_response = client.post(\"/webhooks/push/feedback\",\n-                                       json=feedback_data,\n-                                       headers={\"X-Webhook-Source\": \"fcm\"})\n-        \n+            \"device_token\": \"fcm-device-token-xyz789\",\n+        }\n+\n+        feedback_response = client.post(\n+            \"/webhooks/push/feedback\",\n+            json=feedback_data,\n+            headers={\"X-Webhook-Source\": \"fcm\"},\n+        )\n+\n         assert feedback_response.status_code == 200\n-    \n-    @patch('httpx.AsyncClient.post')\n-    @patch('providers.in_app.InAppProvider.send')\n-    def test_complete_in_app_notification_flow(self, mock_in_app_send, mock_identity, client: TestClient):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    @patch(\"providers.in_app.InAppProvider.send\")\n+    def test_complete_in_app_notification_flow(\n+        self, mock_in_app_send, mock_identity, client: TestClient\n+    ):\n         \"\"\"Test complete in-app notification flow with real-time delivery\"\"\"\n         # Step 1: Mock Identity Service\n         mock_identity_response = AsyncMock()\n         mock_identity_response.status_code = 200\n-        mock_identity_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_identity_response\n-        \n+        mock_identity_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_identity_response\n+\n         # Step 2: Mock in-app provider (immediate delivery)\n         mock_in_app_send.return_value = {\n             \"success\": True,\n             \"notification_id\": \"in-app-notif-123\",\n             \"delivery_status\": \"delivered\",\n-            \"delivered_at\": datetime.utcnow().isoformat()\n-        }\n-        \n+            \"delivered_at\": datetime.utcnow().isoformat(),\n+        }\n+\n         # Step 3: Send in-app notification\n         headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n         notification_data = {\n             \"type\": \"in_app\",\n             \"to\": \"user-123\",\n-            \"title\": \"Appointment Reminder\", \n+            \"title\": \"Appointment Reminder\",\n             \"message\": \"Your appointment with Dr. Johnson is tomorrow at 2:00 PM\",\n             \"data\": {\n                 \"appointment_id\": \"appt-456\",\n                 \"doctor_name\": \"Dr. Johnson\",\n-                \"appointment_time\": \"2024-01-15T14:00:00Z\"\n-            }\n-        }\n-        \n-        response = client.post(\"/api/v1/notifications\",\n-                              json=notification_data,\n-                              headers=headers)\n-        \n+                \"appointment_time\": \"2024-01-15T14:00:00Z\",\n+            },\n+        }\n+\n+        response = client.post(\n+            \"/api/v1/notifications\", json=notification_data, headers=headers\n+        )\n+\n         # Step 4: Verify immediate delivery for in-app notifications\n         assert response.status_code == 200\n         result = response.json()\n         notification_id = result[\"notification_id\"]\n-        \n+\n         # Step 5: Verify user can retrieve unread notifications\n         unread_response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n         assert unread_response.status_code == 200\n-        \n+\n         unread_result = unread_response.json()\n         assert \"notifications\" in unread_result\n         assert \"unread_count\" in unread_result\n-        \n+\n         # Step 6: Mark notification as read\n         mark_read_data = {\"notification_ids\": [notification_id]}\n-        mark_read_response = client.post(\"/api/v1/notifications/mark-read\",\n-                                        json=mark_read_data,\n-                                        headers=headers)\n-        \n+        mark_read_response = client.post(\n+            \"/api/v1/notifications/mark-read\", json=mark_read_data, headers=headers\n+        )\n+\n         assert mark_read_response.status_code == 200\n         mark_read_result = mark_read_response.json()\n         assert \"marked_count\" in mark_read_result\n \n \n @pytest.mark.integration\n @pytest.mark.e2e\n class TestMultiChannelNotificationFlows:\n     \"\"\"End-to-end tests for multi-channel notification scenarios\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n-    @patch('providers.email.EmailProvider.send')\n-    @patch('providers.sms.SMSProvider.send')\n-    @patch('providers.push.PushProvider.send')\n-    @patch('tasks.notification_tasks.send_notification')\n-    def test_multi_channel_notification_campaign(self, mock_task, mock_push, mock_sms, mock_email, mock_identity, client: TestClient):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    @patch(\"providers.email.EmailProvider.send\")\n+    @patch(\"providers.sms.SMSProvider.send\")\n+    @patch(\"providers.push.PushProvider.send\")\n+    @patch(\"tasks.notification_tasks.send_notification\")\n+    def test_multi_channel_notification_campaign(\n+        self,\n+        mock_task,\n+        mock_push,\n+        mock_sms,\n+        mock_email,\n+        mock_identity,\n+        client: TestClient,\n+    ):\n         \"\"\"Test sending same notification across multiple channels\"\"\"\n         # Mock Identity Service\n         mock_identity_response = AsyncMock()\n         mock_identity_response.status_code = 200\n-        mock_identity_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_identity_response\n-        \n+        mock_identity_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_identity_response\n+\n         # Mock all providers\n-        mock_email.return_value = {\"success\": True, \"provider_message_id\": \"email-multi-123\"}\n-        mock_sms.return_value = {\"success\": True, \"provider_message_id\": \"sms-multi-456\"}\n-        mock_push.return_value = {\"success\": True, \"provider_message_id\": \"push-multi-789\"}\n-        \n+        mock_email.return_value = {\n+            \"success\": True,\n+            \"provider_message_id\": \"email-multi-123\",\n+        }\n+        mock_sms.return_value = {\n+            \"success\": True,\n+            \"provider_message_id\": \"sms-multi-456\",\n+        }\n+        mock_push.return_value = {\n+            \"success\": True,\n+            \"provider_message_id\": \"push-multi-789\",\n+        }\n+\n         # Mock tasks\n         mock_task_result = MagicMock()\n         mock_task_result.id = \"task-multi-channel\"\n         mock_task.apply_async.return_value = mock_task_result\n-        \n-        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        \n+\n+        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+\n         # Send same notification across different channels\n         base_data = {\n             \"message\": \"Important security alert: New login detected from unknown device\",\n             \"priority\": \"urgent\",\n             \"data\": {\n                 \"alert_type\": \"security\",\n                 \"device_info\": \"Chrome on Windows\",\n                 \"location\": \"New York, US\",\n-                \"time\": datetime.utcnow().isoformat()\n-            }\n-        }\n-        \n+                \"time\": datetime.utcnow().isoformat(),\n+            },\n+        }\n+\n         notification_ids = []\n-        \n+\n         # Email notification\n         email_data = {\n             **base_data,\n             \"type\": \"email\",\n             \"to\": \"user@example.com\",\n-            \"subject\": \"Security Alert - New Login Detected\"\n-        }\n-        \n-        email_response = client.post(\"/api/v1/notifications\", json=email_data, headers=headers)\n+            \"subject\": \"Security Alert - New Login Detected\",\n+        }\n+\n+        email_response = client.post(\n+            \"/api/v1/notifications\", json=email_data, headers=headers\n+        )\n         assert email_response.status_code == 200\n         notification_ids.append(email_response.json()[\"notification_id\"])\n-        \n-        # SMS notification  \n-        sms_data = {\n-            **base_data,\n-            \"type\": \"sms\",\n-            \"to\": \"+1234567890\"\n-        }\n-        \n-        sms_response = client.post(\"/api/v1/notifications\", json=sms_data, headers=headers)\n+\n+        # SMS notification\n+        sms_data = {**base_data, \"type\": \"sms\", \"to\": \"+1234567890\"}\n+\n+        sms_response = client.post(\n+            \"/api/v1/notifications\", json=sms_data, headers=headers\n+        )\n         assert sms_response.status_code == 200\n         notification_ids.append(sms_response.json()[\"notification_id\"])\n-        \n+\n         # Push notification\n         push_data = {\n             **base_data,\n             \"type\": \"push\",\n             \"to\": \"push-token-security-alert\",\n-            \"title\": \"Security Alert\"\n-        }\n-        \n-        push_response = client.post(\"/api/v1/notifications\", json=push_data, headers=headers)\n+            \"title\": \"Security Alert\",\n+        }\n+\n+        push_response = client.post(\n+            \"/api/v1/notifications\", json=push_data, headers=headers\n+        )\n         assert push_response.status_code == 200\n         notification_ids.append(push_response.json()[\"notification_id\"])\n-        \n+\n         # Verify all notifications were queued\n         assert len(notification_ids) == 3\n-        \n+\n         # Verify each notification status\n         for notification_id in notification_ids:\n-            status_response = client.get(f\"/api/v1/notifications/{notification_id}/status\", headers=headers)\n+            status_response = client.get(\n+                f\"/api/v1/notifications/{notification_id}/status\", headers=headers\n+            )\n             assert status_response.status_code == 200\n             status_result = status_response.json()\n             assert status_result[\"notification_id\"] == notification_id\n-    \n-    @patch('httpx.AsyncClient.post')\n-    @patch('services.template_engine.TemplateEngine')\n-    @patch('providers.email.EmailProvider.send')\n-    @patch('tasks.notification_tasks.send_notification')\n-    def test_template_based_notification_flow(self, mock_task, mock_email, mock_template_engine, mock_identity, client: TestClient, sample_notification_template):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    @patch(\"services.template_engine.TemplateEngine\")\n+    @patch(\"providers.email.EmailProvider.send\")\n+    @patch(\"tasks.notification_tasks.send_notification\")\n+    def test_template_based_notification_flow(\n+        self,\n+        mock_task,\n+        mock_email,\n+        mock_template_engine,\n+        mock_identity,\n+        client: TestClient,\n+        sample_notification_template,\n+    ):\n         \"\"\"Test complete template-based notification flow\"\"\"\n         # Mock Identity Service\n         mock_identity_response = AsyncMock()\n         mock_identity_response.status_code = 200\n-        mock_identity_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_identity_response\n-        \n+        mock_identity_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_identity_response\n+\n         # Mock template engine\n         mock_template_instance = MagicMock()\n-        mock_template_instance.render.return_value = \"Dear John Doe, welcome to Medical Hub! Your account is now active.\"\n+        mock_template_instance.render.return_value = (\n+            \"Dear John Doe, welcome to Medical Hub! Your account is now active.\"\n+        )\n         mock_template_engine.return_value = mock_template_instance\n-        \n+\n         # Mock email provider\n-        mock_email.return_value = {\"success\": True, \"provider_message_id\": \"template-email-123\"}\n-        \n+        mock_email.return_value = {\n+            \"success\": True,\n+            \"provider_message_id\": \"template-email-123\",\n+        }\n+\n         # Mock task\n         mock_task_result = MagicMock()\n         mock_task_result.id = \"task-template-flow\"\n         mock_task.apply_async.return_value = mock_task_result\n-        \n-        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        \n+\n+        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+\n         # Send template-based notification\n         template_data = {\n             \"type\": \"email\",\n-            \"to\": \"john@example.com\", \n+            \"to\": \"john@example.com\",\n             \"template_id\": str(sample_notification_template.id),\n             \"data\": {\n                 \"user_name\": \"John Doe\",\n                 \"platform_name\": \"Medical Hub\",\n-                \"account_status\": \"active\"\n-            }\n-        }\n-        \n-        response = client.post(\"/api/v1/notifications\", json=template_data, headers=headers)\n-        \n+                \"account_status\": \"active\",\n+            },\n+        }\n+\n+        response = client.post(\n+            \"/api/v1/notifications\", json=template_data, headers=headers\n+        )\n+\n         # Verify response\n         assert response.status_code == 200\n         result = response.json()\n         notification_id = result[\"notification_id\"]\n-        \n+\n         # Verify template engine was called\n         mock_template_instance.render.assert_called_once()\n-        \n+\n         # Verify notification status\n-        status_response = client.get(f\"/api/v1/notifications/{notification_id}/status\", headers=headers)\n+        status_response = client.get(\n+            f\"/api/v1/notifications/{notification_id}/status\", headers=headers\n+        )\n         assert status_response.status_code == 200\n \n \n @pytest.mark.integration\n @pytest.mark.e2e\n class TestNotificationErrorRecoveryFlows:\n     \"\"\"End-to-end tests for notification error recovery and retry flows\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n-    @patch('providers.email.EmailProvider.send')\n-    @patch('tasks.notification_tasks.send_notification')\n-    def test_notification_retry_flow_after_provider_failure(self, mock_task, mock_email, mock_identity, client: TestClient):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    @patch(\"providers.email.EmailProvider.send\")\n+    @patch(\"tasks.notification_tasks.send_notification\")\n+    def test_notification_retry_flow_after_provider_failure(\n+        self, mock_task, mock_email, mock_identity, client: TestClient\n+    ):\n         \"\"\"Test complete retry flow after provider failure\"\"\"\n         # Mock Identity Service\n         mock_identity_response = AsyncMock()\n         mock_identity_response.status_code = 200\n-        mock_identity_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_identity_response\n-        \n+        mock_identity_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_identity_response\n+\n         # Mock initial provider failure, then success on retry\n         mock_email.side_effect = [\n             Exception(\"SMTP server unavailable\"),  # First attempt fails\n-            {\"success\": True, \"provider_message_id\": \"retry-success-123\"}  # Retry succeeds\n+            {\n+                \"success\": True,\n+                \"provider_message_id\": \"retry-success-123\",\n+            },  # Retry succeeds\n         ]\n-        \n+\n         # Mock task\n         mock_task_result = MagicMock()\n         mock_task_result.id = \"task-retry-flow\"\n         mock_task.apply_async.return_value = mock_task_result\n-        \n-        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        \n+\n+        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+\n         # Send notification\n         notification_data = {\n             \"type\": \"email\",\n             \"to\": \"test@example.com\",\n             \"subject\": \"Test Retry Flow\",\n-            \"message\": \"This tests the retry mechanism\"\n-        }\n-        \n-        response = client.post(\"/api/v1/notifications\", json=notification_data, headers=headers)\n+            \"message\": \"This tests the retry mechanism\",\n+        }\n+\n+        response = client.post(\n+            \"/api/v1/notifications\", json=notification_data, headers=headers\n+        )\n         assert response.status_code == 200\n         notification_id = response.json()[\"notification_id\"]\n-        \n+\n         # Simulate task processing failure (first attempt)\n         # In real scenario, this would be handled by Celery retry logic\n-        \n+\n         # Manually trigger retry\n-        retry_response = client.post(f\"/api/v1/notifications/{notification_id}/retry\", headers=headers)\n+        retry_response = client.post(\n+            f\"/api/v1/notifications/{notification_id}/retry\", headers=headers\n+        )\n         assert retry_response.status_code == 200\n-        \n+\n         retry_result = retry_response.json()\n         assert retry_result[\"status\"] == \"queued\"\n         assert \"task_id\" in retry_result\n-    \n-    @patch('httpx.AsyncClient.post') \n-    @patch('providers.sms.SMSProvider.send')\n-    @patch('tasks.notification_tasks.send_notification')\n-    def test_notification_cancellation_flow(self, mock_task, mock_sms, mock_identity, client: TestClient):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    @patch(\"providers.sms.SMSProvider.send\")\n+    @patch(\"tasks.notification_tasks.send_notification\")\n+    def test_notification_cancellation_flow(\n+        self, mock_task, mock_sms, mock_identity, client: TestClient\n+    ):\n         \"\"\"Test notification cancellation before processing\"\"\"\n         # Mock Identity Service\n         mock_identity_response = AsyncMock()\n         mock_identity_response.status_code = 200\n-        mock_identity_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_identity_response\n-        \n+        mock_identity_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_identity_response\n+\n         # Mock task\n         mock_task_result = MagicMock()\n         mock_task_result.id = \"task-cancellation-test\"\n         mock_task.apply_async.return_value = mock_task_result\n-        \n-        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        \n+\n+        headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+\n         # Send notification\n         notification_data = {\n             \"type\": \"sms\",\n-            \"to\": \"+1234567890\", \n-            \"message\": \"This notification will be cancelled\"\n-        }\n-        \n-        response = client.post(\"/api/v1/notifications\", json=notification_data, headers=headers)\n+            \"to\": \"+1234567890\",\n+            \"message\": \"This notification will be cancelled\",\n+        }\n+\n+        response = client.post(\n+            \"/api/v1/notifications\", json=notification_data, headers=headers\n+        )\n         assert response.status_code == 200\n         notification_id = response.json()[\"notification_id\"]\n-        \n+\n         # Cancel the notification before processing\n-        with patch('services.queue_manager.QueueManager') as mock_queue:\n+        with patch(\"services.queue_manager.QueueManager\") as mock_queue:\n             mock_queue_instance = AsyncMock()\n             mock_queue_instance.cancel_notification.return_value = True\n             mock_queue.return_value = mock_queue_instance\n-            \n-            cancel_response = client.delete(f\"/api/v1/notifications/{notification_id}\", headers=headers)\n+\n+            cancel_response = client.delete(\n+                f\"/api/v1/notifications/{notification_id}\", headers=headers\n+            )\n             assert cancel_response.status_code == 200\n-            \n+\n             cancel_result = cancel_response.json()\n             assert \"cancelled\" in cancel_result[\"message\"].lower()\n \n \n @pytest.mark.integration\n-@pytest.mark.e2e  \n+@pytest.mark.e2e\n @pytest.mark.slow\n class TestHighVolumeNotificationFlows:\n     \"\"\"End-to-end tests for high-volume notification processing\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n-    @patch('providers.email.EmailProvider.send')\n-    @patch('tasks.notification_tasks.send_notification')\n-    def test_bulk_notification_processing_flow(self, mock_task, mock_email, mock_identity, client: TestClient):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    @patch(\"providers.email.EmailProvider.send\")\n+    @patch(\"tasks.notification_tasks.send_notification\")\n+    def test_bulk_notification_processing_flow(\n+        self, mock_task, mock_email, mock_identity, client: TestClient\n+    ):\n         \"\"\"Test processing multiple notifications in bulk\"\"\"\n         # Mock Identity Service\n         mock_identity_response = AsyncMock()\n         mock_identity_response.status_code = 200\n-        mock_identity_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_identity.return_value = mock_identity_response\n-        \n+        mock_identity_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_identity.return_value = mock_identity_response\n+\n         # Mock provider\n         mock_email.return_value = {\"success\": True, \"provider_message_id\": \"bulk-email\"}\n-        \n+\n         # Mock task\n         mock_task_result = MagicMock()\n         mock_task.apply_async.return_value = mock_task_result\n-        \n+\n         headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n         notification_ids = []\n-        \n+\n         # Send 10 notifications rapidly\n         for i in range(10):\n             notification_data = {\n                 \"type\": \"email\",\n                 \"to\": f\"user{i}@example.com\",\n                 \"subject\": f\"Bulk Test Message {i}\",\n-                \"message\": f\"This is bulk test message number {i}\"\n+                \"message\": f\"This is bulk test message number {i}\",\n             }\n-            \n-            response = client.post(\"/api/v1/notifications\", json=notification_data, headers=headers)\n+\n+            response = client.post(\n+                \"/api/v1/notifications\", json=notification_data, headers=headers\n+            )\n             assert response.status_code == 200\n             notification_ids.append(response.json()[\"notification_id\"])\n-        \n+\n         # Verify all notifications were queued\n         assert len(notification_ids) == 10\n-        \n+\n         # Verify task was called for each notification\n         assert mock_task.apply_async.call_count == 10\n-        \n+\n         # Check status of all notifications\n         for notification_id in notification_ids:\n-            status_response = client.get(f\"/api/v1/notifications/{notification_id}/status\", headers=headers)\n+            status_response = client.get(\n+                f\"/api/v1/notifications/{notification_id}/status\", headers=headers\n+            )\n             assert status_response.status_code == 200\n             status_result = status_response.json()\n             assert status_result[\"notification_id\"] == notification_id\n \n \n @pytest.mark.integration\n @pytest.mark.e2e\n class TestWebhookIntegrationFlows:\n     \"\"\"End-to-end tests for webhook integration flows\"\"\"\n-    \n+\n     def test_email_delivery_webhook_flow(self, client: TestClient):\n         \"\"\"Test complete email delivery webhook processing flow\"\"\"\n         # Simulate email delivery webhook from provider\n         webhook_data = {\n             \"message_id\": \"provider-email-12345\",\n             \"event\": \"delivered\",\n             \"timestamp\": datetime.utcnow().isoformat(),\n             \"recipient\": \"user@example.com\",\n-            \"provider\": \"sendgrid\"\n-        }\n-        \n-        response = client.post(\"/webhooks/email/delivery\",\n-                              json=webhook_data,\n-                              headers={\"X-Webhook-Source\": \"sendgrid\"})\n-        \n+            \"provider\": \"sendgrid\",\n+        }\n+\n+        response = client.post(\n+            \"/webhooks/email/delivery\",\n+            json=webhook_data,\n+            headers={\"X-Webhook-Source\": \"sendgrid\"},\n+        )\n+\n         assert response.status_code == 200\n         result = response.json()\n         assert \"status\" in result\n         assert result[\"status\"] == \"processed\"\n-    \n+\n     def test_sms_status_webhook_flow(self, client: TestClient):\n         \"\"\"Test SMS status webhook processing flow\"\"\"\n         webhook_data = {\n             \"message_id\": \"sms-provider-67890\",\n-            \"status\": \"delivered\", \n+            \"status\": \"delivered\",\n             \"delivered_at\": datetime.utcnow().isoformat(),\n             \"provider\": \"twilio\",\n-            \"cost\": 0.0075\n-        }\n-        \n-        response = client.post(\"/webhooks/sms/status\",\n-                              json=webhook_data,\n-                              headers={\"X-Webhook-Source\": \"twilio\"})\n-        \n+            \"cost\": 0.0075,\n+        }\n+\n+        response = client.post(\n+            \"/webhooks/sms/status\",\n+            json=webhook_data,\n+            headers={\"X-Webhook-Source\": \"twilio\"},\n+        )\n+\n         assert response.status_code == 200\n         result = response.json()\n         assert result[\"status\"] == \"processed\"\n-    \n+\n     def test_push_feedback_webhook_flow(self, client: TestClient):\n         \"\"\"Test push notification feedback webhook flow\"\"\"\n         webhook_data = {\n             \"message_id\": \"fcm-push-abc123\",\n             \"status\": \"delivered\",\n             \"device_token\": \"device-token-xyz\",\n-            \"delivered_at\": datetime.utcnow().isoformat()\n-        }\n-        \n-        response = client.post(\"/webhooks/push/feedback\",\n-                              json=webhook_data,\n-                              headers={\"X-Webhook-Source\": \"fcm\"})\n-        \n+            \"delivered_at\": datetime.utcnow().isoformat(),\n+        }\n+\n+        response = client.post(\n+            \"/webhooks/push/feedback\",\n+            json=webhook_data,\n+            headers={\"X-Webhook-Source\": \"fcm\"},\n+        )\n+\n         assert response.status_code == 200\n         result = response.json()\n-        assert result[\"status\"] == \"processed\"\n\\ No newline at end of file\n+        assert result[\"status\"] == \"processed\"\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/integration/test_api_endpoints.py\t2025-09-09 18:14:18.576769+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/integration/test_api_endpoints.py\t2025-09-10 11:37:02.711336+00:00\n@@ -10,404 +10,449 @@\n from fastapi.testclient import TestClient\n \n from tests.fixtures.sample_data import SampleNotificationData, SampleAPIData\n from tests.fixtures.mock_responses import IdentityServiceMocks, EmailProviderMocks\n \n+\n @pytest.mark.integration\n class TestNotificationEndpoints:\n     \"\"\"Integration tests for notification API endpoints\"\"\"\n-    \n+\n     def test_health_endpoint_no_auth_required(self, client: TestClient):\n         \"\"\"Test health endpoint is accessible without authentication\"\"\"\n         response = client.get(\"/health\")\n-        \n+\n         assert response.status_code == 200\n         data = response.json()\n         assert \"service\" in data\n         assert \"status\" in data\n         assert data[\"service\"] == \"communication-service\"\n         assert data[\"status\"] in [\"healthy\", \"degraded\"]\n-    \n+\n     def test_metrics_endpoint_no_auth_required(self, client: TestClient):\n         \"\"\"Test metrics endpoint is accessible without authentication\"\"\"\n         response = client.get(\"/metrics\")\n-        \n+\n         assert response.status_code == 200\n         # Should return Prometheus metrics format\n         assert response.headers[\"content-type\"].startswith(\"text/plain\")\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_send_email_notification_success(self, mock_post, client: TestClient):\n         \"\"\"Test sending email notification successfully\"\"\"\n         # Mock Identity Service validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         # Mock Celery task\n-        with patch('tasks.notification_tasks.send_notification') as mock_task:\n+        with patch(\"tasks.notification_tasks.send_notification\") as mock_task:\n             mock_result = MagicMock()\n             mock_result.id = \"task-123-456-789\"\n             mock_task.apply_async.return_value = mock_result\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n             notification_data = {\n                 \"type\": \"email\",\n                 \"to\": \"test@example.com\",\n                 \"subject\": \"Test Email\",\n                 \"message\": \"This is a test email notification\",\n                 \"priority\": \"normal\",\n-                \"data\": {\"user_name\": \"Test User\"}\n+                \"data\": {\"user_name\": \"Test User\"},\n             }\n-            \n-            response = client.post(\"/api/v1/notifications\",\n-                                  json=notification_data,\n-                                  headers=headers)\n-            \n+\n+            response = client.post(\n+                \"/api/v1/notifications\", json=notification_data, headers=headers\n+            )\n+\n             assert response.status_code == 200\n             result = response.json()\n             assert \"notification_id\" in result\n             assert \"task_id\" in result\n             assert result[\"status\"] == \"queued\"\n             assert result[\"task_id\"] == \"task-123-456-789\"\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_send_sms_notification_success(self, mock_post, client: TestClient):\n         \"\"\"Test sending SMS notification successfully\"\"\"\n         # Mock Identity Service validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         # Mock Celery task\n-        with patch('tasks.notification_tasks.send_notification') as mock_task:\n+        with patch(\"tasks.notification_tasks.send_notification\") as mock_task:\n             mock_result = MagicMock()\n             mock_result.id = \"task-sms-123\"\n             mock_task.apply_async.return_value = mock_result\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n             notification_data = {\n                 \"type\": \"sms\",\n                 \"to\": \"+1234567890\",\n                 \"message\": \"Your verification code is 123456\",\n                 \"priority\": \"high\",\n-                \"data\": {\"code\": \"123456\"}\n+                \"data\": {\"code\": \"123456\"},\n             }\n-            \n-            response = client.post(\"/api/v1/notifications\",\n-                                  json=notification_data,\n-                                  headers=headers)\n-            \n+\n+            response = client.post(\n+                \"/api/v1/notifications\", json=notification_data, headers=headers\n+            )\n+\n             assert response.status_code == 200\n             result = response.json()\n             assert \"notification_id\" in result\n             assert \"task_id\" in result\n             assert result[\"status\"] == \"queued\"\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_send_push_notification_success(self, mock_post, client: TestClient):\n         \"\"\"Test sending push notification successfully\"\"\"\n         # Mock Identity Service validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         # Mock Celery task\n-        with patch('tasks.notification_tasks.send_notification') as mock_task:\n+        with patch(\"tasks.notification_tasks.send_notification\") as mock_task:\n             mock_result = MagicMock()\n             mock_result.id = \"task-push-123\"\n             mock_task.apply_async.return_value = mock_result\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n             notification_data = {\n                 \"type\": \"push\",\n                 \"to\": \"push-token-123456\",\n                 \"title\": \"New Message\",\n                 \"message\": \"You have received a new message\",\n-                \"data\": {\"deep_link\": \"/messages/123\"}\n+                \"data\": {\"deep_link\": \"/messages/123\"},\n             }\n-            \n-            response = client.post(\"/api/v1/notifications\",\n-                                  json=notification_data,\n-                                  headers=headers)\n-            \n+\n+            response = client.post(\n+                \"/api/v1/notifications\", json=notification_data, headers=headers\n+            )\n+\n             assert response.status_code == 200\n             result = response.json()\n             assert \"notification_id\" in result\n             assert \"task_id\" in result\n             assert result[\"status\"] == \"queued\"\n-    \n-    @patch('httpx.AsyncClient.post')\n-    def test_send_notification_with_template(self, mock_post, client: TestClient, sample_notification_template):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    def test_send_notification_with_template(\n+        self, mock_post, client: TestClient, sample_notification_template\n+    ):\n         \"\"\"Test sending notification using template\"\"\"\n         # Mock Identity Service validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         # Mock Celery task and template rendering\n-        with patch('tasks.notification_tasks.send_notification') as mock_task, \\\n-             patch('services.template_engine.TemplateEngine') as mock_engine:\n-            \n+        with patch(\"tasks.notification_tasks.send_notification\") as mock_task, patch(\n+            \"services.template_engine.TemplateEngine\"\n+        ) as mock_engine:\n+\n             mock_result = MagicMock()\n             mock_result.id = \"task-template-123\"\n             mock_task.apply_async.return_value = mock_result\n-            \n+\n             # Mock template engine\n             mock_engine_instance = MagicMock()\n-            mock_engine_instance.render.return_value = \"Hello Test User, this is a test notification.\"\n+            mock_engine_instance.render.return_value = (\n+                \"Hello Test User, this is a test notification.\"\n+            )\n             mock_engine.return_value = mock_engine_instance\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n             notification_data = {\n                 \"type\": \"email\",\n                 \"to\": \"test@example.com\",\n                 \"template_id\": sample_notification_template.id,\n-                \"data\": {\"name\": \"Test User\", \"action\": \"test\"}\n+                \"data\": {\"name\": \"Test User\", \"action\": \"test\"},\n             }\n-            \n-            response = client.post(\"/api/v1/notifications\",\n-                                  json=notification_data,\n-                                  headers=headers)\n-            \n+\n+            response = client.post(\n+                \"/api/v1/notifications\", json=notification_data, headers=headers\n+            )\n+\n             assert response.status_code == 200\n             result = response.json()\n             assert \"notification_id\" in result\n             assert \"task_id\" in result\n             assert result[\"status\"] == \"queued\"\n-    \n+\n     def test_send_notification_without_auth(self, client: TestClient):\n         \"\"\"Test sending notification without authentication fails\"\"\"\n         notification_data = {\n             \"type\": \"email\",\n             \"to\": \"test@example.com\",\n-            \"message\": \"Test message\"\n+            \"message\": \"Test message\",\n         }\n-        \n+\n         response = client.post(\"/api/v1/notifications\", json=notification_data)\n-        \n+\n         assert response.status_code == 401\n         assert \"detail\" in response.json()\n         assert \"Not authenticated\" in response.json()[\"detail\"]\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_send_notification_invalid_token(self, mock_post, client: TestClient):\n         \"\"\"Test sending notification with invalid token\"\"\"\n         # Mock Identity Service failure\n         mock_response = AsyncMock()\n         mock_response.status_code = 401\n-        mock_response.json.return_value = IdentityServiceMocks.get_invalid_token_response()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_invalid_token_response()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         headers = {\"Authorization\": \"Bearer invalid.jwt.token\"}\n         notification_data = {\n             \"type\": \"email\",\n             \"to\": \"test@example.com\",\n-            \"message\": \"Test message\"\n+            \"message\": \"Test message\",\n         }\n-        \n-        response = client.post(\"/api/v1/notifications\",\n-                              json=notification_data,\n-                              headers=headers)\n-        \n+\n+        response = client.post(\n+            \"/api/v1/notifications\", json=notification_data, headers=headers\n+        )\n+\n         assert response.status_code == 401\n         assert \"Invalid or expired token\" in response.json()[\"detail\"]\n-    \n+\n     def test_send_notification_validation_errors(self, client: TestClient):\n         \"\"\"Test send notification endpoint validation\"\"\"\n         # Mock valid authentication but test validation\n-        with patch('httpx.AsyncClient.post') as mock_post:\n+        with patch(\"httpx.AsyncClient.post\") as mock_post:\n             mock_response = AsyncMock()\n             mock_response.status_code = 200\n-            mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+            mock_response.json.return_value = (\n+                IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+            )\n             mock_post.return_value = mock_response\n-            \n-            headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-            \n+\n+            headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+\n             # Test cases for validation errors\n             test_cases = [\n                 # Missing required fields\n                 ({}, \"type\"),\n                 ({\"type\": \"email\"}, \"to\"),\n                 ({\"type\": \"email\", \"to\": \"test@example.com\"}, \"message\"),\n-                \n                 # Invalid field values\n-                ({\"type\": \"invalid\", \"to\": \"test@example.com\", \"message\": \"test\"}, \"type\"),\n+                (\n+                    {\"type\": \"invalid\", \"to\": \"test@example.com\", \"message\": \"test\"},\n+                    \"type\",\n+                ),\n                 ({\"type\": \"email\", \"to\": \"invalid-email\", \"message\": \"test\"}, \"to\"),\n                 ({\"type\": \"sms\", \"to\": \"invalid-phone\", \"message\": \"test\"}, \"to\"),\n             ]\n-            \n+\n             for invalid_data, expected_field in test_cases:\n-                response = client.post(\"/api/v1/notifications\",\n-                                      json=invalid_data,\n-                                      headers=headers)\n-                \n-                assert response.status_code == 422, f\"Should fail validation for {expected_field}\"\n+                response = client.post(\n+                    \"/api/v1/notifications\", json=invalid_data, headers=headers\n+                )\n+\n+                assert (\n+                    response.status_code == 422\n+                ), f\"Should fail validation for {expected_field}\"\n                 error_details = response.json()\n                 assert \"detail\" in error_details\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_get_unread_notifications_success(self, mock_post, client: TestClient):\n         \"\"\"Test getting unread notifications successfully\"\"\"\n         # Mock Identity Service validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         # Mock in-app provider\n-        with patch('providers.in_app.InAppProvider') as mock_provider:\n+        with patch(\"providers.in_app.InAppProvider\") as mock_provider:\n             mock_instance = AsyncMock()\n             mock_instance.get_unread_notifications.return_value = [\n                 {\n                     \"id\": \"notif-1\",\n                     \"subject\": \"Welcome!\",\n                     \"content\": \"Welcome to our platform\",\n                     \"created_at\": datetime.utcnow().isoformat(),\n-                    \"is_read\": False\n+                    \"is_read\": False,\n                 }\n             ]\n             mock_instance.get_unread_count.return_value = 1\n             mock_provider.return_value = mock_instance\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n             response = client.get(\"/api/v1/notifications/unread\", headers=headers)\n-            \n+\n             assert response.status_code == 200\n             result = response.json()\n             assert \"unread_count\" in result\n             assert \"notifications\" in result\n             assert result[\"unread_count\"] == 1\n             assert len(result[\"notifications\"]) == 1\n-    \n+\n     def test_get_unread_notifications_without_auth(self, client: TestClient):\n         \"\"\"Test getting unread notifications without authentication\"\"\"\n         response = client.get(\"/api/v1/notifications/unread\")\n-        \n+\n         assert response.status_code == 401\n         assert \"Not authenticated\" in response.json()[\"detail\"]\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_mark_notifications_read_success(self, mock_post, client: TestClient):\n         \"\"\"Test marking notifications as read\"\"\"\n         # Mock Identity Service validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         # Mock in-app provider\n-        with patch('providers.in_app.InAppProvider') as mock_provider:\n+        with patch(\"providers.in_app.InAppProvider\") as mock_provider:\n             mock_instance = AsyncMock()\n-            mock_instance.mark_notifications_read.return_value = 3  # 3 notifications marked as read\n+            mock_instance.mark_notifications_read.return_value = (\n+                3  # 3 notifications marked as read\n+            )\n             mock_provider.return_value = mock_instance\n-            \n-            headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-            request_data = {\n-                \"notification_ids\": [\"notif-1\", \"notif-2\", \"notif-3\"]\n-            }\n-            \n-            response = client.post(\"/api/v1/notifications/mark-read\",\n-                                  json=request_data,\n-                                  headers=headers)\n-            \n+\n+            headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+            request_data = {\"notification_ids\": [\"notif-1\", \"notif-2\", \"notif-3\"]}\n+\n+            response = client.post(\n+                \"/api/v1/notifications/mark-read\", json=request_data, headers=headers\n+            )\n+\n             assert response.status_code == 200\n             result = response.json()\n             assert \"marked_count\" in result\n             assert result[\"marked_count\"] == 3\n-    \n-    @patch('httpx.AsyncClient.post')\n-    def test_get_notification_status_success(self, mock_post, client: TestClient, sample_notification):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    def test_get_notification_status_success(\n+        self, mock_post, client: TestClient, sample_notification\n+    ):\n         \"\"\"Test getting notification status\"\"\"\n         # Mock Identity Service validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        response = client.get(f\"/api/v1/notifications/{sample_notification.id}/status\",\n-                             headers=headers)\n-        \n+        response = client.get(\n+            f\"/api/v1/notifications/{sample_notification.id}/status\", headers=headers\n+        )\n+\n         assert response.status_code == 200\n         result = response.json()\n         assert \"notification_id\" in result\n         assert \"status\" in result\n         assert \"channel\" in result\n         assert result[\"notification_id\"] == str(sample_notification.id)\n         assert result[\"status\"] == sample_notification.status.value\n         assert result[\"channel\"] == sample_notification.channel.value\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_get_notification_status_not_found(self, mock_post, client: TestClient):\n         \"\"\"Test getting status for non-existent notification\"\"\"\n         # Mock Identity Service validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         import uuid\n+\n         fake_id = uuid.uuid4()\n         headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-        response = client.get(f\"/api/v1/notifications/{fake_id}/status\",\n-                             headers=headers)\n-        \n+        response = client.get(\n+            f\"/api/v1/notifications/{fake_id}/status\", headers=headers\n+        )\n+\n         assert response.status_code == 404\n         assert \"not found\" in response.json()[\"detail\"].lower()\n-    \n-    @patch('httpx.AsyncClient.post')\n-    def test_cancel_notification_success(self, mock_post, client: TestClient, sample_notification):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    def test_cancel_notification_success(\n+        self, mock_post, client: TestClient, sample_notification\n+    ):\n         \"\"\"Test canceling a pending notification\"\"\"\n         # Mock Identity Service validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         # Mock queue manager\n-        with patch('services.queue_manager.QueueManager') as mock_queue:\n+        with patch(\"services.queue_manager.QueueManager\") as mock_queue:\n             mock_instance = AsyncMock()\n             mock_instance.cancel_notification.return_value = True\n             mock_queue.return_value = mock_instance\n-            \n-            headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-            response = client.delete(f\"/api/v1/notifications/{sample_notification.id}\",\n-                                    headers=headers)\n-            \n+\n+            headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+            response = client.delete(\n+                f\"/api/v1/notifications/{sample_notification.id}\", headers=headers\n+            )\n+\n             assert response.status_code == 200\n             result = response.json()\n             assert \"message\" in result\n             assert \"cancelled\" in result[\"message\"].lower()\n-    \n-    @patch('httpx.AsyncClient.post')\n-    def test_retry_failed_notification_success(self, mock_post, client: TestClient, sample_notification):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    def test_retry_failed_notification_success(\n+        self, mock_post, client: TestClient, sample_notification\n+    ):\n         \"\"\"Test retrying a failed notification\"\"\"\n         # Mock Identity Service validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         # Update notification to failed status\n         sample_notification.status = \"failed\"\n         sample_notification.error_message = \"SMTP server unavailable\"\n-        \n+\n         # Mock Celery task\n-        with patch('tasks.notification_tasks.send_notification') as mock_task:\n+        with patch(\"tasks.notification_tasks.send_notification\") as mock_task:\n             mock_result = MagicMock()\n             mock_result.id = \"retry-task-123\"\n             mock_task.apply_async.return_value = mock_result\n-            \n-            headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-            response = client.post(f\"/api/v1/notifications/{sample_notification.id}/retry\",\n-                                  headers=headers)\n-            \n+\n+            headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n+            response = client.post(\n+                f\"/api/v1/notifications/{sample_notification.id}/retry\", headers=headers\n+            )\n+\n             assert response.status_code == 200\n             result = response.json()\n             assert \"task_id\" in result\n             assert \"status\" in result\n             assert result[\"status\"] == \"queued\"\n@@ -415,220 +460,236 @@\n \n \n @pytest.mark.integration\n class TestTemplateEndpoints:\n     \"\"\"Integration tests for template management endpoints\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_create_template_success(self, mock_post, client: TestClient):\n         \"\"\"Test creating notification template\"\"\"\n         # Mock admin user validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_admin_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_admin_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         headers = {\"Authorization\": \"Bearer admin.jwt.token\"}\n         template_data = SampleAPIData.get_template_create_request()\n-        \n-        response = client.post(\"/api/v1/templates\",\n-                              json=template_data,\n-                              headers=headers)\n-        \n+\n+        response = client.post(\"/api/v1/templates\", json=template_data, headers=headers)\n+\n         assert response.status_code == 201\n         result = response.json()\n         assert \"template_id\" in result\n         assert \"name\" in result\n         assert result[\"name\"] == template_data[\"name\"]\n         assert result[\"channel\"] == template_data[\"channel\"]\n-    \n-    @patch('httpx.AsyncClient.post')\n-    def test_create_template_insufficient_permissions(self, mock_post, client: TestClient):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    def test_create_template_insufficient_permissions(\n+        self, mock_post, client: TestClient\n+    ):\n         \"\"\"Test creating template with insufficient permissions\"\"\"\n         # Mock regular user validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         headers = {\"Authorization\": \"Bearer user.jwt.token\"}\n         template_data = SampleAPIData.get_template_create_request()\n-        \n-        response = client.post(\"/api/v1/templates\",\n-                              json=template_data,\n-                              headers=headers)\n-        \n+\n+        response = client.post(\"/api/v1/templates\", json=template_data, headers=headers)\n+\n         assert response.status_code == 403\n         assert \"insufficient permissions\" in response.json()[\"detail\"].lower()\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_get_templates_success(self, mock_post, client: TestClient):\n         \"\"\"Test getting templates list\"\"\"\n         # Mock user validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n         response = client.get(\"/api/v1/templates\", headers=headers)\n-        \n+\n         assert response.status_code == 200\n         result = response.json()\n         assert \"templates\" in result\n         assert isinstance(result[\"templates\"], list)\n         assert \"total\" in result\n         assert \"page\" in result\n \n \n-@pytest.mark.integration \n+@pytest.mark.integration\n class TestQueueEndpoints:\n     \"\"\"Integration tests for queue management endpoints\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_get_queue_status_success(self, mock_post, client: TestClient):\n         \"\"\"Test getting queue status\"\"\"\n         # Mock admin user validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_admin_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_admin_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         # Mock queue manager\n-        with patch('services.queue_manager.QueueManager') as mock_queue:\n+        with patch(\"services.queue_manager.QueueManager\") as mock_queue:\n             mock_instance = AsyncMock()\n-            mock_instance.get_queue_status.return_value = SampleAPIData.get_queue_status_response()\n+            mock_instance.get_queue_status.return_value = (\n+                SampleAPIData.get_queue_status_response()\n+            )\n             mock_queue.return_value = mock_instance\n-            \n+\n             headers = {\"Authorization\": \"Bearer admin.jwt.token\"}\n             response = client.get(\"/api/v1/queue/status\", headers=headers)\n-            \n+\n             assert response.status_code == 200\n             result = response.json()\n             assert \"total_pending\" in result\n             assert \"queues\" in result\n             assert \"workers\" in result\n-    \n-    @patch('httpx.AsyncClient.post')\n-    def test_get_queue_status_insufficient_permissions(self, mock_post, client: TestClient):\n+\n+    @patch(\"httpx.AsyncClient.post\")\n+    def test_get_queue_status_insufficient_permissions(\n+        self, mock_post, client: TestClient\n+    ):\n         \"\"\"Test getting queue status with insufficient permissions\"\"\"\n         # Mock regular user validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         headers = {\"Authorization\": \"Bearer user.jwt.token\"}\n         response = client.get(\"/api/v1/queue/status\", headers=headers)\n-        \n+\n         assert response.status_code == 403\n         assert \"insufficient permissions\" in response.json()[\"detail\"].lower()\n \n \n @pytest.mark.integration\n class TestErrorHandling:\n     \"\"\"Integration tests for error handling scenarios\"\"\"\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_identity_service_timeout(self, mock_post, client: TestClient):\n         \"\"\"Test handling Identity Service timeout\"\"\"\n         # Mock timeout exception\n         import httpx\n+\n         mock_post.side_effect = httpx.TimeoutException(\"Request timeout\")\n-        \n+\n         headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n         notification_data = {\n             \"type\": \"email\",\n             \"to\": \"test@example.com\",\n-            \"message\": \"Test message\"\n+            \"message\": \"Test message\",\n         }\n-        \n-        response = client.post(\"/api/v1/notifications\",\n-                              json=notification_data,\n-                              headers=headers)\n-        \n+\n+        response = client.post(\n+            \"/api/v1/notifications\", json=notification_data, headers=headers\n+        )\n+\n         assert response.status_code == 503\n         assert \"service temporarily unavailable\" in response.json()[\"detail\"].lower()\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_identity_service_connection_error(self, mock_post, client: TestClient):\n         \"\"\"Test handling Identity Service connection error\"\"\"\n         # Mock connection error\n         import httpx\n+\n         mock_post.side_effect = httpx.ConnectError(\"Connection refused\")\n-        \n+\n         headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n         notification_data = {\n             \"type\": \"email\",\n             \"to\": \"test@example.com\",\n-            \"message\": \"Test message\"\n+            \"message\": \"Test message\",\n         }\n-        \n-        response = client.post(\"/api/v1/notifications\",\n-                              json=notification_data,\n-                              headers=headers)\n-        \n+\n+        response = client.post(\n+            \"/api/v1/notifications\", json=notification_data, headers=headers\n+        )\n+\n         assert response.status_code == 503\n         assert \"service temporarily unavailable\" in response.json()[\"detail\"].lower()\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     def test_celery_task_failure(self, mock_post, client: TestClient):\n         \"\"\"Test handling Celery task submission failure\"\"\"\n         # Mock Identity Service validation\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n-        mock_post.return_value = mock_response\n-        \n+        mock_response.json.return_value = (\n+            IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+        )\n+        mock_post.return_value = mock_response\n+\n         # Mock Celery task failure\n-        with patch('tasks.notification_tasks.send_notification') as mock_task:\n+        with patch(\"tasks.notification_tasks.send_notification\") as mock_task:\n             mock_task.apply_async.side_effect = Exception(\"Celery connection failed\")\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n             notification_data = {\n                 \"type\": \"email\",\n                 \"to\": \"test@example.com\",\n-                \"message\": \"Test message\"\n+                \"message\": \"Test message\",\n             }\n-            \n-            response = client.post(\"/api/v1/notifications\",\n-                                  json=notification_data,\n-                                  headers=headers)\n-            \n+\n+            response = client.post(\n+                \"/api/v1/notifications\", json=notification_data, headers=headers\n+            )\n+\n             assert response.status_code == 500\n             assert \"internal server error\" in response.json()[\"detail\"].lower()\n-    \n+\n     def test_invalid_json_request(self, client: TestClient):\n         \"\"\"Test handling invalid JSON in request\"\"\"\n         headers = {\n             \"Authorization\": \"Bearer valid.jwt.token\",\n-            \"Content-Type\": \"application/json\"\n+            \"Content-Type\": \"application/json\",\n         }\n-        \n+\n         # Send invalid JSON\n-        response = client.post(\"/api/v1/notifications\",\n-                              data=\"invalid json content\",\n-                              headers=headers)\n-        \n+        response = client.post(\n+            \"/api/v1/notifications\", data=\"invalid json content\", headers=headers\n+        )\n+\n         assert response.status_code == 422\n-    \n+\n     def test_request_too_large(self, client: TestClient):\n         \"\"\"Test handling requests that are too large\"\"\"\n         headers = {\n             \"Authorization\": \"Bearer valid.jwt.token\",\n-            \"Content-Type\": \"application/json\"\n+            \"Content-Type\": \"application/json\",\n         }\n-        \n+\n         # Create a very large request\n         large_data = {\n             \"type\": \"email\",\n             \"to\": \"test@example.com\",\n             \"message\": \"x\" * 100000,  # Very large message\n-            \"data\": {\"large_field\": \"y\" * 100000}\n+            \"data\": {\"large_field\": \"y\" * 100000},\n         }\n-        \n-        response = client.post(\"/api/v1/notifications\",\n-                              json=large_data,\n-                              headers=headers)\n-        \n+\n+        response = client.post(\n+            \"/api/v1/notifications\", json=large_data, headers=headers\n+        )\n+\n         # Should either reject as too large or handle gracefully\n-        assert response.status_code in [413, 422, 400]\n\\ No newline at end of file\n+        assert response.status_code in [413, 422, 400]\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/integration/test_celery_tasks.py\t2025-09-09 18:42:10.813219+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/integration/test_celery_tasks.py\t2025-09-10 11:37:02.731744+00:00\n@@ -9,593 +9,685 @@\n from unittest.mock import patch, AsyncMock, MagicMock\n \n from tests.fixtures.sample_data import SampleNotificationData\n from tests.fixtures.mock_responses import CeleryTaskMocks, EmailProviderMocks\n \n+\n @pytest.mark.integration\n @pytest.mark.requires_celery\n class TestNotificationDeliveryTasks:\n     \"\"\"Integration tests for notification delivery Celery tasks\"\"\"\n-    \n+\n     @pytest.fixture\n     def celery_app(self):\n         \"\"\"Create test Celery app\"\"\"\n         from celery import Celery\n-        app = Celery('communication-service-test')\n-        app.config_from_object({\n-            'task_always_eager': True,  # Execute tasks synchronously for testing\n-            'task_eager_propagates': True,\n-            'broker_url': 'memory://',\n-            'result_backend': 'cache+memory://',\n-        })\n+\n+        app = Celery(\"communication-service-test\")\n+        app.config_from_object(\n+            {\n+                \"task_always_eager\": True,  # Execute tasks synchronously for testing\n+                \"task_eager_propagates\": True,\n+                \"broker_url\": \"memory://\",\n+                \"result_backend\": \"cache+memory://\",\n+            }\n+        )\n         return app\n-    \n-    async def test_send_email_notification_task_success(self, celery_app, sample_notification):\n+\n+    async def test_send_email_notification_task_success(\n+        self, celery_app, sample_notification\n+    ):\n         \"\"\"Test successful email notification delivery task\"\"\"\n         from tasks.notification_tasks import send_notification\n-        \n+\n         # Mock email provider\n-        with patch('providers.email.EmailProvider') as mock_provider:\n-            mock_instance = AsyncMock()\n-            mock_instance.send.return_value = EmailProviderMocks.get_successful_send_response()\n-            mock_provider.return_value = mock_instance\n-            \n+        with patch(\"providers.email.EmailProvider\") as mock_provider:\n+            mock_instance = AsyncMock()\n+            mock_instance.send.return_value = (\n+                EmailProviderMocks.get_successful_send_response()\n+            )\n+            mock_provider.return_value = mock_instance\n+\n             # Mock database update\n-            with patch('services.notification_service.NotificationService') as mock_service:\n-                mock_service_instance = AsyncMock()\n-                mock_service_instance.update_notification_status.return_value = sample_notification\n-                mock_service.return_value = mock_service_instance\n-                \n+            with patch(\n+                \"services.notification_service.NotificationService\"\n+            ) as mock_service:\n+                mock_service_instance = AsyncMock()\n+                mock_service_instance.update_notification_status.return_value = (\n+                    sample_notification\n+                )\n+                mock_service.return_value = mock_service_instance\n+\n                 # Execute task\n                 task_data = {\n                     \"notification_id\": str(sample_notification.id),\n                     \"user_id\": str(sample_notification.user_id),\n                     \"channel\": \"email\",\n                     \"recipient\": \"test@example.com\",\n                     \"subject\": \"Test Email\",\n-                    \"content\": \"Test content\"\n-                }\n-                \n+                    \"content\": \"Test content\",\n+                }\n+\n                 result = send_notification.apply(args=[task_data])\n-                \n+\n                 assert result.successful()\n                 task_result = result.result\n                 assert task_result[\"status\"] == \"sent\"\n                 assert \"message_id\" in task_result\n-                \n+\n                 # Verify provider was called\n                 mock_instance.send.assert_called_once()\n-                \n+\n                 # Verify database was updated\n                 mock_service_instance.update_notification_status.assert_called()\n-    \n-    async def test_send_sms_notification_task_success(self, celery_app, sample_notification):\n+\n+    async def test_send_sms_notification_task_success(\n+        self, celery_app, sample_notification\n+    ):\n         \"\"\"Test successful SMS notification delivery task\"\"\"\n         from tasks.notification_tasks import send_notification\n-        \n+\n         # Mock SMS provider\n-        with patch('providers.sms.SMSProvider') as mock_provider:\n+        with patch(\"providers.sms.SMSProvider\") as mock_provider:\n             mock_instance = AsyncMock()\n             mock_instance.send.return_value = {\n                 \"status\": \"sent\",\n                 \"message_id\": f\"sms-{uuid.uuid4()}\",\n-                \"provider\": \"twilio\"\n+                \"provider\": \"twilio\",\n             }\n             mock_provider.return_value = mock_instance\n-            \n+\n             # Mock database update\n-            with patch('services.notification_service.NotificationService') as mock_service:\n-                mock_service_instance = AsyncMock()\n-                mock_service_instance.update_notification_status.return_value = sample_notification\n-                mock_service.return_value = mock_service_instance\n-                \n+            with patch(\n+                \"services.notification_service.NotificationService\"\n+            ) as mock_service:\n+                mock_service_instance = AsyncMock()\n+                mock_service_instance.update_notification_status.return_value = (\n+                    sample_notification\n+                )\n+                mock_service.return_value = mock_service_instance\n+\n                 task_data = {\n                     \"notification_id\": str(sample_notification.id),\n                     \"user_id\": str(sample_notification.user_id),\n                     \"channel\": \"sms\",\n                     \"recipient\": \"+1234567890\",\n-                    \"content\": \"Your verification code is 123456\"\n-                }\n-                \n+                    \"content\": \"Your verification code is 123456\",\n+                }\n+\n                 result = send_notification.apply(args=[task_data])\n-                \n+\n                 assert result.successful()\n                 task_result = result.result\n                 assert task_result[\"status\"] == \"sent\"\n                 assert task_result[\"provider\"] == \"twilio\"\n-    \n-    async def test_send_push_notification_task_success(self, celery_app, sample_notification):\n+\n+    async def test_send_push_notification_task_success(\n+        self, celery_app, sample_notification\n+    ):\n         \"\"\"Test successful push notification delivery task\"\"\"\n         from tasks.notification_tasks import send_notification\n-        \n+\n         # Mock push provider\n-        with patch('providers.push.PushProvider') as mock_provider:\n+        with patch(\"providers.push.PushProvider\") as mock_provider:\n             mock_instance = AsyncMock()\n             mock_instance.send.return_value = {\n                 \"status\": \"sent\",\n                 \"message_id\": f\"push-{uuid.uuid4()}\",\n-                \"provider\": \"fcm\"\n+                \"provider\": \"fcm\",\n             }\n             mock_provider.return_value = mock_instance\n-            \n+\n             # Mock database update\n-            with patch('services.notification_service.NotificationService') as mock_service:\n-                mock_service_instance = AsyncMock()\n-                mock_service_instance.update_notification_status.return_value = sample_notification\n-                mock_service.return_value = mock_service_instance\n-                \n+            with patch(\n+                \"services.notification_service.NotificationService\"\n+            ) as mock_service:\n+                mock_service_instance = AsyncMock()\n+                mock_service_instance.update_notification_status.return_value = (\n+                    sample_notification\n+                )\n+                mock_service.return_value = mock_service_instance\n+\n                 task_data = {\n                     \"notification_id\": str(sample_notification.id),\n                     \"user_id\": str(sample_notification.user_id),\n                     \"channel\": \"push\",\n                     \"recipient\": \"push-token-123456\",\n                     \"title\": \"New Message\",\n                     \"content\": \"You have a new message\",\n-                    \"data\": {\"deep_link\": \"/messages/123\"}\n-                }\n-                \n+                    \"data\": {\"deep_link\": \"/messages/123\"},\n+                }\n+\n                 result = send_notification.apply(args=[task_data])\n-                \n+\n                 assert result.successful()\n                 task_result = result.result\n                 assert task_result[\"status\"] == \"sent\"\n                 assert task_result[\"provider\"] == \"fcm\"\n-    \n-    async def test_send_in_app_notification_task_success(self, celery_app, sample_notification):\n+\n+    async def test_send_in_app_notification_task_success(\n+        self, celery_app, sample_notification\n+    ):\n         \"\"\"Test successful in-app notification delivery task\"\"\"\n         from tasks.notification_tasks import send_notification\n-        \n+\n         # Mock in-app provider\n-        with patch('providers.in_app.InAppProvider') as mock_provider:\n+        with patch(\"providers.in_app.InAppProvider\") as mock_provider:\n             mock_instance = AsyncMock()\n             mock_instance.send.return_value = {\n                 \"status\": \"sent\",\n                 \"message_id\": f\"inapp-{uuid.uuid4()}\",\n-                \"provider\": \"in_app\"\n+                \"provider\": \"in_app\",\n             }\n             mock_provider.return_value = mock_instance\n-            \n+\n             # Mock database update\n-            with patch('services.notification_service.NotificationService') as mock_service:\n-                mock_service_instance = AsyncMock()\n-                mock_service_instance.update_notification_status.return_value = sample_notification\n-                mock_service.return_value = mock_service_instance\n-                \n+            with patch(\n+                \"services.notification_service.NotificationService\"\n+            ) as mock_service:\n+                mock_service_instance = AsyncMock()\n+                mock_service_instance.update_notification_status.return_value = (\n+                    sample_notification\n+                )\n+                mock_service.return_value = mock_service_instance\n+\n                 task_data = {\n                     \"notification_id\": str(sample_notification.id),\n                     \"user_id\": str(sample_notification.user_id),\n                     \"channel\": \"in_app\",\n                     \"title\": \"System Update\",\n-                    \"content\": \"System maintenance completed successfully\"\n-                }\n-                \n+                    \"content\": \"System maintenance completed successfully\",\n+                }\n+\n                 result = send_notification.apply(args=[task_data])\n-                \n+\n                 assert result.successful()\n                 task_result = result.result\n                 assert task_result[\"status\"] == \"sent\"\n                 assert task_result[\"provider\"] == \"in_app\"\n-    \n-    async def test_notification_task_with_template_rendering(self, celery_app, sample_notification, sample_notification_template):\n+\n+    async def test_notification_task_with_template_rendering(\n+        self, celery_app, sample_notification, sample_notification_template\n+    ):\n         \"\"\"Test notification task with template rendering\"\"\"\n         from tasks.notification_tasks import send_notification\n-        \n+\n         # Mock template engine\n-        with patch('services.template_engine.TemplateEngine') as mock_engine:\n+        with patch(\"services.template_engine.TemplateEngine\") as mock_engine:\n             mock_engine_instance = MagicMock()\n-            mock_engine_instance.render.return_value = \"Hello John Doe, welcome to Our Platform!\"\n+            mock_engine_instance.render.return_value = (\n+                \"Hello John Doe, welcome to Our Platform!\"\n+            )\n             mock_engine.return_value = mock_engine_instance\n-            \n+\n             # Mock email provider\n-            with patch('providers.email.EmailProvider') as mock_provider:\n+            with patch(\"providers.email.EmailProvider\") as mock_provider:\n                 mock_instance = AsyncMock()\n-                mock_instance.send.return_value = EmailProviderMocks.get_successful_send_response()\n+                mock_instance.send.return_value = (\n+                    EmailProviderMocks.get_successful_send_response()\n+                )\n                 mock_provider.return_value = mock_instance\n-                \n+\n                 # Mock database update\n-                with patch('services.notification_service.NotificationService') as mock_service:\n+                with patch(\n+                    \"services.notification_service.NotificationService\"\n+                ) as mock_service:\n                     mock_service_instance = AsyncMock()\n-                    mock_service_instance.update_notification_status.return_value = sample_notification\n+                    mock_service_instance.update_notification_status.return_value = (\n+                        sample_notification\n+                    )\n                     mock_service.return_value = mock_service_instance\n-                    \n+\n                     task_data = {\n                         \"notification_id\": str(sample_notification.id),\n                         \"user_id\": str(sample_notification.user_id),\n                         \"channel\": \"email\",\n                         \"recipient\": \"john@example.com\",\n                         \"template_id\": str(sample_notification_template.id),\n                         \"data\": {\n                             \"name\": \"John Doe\",\n                             \"platform\": \"Our Platform\",\n-                            \"action\": \"registration\"\n-                        }\n+                            \"action\": \"registration\",\n+                        },\n                     }\n-                    \n+\n                     result = send_notification.apply(args=[task_data])\n-                    \n+\n                     assert result.successful()\n-                    \n+\n                     # Verify template was rendered\n                     mock_engine_instance.render.assert_called()\n-                    \n+\n                     # Verify rendered content was used\n                     provider_call_args = mock_instance.send.call_args\n-                    assert \"John Doe\" in str(provider_call_args) or \"Our Platform\" in str(provider_call_args)\n+                    assert \"John Doe\" in str(\n+                        provider_call_args\n+                    ) or \"Our Platform\" in str(provider_call_args)\n \n \n @pytest.mark.integration\n @pytest.mark.requires_celery\n class TestNotificationTaskErrorHandling:\n     \"\"\"Test error handling in notification delivery tasks\"\"\"\n-    \n-    async def test_notification_task_provider_failure(self, celery_app, sample_notification):\n+\n+    async def test_notification_task_provider_failure(\n+        self, celery_app, sample_notification\n+    ):\n         \"\"\"Test task handling when notification provider fails\"\"\"\n         from tasks.notification_tasks import send_notification\n-        \n+\n         # Mock provider failure\n-        with patch('providers.email.EmailProvider') as mock_provider:\n+        with patch(\"providers.email.EmailProvider\") as mock_provider:\n             mock_instance = AsyncMock()\n             mock_instance.send.side_effect = Exception(\"SMTP server unavailable\")\n             mock_provider.return_value = mock_instance\n-            \n+\n             # Mock database update\n-            with patch('services.notification_service.NotificationService') as mock_service:\n-                mock_service_instance = AsyncMock()\n-                mock_service_instance.update_notification_status.return_value = sample_notification\n-                mock_service.return_value = mock_service_instance\n-                \n+            with patch(\n+                \"services.notification_service.NotificationService\"\n+            ) as mock_service:\n+                mock_service_instance = AsyncMock()\n+                mock_service_instance.update_notification_status.return_value = (\n+                    sample_notification\n+                )\n+                mock_service.return_value = mock_service_instance\n+\n                 task_data = {\n                     \"notification_id\": str(sample_notification.id),\n                     \"user_id\": str(sample_notification.user_id),\n                     \"channel\": \"email\",\n                     \"recipient\": \"test@example.com\",\n-                    \"content\": \"Test content\"\n-                }\n-                \n+                    \"content\": \"Test content\",\n+                }\n+\n                 result = send_notification.apply(args=[task_data])\n-                \n+\n                 # Task should complete but mark notification as failed\n                 assert result.successful()\n                 task_result = result.result\n                 assert task_result[\"status\"] == \"failed\"\n                 assert \"error\" in task_result\n                 assert \"SMTP server unavailable\" in task_result[\"error\"]\n-                \n+\n                 # Verify database was updated with error\n-                update_calls = mock_service_instance.update_notification_status.call_args_list\n+                update_calls = (\n+                    mock_service_instance.update_notification_status.call_args_list\n+                )\n                 assert any(\"failed\" in str(call) for call in update_calls)\n-    \n-    async def test_notification_task_invalid_template(self, celery_app, sample_notification):\n+\n+    async def test_notification_task_invalid_template(\n+        self, celery_app, sample_notification\n+    ):\n         \"\"\"Test task handling with invalid template\"\"\"\n         from tasks.notification_tasks import send_notification\n-        \n+\n         # Mock template engine failure\n-        with patch('services.template_engine.TemplateEngine') as mock_engine:\n+        with patch(\"services.template_engine.TemplateEngine\") as mock_engine:\n             mock_engine_instance = MagicMock()\n             mock_engine_instance.render.side_effect = Exception(\"Template not found\")\n             mock_engine.return_value = mock_engine_instance\n-            \n+\n             # Mock database update\n-            with patch('services.notification_service.NotificationService') as mock_service:\n-                mock_service_instance = AsyncMock()\n-                mock_service_instance.update_notification_status.return_value = sample_notification\n-                mock_service.return_value = mock_service_instance\n-                \n+            with patch(\n+                \"services.notification_service.NotificationService\"\n+            ) as mock_service:\n+                mock_service_instance = AsyncMock()\n+                mock_service_instance.update_notification_status.return_value = (\n+                    sample_notification\n+                )\n+                mock_service.return_value = mock_service_instance\n+\n                 task_data = {\n                     \"notification_id\": str(sample_notification.id),\n                     \"user_id\": str(sample_notification.user_id),\n                     \"channel\": \"email\",\n                     \"recipient\": \"test@example.com\",\n-                    \"template_id\": \"invalid-template-id\"\n-                }\n-                \n+                    \"template_id\": \"invalid-template-id\",\n+                }\n+\n                 result = send_notification.apply(args=[task_data])\n-                \n+\n                 assert result.successful()\n                 task_result = result.result\n                 assert task_result[\"status\"] == \"failed\"\n                 assert \"template\" in task_result[\"error\"].lower()\n-    \n+\n     async def test_notification_task_database_error(self, celery_app):\n         \"\"\"Test task handling when database update fails\"\"\"\n         from tasks.notification_tasks import send_notification\n-        \n+\n         # Mock successful provider\n-        with patch('providers.email.EmailProvider') as mock_provider:\n-            mock_instance = AsyncMock()\n-            mock_instance.send.return_value = EmailProviderMocks.get_successful_send_response()\n-            mock_provider.return_value = mock_instance\n-            \n+        with patch(\"providers.email.EmailProvider\") as mock_provider:\n+            mock_instance = AsyncMock()\n+            mock_instance.send.return_value = (\n+                EmailProviderMocks.get_successful_send_response()\n+            )\n+            mock_provider.return_value = mock_instance\n+\n             # Mock database failure\n-            with patch('services.notification_service.NotificationService') as mock_service:\n-                mock_service_instance = AsyncMock()\n-                mock_service_instance.update_notification_status.side_effect = Exception(\"Database connection lost\")\n-                mock_service.return_value = mock_service_instance\n-                \n+            with patch(\n+                \"services.notification_service.NotificationService\"\n+            ) as mock_service:\n+                mock_service_instance = AsyncMock()\n+                mock_service_instance.update_notification_status.side_effect = (\n+                    Exception(\"Database connection lost\")\n+                )\n+                mock_service.return_value = mock_service_instance\n+\n                 task_data = {\n                     \"notification_id\": str(uuid.uuid4()),\n                     \"user_id\": str(uuid.uuid4()),\n                     \"channel\": \"email\",\n                     \"recipient\": \"test@example.com\",\n-                    \"content\": \"Test content\"\n-                }\n-                \n+                    \"content\": \"Test content\",\n+                }\n+\n                 result = send_notification.apply(args=[task_data])\n-                \n+\n                 # Task should handle database error gracefully\n                 assert result.successful()\n                 task_result = result.result\n                 # Should still indicate that the notification was sent to provider\n                 # but database update failed\n-                assert \"database\" in task_result.get(\"warning\", \"\").lower() or \\\n-                       task_result[\"status\"] in [\"sent\", \"failed\"]\n+                assert \"database\" in task_result.get(\n+                    \"warning\", \"\"\n+                ).lower() or task_result[\"status\"] in [\"sent\", \"failed\"]\n \n \n @pytest.mark.integration\n @pytest.mark.requires_celery\n class TestNotificationTaskRetryLogic:\n     \"\"\"Test retry logic for notification delivery tasks\"\"\"\n-    \n-    async def test_notification_task_retry_on_transient_error(self, celery_app, sample_notification):\n+\n+    async def test_notification_task_retry_on_transient_error(\n+        self, celery_app, sample_notification\n+    ):\n         \"\"\"Test task retry on transient errors\"\"\"\n         from tasks.notification_tasks import send_notification\n         from celery.exceptions import Retry\n-        \n+\n         # Mock transient error that should trigger retry\n-        with patch('providers.email.EmailProvider') as mock_provider:\n+        with patch(\"providers.email.EmailProvider\") as mock_provider:\n             mock_instance = AsyncMock()\n             # First call fails with transient error, second succeeds\n             mock_instance.send.side_effect = [\n                 Exception(\"Network timeout\"),\n-                EmailProviderMocks.get_successful_send_response()\n+                EmailProviderMocks.get_successful_send_response(),\n             ]\n             mock_provider.return_value = mock_instance\n-            \n+\n             # Mock database update\n-            with patch('services.notification_service.NotificationService') as mock_service:\n-                mock_service_instance = AsyncMock()\n-                mock_service_instance.update_notification_status.return_value = sample_notification\n-                mock_service.return_value = mock_service_instance\n-                \n+            with patch(\n+                \"services.notification_service.NotificationService\"\n+            ) as mock_service:\n+                mock_service_instance = AsyncMock()\n+                mock_service_instance.update_notification_status.return_value = (\n+                    sample_notification\n+                )\n+                mock_service.return_value = mock_service_instance\n+\n                 # Mock task retry mechanism\n-                with patch.object(send_notification, 'retry') as mock_retry:\n+                with patch.object(send_notification, \"retry\") as mock_retry:\n                     mock_retry.side_effect = Retry(\"Retrying due to transient error\")\n-                    \n+\n                     task_data = {\n                         \"notification_id\": str(sample_notification.id),\n                         \"user_id\": str(sample_notification.user_id),\n                         \"channel\": \"email\",\n                         \"recipient\": \"test@example.com\",\n-                        \"content\": \"Test content\"\n+                        \"content\": \"Test content\",\n                     }\n-                    \n+\n                     # First execution should trigger retry\n                     with pytest.raises(Retry):\n                         send_notification.apply(args=[task_data])\n-                    \n+\n                     # Verify retry was called\n                     mock_retry.assert_called_once()\n-    \n-    async def test_notification_task_max_retries_exceeded(self, celery_app, sample_notification):\n+\n+    async def test_notification_task_max_retries_exceeded(\n+        self, celery_app, sample_notification\n+    ):\n         \"\"\"Test task behavior when max retries exceeded\"\"\"\n         from tasks.notification_tasks import send_notification\n-        \n+\n         # Mock persistent failure\n-        with patch('providers.email.EmailProvider') as mock_provider:\n+        with patch(\"providers.email.EmailProvider\") as mock_provider:\n             mock_instance = AsyncMock()\n             mock_instance.send.side_effect = Exception(\"Persistent server error\")\n             mock_provider.return_value = mock_instance\n-            \n+\n             # Mock database update\n-            with patch('services.notification_service.NotificationService') as mock_service:\n-                mock_service_instance = AsyncMock()\n-                mock_service_instance.update_notification_status.return_value = sample_notification\n-                mock_service.return_value = mock_service_instance\n-                \n+            with patch(\n+                \"services.notification_service.NotificationService\"\n+            ) as mock_service:\n+                mock_service_instance = AsyncMock()\n+                mock_service_instance.update_notification_status.return_value = (\n+                    sample_notification\n+                )\n+                mock_service.return_value = mock_service_instance\n+\n                 # Mock task to simulate max retries exceeded\n-                with patch.object(send_notification, 'request') as mock_request:\n+                with patch.object(send_notification, \"request\") as mock_request:\n                     mock_request.retries = 3  # Max retries reached\n-                    \n+\n                     task_data = {\n                         \"notification_id\": str(sample_notification.id),\n                         \"user_id\": str(sample_notification.user_id),\n                         \"channel\": \"email\",\n                         \"recipient\": \"test@example.com\",\n-                        \"content\": \"Test content\"\n+                        \"content\": \"Test content\",\n                     }\n-                    \n+\n                     result = send_notification.apply(args=[task_data])\n-                    \n+\n                     assert result.successful()\n                     task_result = result.result\n                     assert task_result[\"status\"] == \"failed\"\n-                    assert \"max retries\" in task_result[\"error\"].lower() or \\\n-                           \"persistent\" in task_result[\"error\"].lower()\n-    \n+                    assert (\n+                        \"max retries\" in task_result[\"error\"].lower()\n+                        or \"persistent\" in task_result[\"error\"].lower()\n+                    )\n+\n     async def test_notification_task_exponential_backoff(self, celery_app):\n         \"\"\"Test exponential backoff in retry logic\"\"\"\n         from tasks.notification_tasks import send_notification\n-        \n+\n         # Test that retry delays increase exponentially\n         # This is more of a unit test for the retry configuration\n         task_instance = send_notification\n-        \n+\n         # Check retry configuration\n-        assert hasattr(task_instance, 'autoretry_for')\n-        assert hasattr(task_instance, 'retry_backoff')\n-        assert hasattr(task_instance, 'retry_kwargs')\n-        \n+        assert hasattr(task_instance, \"autoretry_for\")\n+        assert hasattr(task_instance, \"retry_backoff\")\n+        assert hasattr(task_instance, \"retry_kwargs\")\n+\n         # Verify exponential backoff configuration\n-        if hasattr(task_instance, 'retry_backoff'):\n+        if hasattr(task_instance, \"retry_backoff\"):\n             assert task_instance.retry_backoff > 0  # Should have backoff delay\n-        \n-        if hasattr(task_instance, 'retry_kwargs'):\n+\n+        if hasattr(task_instance, \"retry_kwargs\"):\n             retry_kwargs = task_instance.retry_kwargs\n-            if 'max_retries' in retry_kwargs:\n-                assert retry_kwargs['max_retries'] > 0\n+            if \"max_retries\" in retry_kwargs:\n+                assert retry_kwargs[\"max_retries\"] > 0\n \n \n @pytest.mark.integration\n @pytest.mark.requires_celery\n class TestNotificationTaskPrioritization:\n     \"\"\"Test task prioritization and queue management\"\"\"\n-    \n+\n     async def test_urgent_notification_high_priority_queue(self, celery_app):\n         \"\"\"Test urgent notifications use high priority queue\"\"\"\n         from tasks.notification_tasks import send_notification\n-        \n+\n         task_data = {\n             \"notification_id\": str(uuid.uuid4()),\n             \"user_id\": str(uuid.uuid4()),\n             \"channel\": \"sms\",\n             \"priority\": \"urgent\",\n             \"recipient\": \"+1234567890\",\n-            \"content\": \"URGENT: Security alert\"\n+            \"content\": \"URGENT: Security alert\",\n         }\n-        \n+\n         # Mock provider\n-        with patch('providers.sms.SMSProvider') as mock_provider:\n-            mock_instance = AsyncMock()\n-            mock_instance.send.return_value = {\"status\": \"sent\", \"message_id\": \"urgent-123\"}\n-            mock_provider.return_value = mock_instance\n-            \n+        with patch(\"providers.sms.SMSProvider\") as mock_provider:\n+            mock_instance = AsyncMock()\n+            mock_instance.send.return_value = {\n+                \"status\": \"sent\",\n+                \"message_id\": \"urgent-123\",\n+            }\n+            mock_provider.return_value = mock_instance\n+\n             # Mock database\n-            with patch('services.notification_service.NotificationService') as mock_service:\n-                mock_service_instance = AsyncMock()\n-                mock_service.return_value = mock_service_instance\n-                \n+            with patch(\n+                \"services.notification_service.NotificationService\"\n+            ) as mock_service:\n+                mock_service_instance = AsyncMock()\n+                mock_service.return_value = mock_service_instance\n+\n                 # Apply task with urgent priority\n                 result = send_notification.apply(\n                     args=[task_data],\n                     priority=9,  # High priority\n-                    routing_key='notifications.urgent'\n-                )\n-                \n+                    routing_key=\"notifications.urgent\",\n+                )\n+\n                 assert result.successful()\n                 task_result = result.result\n                 assert task_result[\"status\"] == \"sent\"\n-    \n+\n     async def test_low_priority_notification_delay(self, celery_app):\n         \"\"\"Test low priority notifications can be delayed\"\"\"\n         from tasks.notification_tasks import send_notification\n-        \n+\n         task_data = {\n             \"notification_id\": str(uuid.uuid4()),\n             \"user_id\": str(uuid.uuid4()),\n             \"channel\": \"email\",\n             \"priority\": \"low\",\n             \"recipient\": \"user@example.com\",\n-            \"content\": \"Low priority newsletter\"\n+            \"content\": \"Low priority newsletter\",\n         }\n-        \n+\n         # Mock provider\n-        with patch('providers.email.EmailProvider') as mock_provider:\n-            mock_instance = AsyncMock()\n-            mock_instance.send.return_value = EmailProviderMocks.get_successful_send_response()\n-            mock_provider.return_value = mock_instance\n-            \n+        with patch(\"providers.email.EmailProvider\") as mock_provider:\n+            mock_instance = AsyncMock()\n+            mock_instance.send.return_value = (\n+                EmailProviderMocks.get_successful_send_response()\n+            )\n+            mock_provider.return_value = mock_instance\n+\n             # Mock database\n-            with patch('services.notification_service.NotificationService') as mock_service:\n-                mock_service_instance = AsyncMock()\n-                mock_service.return_value = mock_service_instance\n-                \n+            with patch(\n+                \"services.notification_service.NotificationService\"\n+            ) as mock_service:\n+                mock_service_instance = AsyncMock()\n+                mock_service.return_value = mock_service_instance\n+\n                 # Apply task with low priority and delay\n                 result = send_notification.apply(\n                     args=[task_data],\n                     priority=1,  # Low priority\n                     countdown=300,  # 5 minute delay\n-                    routing_key='notifications.low'\n-                )\n-                \n+                    routing_key=\"notifications.low\",\n+                )\n+\n                 assert result.successful()\n \n \n @pytest.mark.integration\n @pytest.mark.requires_celery\n class TestBulkNotificationTasks:\n     \"\"\"Test bulk notification processing tasks\"\"\"\n-    \n+\n     async def test_bulk_email_notification_task(self, celery_app):\n         \"\"\"Test bulk email notification processing\"\"\"\n         from tasks.notification_tasks import send_bulk_notifications\n-        \n+\n         # Prepare bulk notification data\n         bulk_data = {\n             \"notifications\": [\n                 {\n                     \"notification_id\": str(uuid.uuid4()),\n                     \"user_id\": str(uuid.uuid4()),\n                     \"channel\": \"email\",\n                     \"recipient\": f\"user{i}@example.com\",\n                     \"subject\": f\"Bulk Email {i+1}\",\n-                    \"content\": f\"This is bulk email {i+1}\"\n+                    \"content\": f\"This is bulk email {i+1}\",\n                 }\n                 for i in range(5)\n             ]\n         }\n-        \n+\n         # Mock provider\n-        with patch('providers.email.EmailProvider') as mock_provider:\n+        with patch(\"providers.email.EmailProvider\") as mock_provider:\n             mock_instance = AsyncMock()\n             mock_instance.send_bulk.return_value = {\n                 \"successful_count\": 5,\n                 \"failed_count\": 0,\n-                \"results\": [{\"status\": \"sent\", \"message_id\": f\"bulk-{i}\"} for i in range(5)]\n+                \"results\": [\n+                    {\"status\": \"sent\", \"message_id\": f\"bulk-{i}\"} for i in range(5)\n+                ],\n             }\n             mock_provider.return_value = mock_instance\n-            \n+\n             # Mock database\n-            with patch('services.notification_service.NotificationService') as mock_service:\n-                mock_service_instance = AsyncMock()\n-                mock_service.return_value = mock_service_instance\n-                \n+            with patch(\n+                \"services.notification_service.NotificationService\"\n+            ) as mock_service:\n+                mock_service_instance = AsyncMock()\n+                mock_service.return_value = mock_service_instance\n+\n                 result = send_bulk_notifications.apply(args=[bulk_data])\n-                \n+\n                 assert result.successful()\n                 task_result = result.result\n                 assert task_result[\"successful_count\"] == 5\n                 assert task_result[\"failed_count\"] == 0\n-    \n+\n     async def test_bulk_notification_partial_failure(self, celery_app):\n         \"\"\"Test bulk notification with partial failures\"\"\"\n         from tasks.notification_tasks import send_bulk_notifications\n-        \n+\n         bulk_data = {\n             \"notifications\": [\n                 {\n                     \"notification_id\": str(uuid.uuid4()),\n                     \"user_id\": str(uuid.uuid4()),\n                     \"channel\": \"email\",\n                     \"recipient\": f\"user{i}@example.com\",\n                     \"subject\": f\"Bulk Email {i+1}\",\n-                    \"content\": f\"Content {i+1}\"\n+                    \"content\": f\"Content {i+1}\",\n                 }\n                 for i in range(3)\n             ]\n         }\n-        \n+\n         # Mock provider with partial failure\n-        with patch('providers.email.EmailProvider') as mock_provider:\n+        with patch(\"providers.email.EmailProvider\") as mock_provider:\n             mock_instance = AsyncMock()\n             mock_instance.send_bulk.return_value = {\n                 \"successful_count\": 2,\n                 \"failed_count\": 1,\n                 \"results\": [\n                     {\"status\": \"sent\", \"message_id\": \"bulk-1\"},\n                     {\"status\": \"sent\", \"message_id\": \"bulk-2\"},\n-                    {\"status\": \"failed\", \"error\": \"Invalid email address\"}\n-                ]\n+                    {\"status\": \"failed\", \"error\": \"Invalid email address\"},\n+                ],\n             }\n             mock_provider.return_value = mock_instance\n-            \n+\n             # Mock database\n-            with patch('services.notification_service.NotificationService') as mock_service:\n-                mock_service_instance = AsyncMock()\n-                mock_service.return_value = mock_service_instance\n-                \n+            with patch(\n+                \"services.notification_service.NotificationService\"\n+            ) as mock_service:\n+                mock_service_instance = AsyncMock()\n+                mock_service.return_value = mock_service_instance\n+\n                 result = send_bulk_notifications.apply(args=[bulk_data])\n-                \n+\n                 assert result.successful()\n                 task_result = result.result\n                 assert task_result[\"successful_count\"] == 2\n                 assert task_result[\"failed_count\"] == 1\n                 assert \"partial_success\" in task_result[\"status\"]\n@@ -603,79 +695,86 @@\n \n @pytest.mark.integration\n @pytest.mark.requires_celery\n class TestNotificationTaskMonitoring:\n     \"\"\"Test task monitoring and metrics collection\"\"\"\n-    \n+\n     async def test_task_execution_metrics(self, celery_app, sample_notification):\n         \"\"\"Test task execution metrics are collected\"\"\"\n         from tasks.notification_tasks import send_notification\n-        \n+\n         # Mock provider\n-        with patch('providers.email.EmailProvider') as mock_provider:\n-            mock_instance = AsyncMock()\n-            mock_instance.send.return_value = EmailProviderMocks.get_successful_send_response()\n-            mock_provider.return_value = mock_instance\n-            \n+        with patch(\"providers.email.EmailProvider\") as mock_provider:\n+            mock_instance = AsyncMock()\n+            mock_instance.send.return_value = (\n+                EmailProviderMocks.get_successful_send_response()\n+            )\n+            mock_provider.return_value = mock_instance\n+\n             # Mock metrics collection\n-            with patch('prometheus_client.Counter') as mock_counter, \\\n-                 patch('prometheus_client.Histogram') as mock_histogram:\n-                \n+            with patch(\"prometheus_client.Counter\") as mock_counter, patch(\n+                \"prometheus_client.Histogram\"\n+            ) as mock_histogram:\n+\n                 mock_counter_instance = MagicMock()\n                 mock_histogram_instance = MagicMock()\n                 mock_counter.return_value = mock_counter_instance\n                 mock_histogram.return_value = mock_histogram_instance\n-                \n+\n                 # Mock database\n-                with patch('services.notification_service.NotificationService') as mock_service:\n+                with patch(\n+                    \"services.notification_service.NotificationService\"\n+                ) as mock_service:\n                     mock_service_instance = AsyncMock()\n                     mock_service.return_value = mock_service_instance\n-                    \n+\n                     task_data = {\n                         \"notification_id\": str(sample_notification.id),\n                         \"user_id\": str(sample_notification.user_id),\n                         \"channel\": \"email\",\n                         \"recipient\": \"test@example.com\",\n-                        \"content\": \"Test content\"\n+                        \"content\": \"Test content\",\n                     }\n-                    \n+\n                     result = send_notification.apply(args=[task_data])\n-                    \n+\n                     assert result.successful()\n-                    \n+\n                     # Verify metrics were recorded (if implemented)\n                     # This depends on the actual metrics implementation\n-    \n+\n     async def test_task_failure_alerting(self, celery_app):\n         \"\"\"Test task failure triggers appropriate alerts\"\"\"\n         from tasks.notification_tasks import send_notification\n-        \n+\n         # Mock provider failure\n-        with patch('providers.email.EmailProvider') as mock_provider:\n+        with patch(\"providers.email.EmailProvider\") as mock_provider:\n             mock_instance = AsyncMock()\n             mock_instance.send.side_effect = Exception(\"Critical system failure\")\n             mock_provider.return_value = mock_instance\n-            \n+\n             # Mock alerting system\n-            with patch('services.alerting.AlertManager') as mock_alerting:\n+            with patch(\"services.alerting.AlertManager\") as mock_alerting:\n                 mock_alert_instance = AsyncMock()\n                 mock_alerting.return_value = mock_alert_instance\n-                \n+\n                 # Mock database\n-                with patch('services.notification_service.NotificationService') as mock_service:\n+                with patch(\n+                    \"services.notification_service.NotificationService\"\n+                ) as mock_service:\n                     mock_service_instance = AsyncMock()\n                     mock_service.return_value = mock_service_instance\n-                    \n+\n                     task_data = {\n                         \"notification_id\": str(uuid.uuid4()),\n                         \"user_id\": str(uuid.uuid4()),\n                         \"channel\": \"email\",\n                         \"recipient\": \"test@example.com\",\n-                        \"content\": \"Test content\"\n+                        \"content\": \"Test content\",\n                     }\n-                    \n+\n                     result = send_notification.apply(args=[task_data])\n-                    \n+\n                     assert result.successful()\n-                    \n+\n                     # Verify alert was triggered (if implemented)\n-                    # This depends on the actual alerting implementation\n\\ No newline at end of file\n+                    # This depends on the actual alerting implementation\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_health.py\t2025-09-09 13:35:43.648591+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_health.py\t2025-09-10 11:37:02.791714+00:00\n@@ -1,294 +1,327 @@\n \"\"\"\n Tests for health check endpoint and functionality\n \"\"\"\n+\n import pytest\n from unittest.mock import patch, MagicMock, AsyncMock\n from fastapi.testclient import TestClient\n \n from main import app\n \n+\n class TestHealthEndpoint:\n     \"\"\"Test health check endpoint\"\"\"\n-    \n+\n     def test_health_endpoint_success(self):\n         \"\"\"Test successful health check\"\"\"\n-        with patch('main.get_uptime') as mock_uptime, \\\n-             patch('main.get_memory_usage') as mock_memory, \\\n-             patch('main.get_active_connections') as mock_connections, \\\n-             patch('main.redis.from_url') as mock_redis, \\\n-             patch('main.httpx.AsyncClient') as mock_httpx:\n-            \n+        with patch(\"main.get_uptime\") as mock_uptime, patch(\n+            \"main.get_memory_usage\"\n+        ) as mock_memory, patch(\n+            \"main.get_active_connections\"\n+        ) as mock_connections, patch(\n+            \"main.redis.from_url\"\n+        ) as mock_redis, patch(\n+            \"main.httpx.AsyncClient\"\n+        ) as mock_httpx:\n+\n             # Mock helper functions\n             mock_uptime.return_value = 3600\n             mock_memory.return_value = 128.5\n             mock_connections.return_value = 10\n-            \n+\n             # Mock Redis health check\n             mock_redis_client = AsyncMock()\n             mock_redis_client.ping = AsyncMock(return_value=True)\n             mock_redis_client.close = AsyncMock()\n             mock_redis.return_value = mock_redis_client\n-            \n+\n             # Mock Identity Service health check\n             mock_http_client = AsyncMock()\n             mock_response = MagicMock()\n             mock_response.status_code = 200\n             mock_http_client.get.return_value = mock_response\n             mock_httpx.return_value.__aenter__.return_value = mock_http_client\n-            \n-            client = TestClient(app)\n-            response = client.get(\"/health\")\n-            \n-            assert response.status_code == 200\n-            \n+\n+            client = TestClient(app)\n+            response = client.get(\"/health\")\n+\n+            assert response.status_code == 200\n+\n             data = response.json()\n             assert data[\"service\"] == \"communication-service\"\n             assert data[\"status\"] == \"healthy\"\n             assert data[\"version\"] == \"1.0.0\"\n             assert data[\"port\"] == 8003\n-            \n+\n             # Check dependencies\n             assert \"dependencies\" in data\n             assert data[\"dependencies\"][\"redis\"] == \"healthy\"\n             assert data[\"dependencies\"][\"identity-service\"] == \"healthy\"\n-            \n+\n             # Check metrics\n             assert \"metrics\" in data\n             assert data[\"metrics\"][\"uptime_seconds\"] == 3600\n             assert data[\"metrics\"][\"memory_usage_mb\"] == 128.5\n             assert data[\"metrics\"][\"active_connections\"] == 10\n-    \n+\n     def test_health_endpoint_degraded_redis(self):\n         \"\"\"Test health check with Redis failure\"\"\"\n-        with patch('main.get_uptime') as mock_uptime, \\\n-             patch('main.get_memory_usage') as mock_memory, \\\n-             patch('main.get_active_connections') as mock_connections, \\\n-             patch('main.redis.from_url') as mock_redis, \\\n-             patch('main.httpx.AsyncClient') as mock_httpx:\n-            \n+        with patch(\"main.get_uptime\") as mock_uptime, patch(\n+            \"main.get_memory_usage\"\n+        ) as mock_memory, patch(\n+            \"main.get_active_connections\"\n+        ) as mock_connections, patch(\n+            \"main.redis.from_url\"\n+        ) as mock_redis, patch(\n+            \"main.httpx.AsyncClient\"\n+        ) as mock_httpx:\n+\n             mock_uptime.return_value = 3600\n             mock_memory.return_value = 128.5\n             mock_connections.return_value = 10\n-            \n+\n             # Mock Redis failure\n             mock_redis_client = AsyncMock()\n-            mock_redis_client.ping = AsyncMock(side_effect=Exception(\"Redis connection failed\"))\n-            mock_redis_client.close = AsyncMock()\n-            mock_redis.return_value = mock_redis_client\n-            \n+            mock_redis_client.ping = AsyncMock(\n+                side_effect=Exception(\"Redis connection failed\")\n+            )\n+            mock_redis_client.close = AsyncMock()\n+            mock_redis.return_value = mock_redis_client\n+\n             # Mock Identity Service success\n             mock_http_client = AsyncMock()\n             mock_response = MagicMock()\n             mock_response.status_code = 200\n             mock_http_client.get.return_value = mock_response\n             mock_httpx.return_value.__aenter__.return_value = mock_http_client\n-            \n-            client = TestClient(app)\n-            response = client.get(\"/health\")\n-            \n-            assert response.status_code == 200\n-            \n+\n+            client = TestClient(app)\n+            response = client.get(\"/health\")\n+\n+            assert response.status_code == 200\n+\n             data = response.json()\n             assert data[\"status\"] == \"degraded\"\n             assert data[\"dependencies\"][\"redis\"] == \"unhealthy\"\n             assert data[\"dependencies\"][\"identity-service\"] == \"healthy\"\n-    \n+\n     def test_health_endpoint_degraded_identity_service(self):\n         \"\"\"Test health check with Identity Service failure\"\"\"\n-        with patch('main.get_uptime') as mock_uptime, \\\n-             patch('main.get_memory_usage') as mock_memory, \\\n-             patch('main.get_active_connections') as mock_connections, \\\n-             patch('main.redis.from_url') as mock_redis, \\\n-             patch('main.httpx.AsyncClient') as mock_httpx:\n-            \n+        with patch(\"main.get_uptime\") as mock_uptime, patch(\n+            \"main.get_memory_usage\"\n+        ) as mock_memory, patch(\n+            \"main.get_active_connections\"\n+        ) as mock_connections, patch(\n+            \"main.redis.from_url\"\n+        ) as mock_redis, patch(\n+            \"main.httpx.AsyncClient\"\n+        ) as mock_httpx:\n+\n             mock_uptime.return_value = 3600\n             mock_memory.return_value = 128.5\n             mock_connections.return_value = 10\n-            \n+\n             # Mock Redis success\n             mock_redis_client = AsyncMock()\n             mock_redis_client.ping = AsyncMock(return_value=True)\n             mock_redis_client.close = AsyncMock()\n             mock_redis.return_value = mock_redis_client\n-            \n+\n             # Mock Identity Service failure\n             mock_http_client = AsyncMock()\n             mock_http_client.get.side_effect = Exception(\"Service unavailable\")\n             mock_httpx.return_value.__aenter__.return_value = mock_http_client\n-            \n-            client = TestClient(app)\n-            response = client.get(\"/health\")\n-            \n-            assert response.status_code == 200\n-            \n+\n+            client = TestClient(app)\n+            response = client.get(\"/health\")\n+\n+            assert response.status_code == 200\n+\n             data = response.json()\n             assert data[\"status\"] == \"degraded\"\n             assert data[\"dependencies\"][\"redis\"] == \"healthy\"\n             assert data[\"dependencies\"][\"identity-service\"] == \"unhealthy\"\n-    \n+\n     def test_health_endpoint_all_degraded(self):\n         \"\"\"Test health check with all dependencies failing\"\"\"\n-        with patch('main.get_uptime') as mock_uptime, \\\n-             patch('main.get_memory_usage') as mock_memory, \\\n-             patch('main.get_active_connections') as mock_connections, \\\n-             patch('main.redis.from_url') as mock_redis, \\\n-             patch('main.httpx.AsyncClient') as mock_httpx:\n-            \n+        with patch(\"main.get_uptime\") as mock_uptime, patch(\n+            \"main.get_memory_usage\"\n+        ) as mock_memory, patch(\n+            \"main.get_active_connections\"\n+        ) as mock_connections, patch(\n+            \"main.redis.from_url\"\n+        ) as mock_redis, patch(\n+            \"main.httpx.AsyncClient\"\n+        ) as mock_httpx:\n+\n             mock_uptime.return_value = 3600\n             mock_memory.return_value = 128.5\n             mock_connections.return_value = 10\n-            \n+\n             # Mock Redis failure\n             mock_redis_client = AsyncMock()\n             mock_redis_client.ping = AsyncMock(side_effect=Exception(\"Redis failed\"))\n             mock_redis_client.close = AsyncMock()\n             mock_redis.return_value = mock_redis_client\n-            \n+\n             # Mock Identity Service failure\n             mock_http_client = AsyncMock()\n             mock_http_client.get.side_effect = Exception(\"Service failed\")\n             mock_httpx.return_value.__aenter__.return_value = mock_http_client\n-            \n-            client = TestClient(app)\n-            response = client.get(\"/health\")\n-            \n-            assert response.status_code == 200\n-            \n+\n+            client = TestClient(app)\n+            response = client.get(\"/health\")\n+\n+            assert response.status_code == 200\n+\n             data = response.json()\n             assert data[\"status\"] == \"degraded\"\n             assert data[\"dependencies\"][\"redis\"] == \"unhealthy\"\n             assert data[\"dependencies\"][\"identity-service\"] == \"unhealthy\"\n             assert data[\"dependencies\"][\"celery-workers\"] == \"not-implemented\"\n \n+\n class TestHealthHelperFunctions:\n     \"\"\"Test health check helper functions\"\"\"\n-    \n+\n     def test_get_uptime(self):\n         \"\"\"Test uptime calculation\"\"\"\n         import time\n         from main import start_time, get_uptime\n-        \n+\n         # Mock start_time to be 100 seconds ago\n-        with patch('main.start_time', time.time() - 100):\n+        with patch(\"main.start_time\", time.time() - 100):\n             uptime = get_uptime()\n-            \n+\n             # Should be approximately 100 seconds (allow small variance)\n             assert 95 <= uptime <= 105\n-    \n+\n     def test_get_memory_usage(self):\n         \"\"\"Test memory usage retrieval\"\"\"\n-        with patch('main.psutil.Process') as mock_process_class:\n+        with patch(\"main.psutil.Process\") as mock_process_class:\n             mock_process = MagicMock()\n             mock_memory_info = MagicMock()\n             mock_memory_info.rss = 134217728  # 128 MB in bytes\n             mock_process.memory_info.return_value = mock_memory_info\n             mock_process_class.return_value = mock_process\n-            \n+\n             from main import get_memory_usage\n+\n             memory_mb = get_memory_usage()\n-            \n+\n             assert memory_mb == 128.0  # Should be 128.0 MB\n-    \n+\n     def test_get_active_connections(self):\n         \"\"\"Test active connections count\"\"\"\n         from main import get_active_connections\n-        \n+\n         # Currently returns 0 as placeholder\n         connections = get_active_connections()\n         assert connections == 0\n \n+\n class TestHealthIntegration:\n     \"\"\"Integration tests for health functionality\"\"\"\n-    \n+\n     def test_health_with_real_app_structure(self):\n         \"\"\"Test health endpoint with actual app structure\"\"\"\n         client = TestClient(app)\n-        \n+\n         # This test will use the actual main.py health endpoint\n         # but mock external dependencies\n-        with patch('main.redis.from_url') as mock_redis, \\\n-             patch('main.httpx.AsyncClient') as mock_httpx:\n-            \n+        with patch(\"main.redis.from_url\") as mock_redis, patch(\n+            \"main.httpx.AsyncClient\"\n+        ) as mock_httpx:\n+\n             # Mock successful Redis\n             mock_redis_client = AsyncMock()\n             mock_redis_client.ping = AsyncMock(return_value=True)\n             mock_redis_client.close = AsyncMock()\n             mock_redis.return_value = mock_redis_client\n-            \n+\n             # Mock successful Identity Service\n             mock_http_client = AsyncMock()\n             mock_response = MagicMock()\n             mock_response.status_code = 200\n             mock_http_client.get.return_value = mock_response\n             mock_httpx.return_value.__aenter__.return_value = mock_http_client\n-            \n-            response = client.get(\"/health\")\n-            \n+\n+            response = client.get(\"/health\")\n+\n             assert response.status_code == 200\n             assert response.headers[\"content-type\"] == \"application/json\"\n-            \n-            data = response.json()\n-            \n+\n+            data = response.json()\n+\n             # Verify required fields exist\n-            required_fields = [\"service\", \"status\", \"version\", \"port\", \"dependencies\", \"metrics\"]\n+            required_fields = [\n+                \"service\",\n+                \"status\",\n+                \"version\",\n+                \"port\",\n+                \"dependencies\",\n+                \"metrics\",\n+            ]\n             for field in required_fields:\n                 assert field in data\n-            \n+\n             # Verify dependencies structure\n             assert isinstance(data[\"dependencies\"], dict)\n             dependency_keys = [\"redis\", \"identity-service\", \"celery-workers\"]\n             for key in dependency_keys:\n                 assert key in data[\"dependencies\"]\n-            \n+\n             # Verify metrics structure\n             assert isinstance(data[\"metrics\"], dict)\n             metric_keys = [\"uptime_seconds\", \"active_connections\", \"memory_usage_mb\"]\n             for key in metric_keys:\n                 assert key in data[\"metrics\"]\n                 assert isinstance(data[\"metrics\"][key], (int, float))\n \n+\n class TestHealthResponseFormat:\n     \"\"\"Test health response format compliance\"\"\"\n-    \n+\n     def test_health_response_schema(self):\n         \"\"\"Test that health response matches expected schema\"\"\"\n-        with patch('main.redis.from_url') as mock_redis, \\\n-             patch('main.httpx.AsyncClient') as mock_httpx:\n-            \n+        with patch(\"main.redis.from_url\") as mock_redis, patch(\n+            \"main.httpx.AsyncClient\"\n+        ) as mock_httpx:\n+\n             # Mock all dependencies as healthy\n             mock_redis_client = AsyncMock()\n             mock_redis_client.ping = AsyncMock(return_value=True)\n             mock_redis_client.close = AsyncMock()\n             mock_redis.return_value = mock_redis_client\n-            \n+\n             mock_http_client = AsyncMock()\n             mock_response = MagicMock()\n             mock_response.status_code = 200\n             mock_http_client.get.return_value = mock_response\n             mock_httpx.return_value.__aenter__.return_value = mock_http_client\n-            \n-            client = TestClient(app)\n-            response = client.get(\"/health\")\n-            data = response.json()\n-            \n+\n+            client = TestClient(app)\n+            response = client.get(\"/health\")\n+            data = response.json()\n+\n             # Verify top-level schema\n             assert isinstance(data[\"service\"], str)\n             assert data[\"status\"] in [\"healthy\", \"degraded\", \"unhealthy\"]\n             assert isinstance(data[\"version\"], str)\n             assert isinstance(data[\"port\"], int)\n             assert isinstance(data[\"dependencies\"], dict)\n             assert isinstance(data[\"metrics\"], dict)\n-            \n+\n             # Verify dependencies values\n             for dep_name, dep_status in data[\"dependencies\"].items():\n                 assert dep_status in [\"healthy\", \"unhealthy\", \"not-implemented\"]\n-            \n+\n             # Verify metrics values\n             assert isinstance(data[\"metrics\"][\"uptime_seconds\"], int)\n             assert isinstance(data[\"metrics\"][\"active_connections\"], int)\n             assert isinstance(data[\"metrics\"][\"memory_usage_mb\"], (int, float))\n-            \n+\n             # Verify numeric ranges make sense\n             assert data[\"metrics\"][\"uptime_seconds\"] >= 0\n             assert data[\"metrics\"][\"active_connections\"] >= 0\n-            assert data[\"metrics\"][\"memory_usage_mb\"] > 0\n\\ No newline at end of file\n+            assert data[\"metrics\"][\"memory_usage_mb\"] > 0\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/performance/test_load_testing.py\t2025-09-09 19:33:50.135506+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/performance/test_load_testing.py\t2025-09-10 11:37:02.854749+00:00\n@@ -19,190 +19,219 @@\n \n @pytest.mark.performance\n @pytest.mark.slow\n class TestNotificationAPIPerformance:\n     \"\"\"Performance tests for notification API endpoints\"\"\"\n-    \n+\n     async def test_single_notification_endpoint_performance(self, client: TestClient):\n         \"\"\"Test performance of single notification endpoint\"\"\"\n-        \n+\n         # Mock authentication and task processing\n-        with patch('httpx.AsyncClient.post') as mock_identity, \\\n-             patch('tasks.notification_tasks.send_notification') as mock_task:\n-            \n+        with patch(\"httpx.AsyncClient.post\") as mock_identity, patch(\n+            \"tasks.notification_tasks.send_notification\"\n+        ) as mock_task:\n+\n             # Mock Identity Service\n             mock_response = AsyncMock()\n             mock_response.status_code = 200\n-            mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+            mock_response.json.return_value = (\n+                IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+            )\n             mock_identity.return_value = mock_response\n-            \n+\n             # Mock task\n             mock_result = MagicMock()\n             mock_result.id = \"perf-task-123\"\n             mock_task.apply_async.return_value = mock_result\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n             notification_data = {\n                 \"type\": \"email\",\n                 \"to\": \"perf@example.com\",\n                 \"subject\": \"Performance Test\",\n-                \"message\": \"Testing API performance\"\n+                \"message\": \"Testing API performance\",\n             }\n-            \n+\n             # Measure response times for multiple requests\n             response_times = []\n             success_count = 0\n-            \n+\n             for i in range(50):  # Test 50 requests\n                 start_time = time.time()\n-                response = client.post(\"/api/v1/notifications\", \n-                                     json=notification_data, \n-                                     headers=headers)\n+                response = client.post(\n+                    \"/api/v1/notifications\", json=notification_data, headers=headers\n+                )\n                 end_time = time.time()\n-                \n+\n                 response_time = end_time - start_time\n                 response_times.append(response_time)\n-                \n+\n                 if response.status_code == 200:\n                     success_count += 1\n-            \n+\n             # Performance assertions\n             avg_response_time = statistics.mean(response_times)\n-            p95_response_time = statistics.quantiles(response_times, n=20)[18]  # 95th percentile\n-            \n-            assert avg_response_time < 0.1, f\"Average response time too high: {avg_response_time:.3f}s\"\n-            assert p95_response_time < 0.2, f\"95th percentile response time too high: {p95_response_time:.3f}s\"\n-            assert success_count == 50, f\"Not all requests succeeded: {success_count}/50\"\n-            \n+            p95_response_time = statistics.quantiles(response_times, n=20)[\n+                18\n+            ]  # 95th percentile\n+\n+            assert (\n+                avg_response_time < 0.1\n+            ), f\"Average response time too high: {avg_response_time:.3f}s\"\n+            assert (\n+                p95_response_time < 0.2\n+            ), f\"95th percentile response time too high: {p95_response_time:.3f}s\"\n+            assert (\n+                success_count == 50\n+            ), f\"Not all requests succeeded: {success_count}/50\"\n+\n             print(f\"Performance metrics:\")\n             print(f\"- Average response time: {avg_response_time:.3f}s\")\n             print(f\"- 95th percentile: {p95_response_time:.3f}s\")\n             print(f\"- Success rate: {success_count}/50 (100%)\")\n-    \n+\n     async def test_concurrent_notification_requests(self, client: TestClient):\n         \"\"\"Test API performance under concurrent load\"\"\"\n-        \n-        with patch('httpx.AsyncClient.post') as mock_identity, \\\n-             patch('tasks.notification_tasks.send_notification') as mock_task:\n-            \n+\n+        with patch(\"httpx.AsyncClient.post\") as mock_identity, patch(\n+            \"tasks.notification_tasks.send_notification\"\n+        ) as mock_task:\n+\n             # Mock responses\n             mock_response = AsyncMock()\n             mock_response.status_code = 200\n-            mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+            mock_response.json.return_value = (\n+                IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+            )\n             mock_identity.return_value = mock_response\n-            \n+\n             mock_result = MagicMock()\n             mock_result.id = \"concurrent-task\"\n             mock_task.apply_async.return_value = mock_result\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-            \n+\n             def make_request(request_id):\n                 \"\"\"Make a single notification request\"\"\"\n                 notification_data = {\n                     \"type\": \"email\",\n                     \"to\": f\"concurrent{request_id}@example.com\",\n                     \"subject\": f\"Concurrent Test {request_id}\",\n-                    \"message\": f\"Testing concurrent requests {request_id}\"\n+                    \"message\": f\"Testing concurrent requests {request_id}\",\n                 }\n-                \n+\n                 start_time = time.time()\n-                response = client.post(\"/api/v1/notifications\",\n-                                     json=notification_data,\n-                                     headers=headers)\n+                response = client.post(\n+                    \"/api/v1/notifications\", json=notification_data, headers=headers\n+                )\n                 end_time = time.time()\n-                \n+\n                 return {\n                     \"request_id\": request_id,\n                     \"status_code\": response.status_code,\n                     \"response_time\": end_time - start_time,\n-                    \"success\": response.status_code == 200\n+                    \"success\": response.status_code == 200,\n                 }\n-            \n+\n             # Run concurrent requests\n             concurrent_requests = 20\n             start_time = time.time()\n-            \n+\n             with ThreadPoolExecutor(max_workers=10) as executor:\n-                futures = [executor.submit(make_request, i) for i in range(concurrent_requests)]\n+                futures = [\n+                    executor.submit(make_request, i) for i in range(concurrent_requests)\n+                ]\n                 results = [future.result() for future in futures]\n-            \n+\n             total_time = time.time() - start_time\n-            \n+\n             # Analyze results\n             successful_requests = [r for r in results if r[\"success\"]]\n             response_times = [r[\"response_time\"] for r in results]\n-            \n+\n             success_rate = len(successful_requests) / len(results) * 100\n             avg_response_time = statistics.mean(response_times)\n             max_response_time = max(response_times)\n             throughput = len(results) / total_time\n-            \n+\n             # Performance assertions\n             assert success_rate >= 95, f\"Success rate too low: {success_rate:.1f}%\"\n-            assert avg_response_time < 0.5, f\"Average response time under load too high: {avg_response_time:.3f}s\"\n-            assert throughput >= 10, f\"Throughput too low: {throughput:.1f} requests/second\"\n-            \n+            assert (\n+                avg_response_time < 0.5\n+            ), f\"Average response time under load too high: {avg_response_time:.3f}s\"\n+            assert (\n+                throughput >= 10\n+            ), f\"Throughput too low: {throughput:.1f} requests/second\"\n+\n             print(f\"Concurrent load test results:\")\n             print(f\"- Requests: {concurrent_requests}\")\n             print(f\"- Success rate: {success_rate:.1f}%\")\n             print(f\"- Average response time: {avg_response_time:.3f}s\")\n-            print(f\"- Max response time: {max_response_time:.3f}s\") \n+            print(f\"- Max response time: {max_response_time:.3f}s\")\n             print(f\"- Throughput: {throughput:.1f} requests/second\")\n-    \n+\n     async def test_bulk_notification_performance(self, client: TestClient):\n         \"\"\"Test performance of bulk notification processing\"\"\"\n-        \n-        with patch('httpx.AsyncClient.post') as mock_identity, \\\n-             patch('tasks.notification_tasks.send_notification') as mock_task:\n-            \n+\n+        with patch(\"httpx.AsyncClient.post\") as mock_identity, patch(\n+            \"tasks.notification_tasks.send_notification\"\n+        ) as mock_task:\n+\n             mock_response = AsyncMock()\n             mock_response.status_code = 200\n-            mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+            mock_response.json.return_value = (\n+                IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+            )\n             mock_identity.return_value = mock_response\n-            \n+\n             mock_result = MagicMock()\n             mock_task.apply_async.return_value = mock_result\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-            \n+\n             # Prepare bulk notification data\n             bulk_size = 100\n             notifications = []\n-            \n+\n             for i in range(bulk_size):\n                 notification_data = {\n                     \"type\": \"email\",\n-                    \"to\": f\"bulk{i}@example.com\", \n+                    \"to\": f\"bulk{i}@example.com\",\n                     \"subject\": f\"Bulk Test {i}\",\n-                    \"message\": f\"Bulk notification {i}\"\n+                    \"message\": f\"Bulk notification {i}\",\n                 }\n                 notifications.append(notification_data)\n-            \n+\n             # Measure bulk processing time\n             start_time = time.time()\n-            \n+\n             # Send all notifications rapidly\n             responses = []\n             for notification in notifications:\n-                response = client.post(\"/api/v1/notifications\",\n-                                     json=notification,\n-                                     headers=headers)\n+                response = client.post(\n+                    \"/api/v1/notifications\", json=notification, headers=headers\n+                )\n                 responses.append(response)\n-            \n+\n             processing_time = time.time() - start_time\n-            \n+\n             # Analyze results\n             successful_responses = [r for r in responses if r.status_code == 200]\n             success_rate = len(successful_responses) / len(responses) * 100\n             throughput = len(responses) / processing_time\n-            \n+\n             # Performance assertions\n-            assert success_rate >= 98, f\"Bulk processing success rate too low: {success_rate:.1f}%\"\n-            assert throughput >= 50, f\"Bulk processing throughput too low: {throughput:.1f} notifications/second\"\n-            assert processing_time < 10, f\"Bulk processing took too long: {processing_time:.1f}s\"\n-            \n+            assert (\n+                success_rate >= 98\n+            ), f\"Bulk processing success rate too low: {success_rate:.1f}%\"\n+            assert (\n+                throughput >= 50\n+            ), f\"Bulk processing throughput too low: {throughput:.1f} notifications/second\"\n+            assert (\n+                processing_time < 10\n+            ), f\"Bulk processing took too long: {processing_time:.1f}s\"\n+\n             print(f\"Bulk notification performance:\")\n             print(f\"- Notifications: {bulk_size}\")\n             print(f\"- Processing time: {processing_time:.2f}s\")\n             print(f\"- Success rate: {success_rate:.1f}%\")\n             print(f\"- Throughput: {throughput:.1f} notifications/second\")\n@@ -210,319 +239,335 @@\n \n @pytest.mark.performance\n @pytest.mark.slow\n class TestCeleryQueuePerformance:\n     \"\"\"Performance tests for Celery task queues\"\"\"\n-    \n-    @patch('tasks.notification_tasks.send_notification')\n-    @patch('celery.app.Celery.send_task')\n-    async def test_queue_throughput_performance(self, mock_send_task, mock_notification_task):\n+\n+    @patch(\"tasks.notification_tasks.send_notification\")\n+    @patch(\"celery.app.Celery.send_task\")\n+    async def test_queue_throughput_performance(\n+        self, mock_send_task, mock_notification_task\n+    ):\n         \"\"\"Test Celery queue throughput under load\"\"\"\n-        \n+\n         # Mock task execution\n         mock_result = MagicMock()\n         mock_result.id = \"queue-perf-task\"\n         mock_send_task.return_value = mock_result\n-        \n+\n         mock_notification_task.apply_async.return_value = mock_result\n-        \n+\n         # Simulate high-volume task queuing\n         task_count = 500\n         start_time = time.time()\n-        \n+\n         task_ids = []\n         for i in range(task_count):\n             task_data = {\n                 \"notification_id\": f\"queue-test-{i}\",\n                 \"recipient\": f\"queue{i}@example.com\",\n                 \"content\": f\"Queue performance test {i}\",\n-                \"priority\": \"normal\"\n+                \"priority\": \"normal\",\n             }\n-            \n+\n             # Queue task\n             result = mock_notification_task.apply_async.return_value\n             task_ids.append(result.id)\n-        \n+\n         queuing_time = time.time() - start_time\n-        \n+\n         # Performance metrics\n         queuing_throughput = task_count / queuing_time\n-        \n-        assert queuing_throughput >= 100, f\"Queue throughput too low: {queuing_throughput:.1f} tasks/second\"\n+\n+        assert (\n+            queuing_throughput >= 100\n+        ), f\"Queue throughput too low: {queuing_throughput:.1f} tasks/second\"\n         assert queuing_time < 10, f\"Queuing took too long: {queuing_time:.1f}s\"\n-        \n+\n         print(f\"Queue performance metrics:\")\n         print(f\"- Tasks queued: {task_count}\")\n         print(f\"- Queuing time: {queuing_time:.2f}s\")\n         print(f\"- Throughput: {queuing_throughput:.1f} tasks/second\")\n-    \n-    @patch('tasks.notification_tasks.send_notification')\n+\n+    @patch(\"tasks.notification_tasks.send_notification\")\n     async def test_priority_queue_performance(self, mock_task):\n         \"\"\"Test priority-based queue performance\"\"\"\n-        \n+\n         mock_result = MagicMock()\n         mock_result.id = \"priority-task\"\n         mock_task.apply_async.return_value = mock_result\n-        \n+\n         # Queue tasks with different priorities\n         priorities = [\"urgent\", \"high\", \"normal\", \"low\"]\n         tasks_per_priority = 25\n-        \n+\n         start_time = time.time()\n-        \n+\n         for priority in priorities:\n             for i in range(tasks_per_priority):\n                 task_data = {\n                     \"notification_id\": f\"priority-{priority}-{i}\",\n                     \"recipient\": f\"priority{i}@example.com\",\n-                    \"priority\": priority\n+                    \"priority\": priority,\n                 }\n-                \n+\n                 # Mock priority-based queuing\n                 mock_task.apply_async.return_value\n-        \n+\n         total_time = time.time() - start_time\n         total_tasks = len(priorities) * tasks_per_priority\n-        \n+\n         priority_throughput = total_tasks / total_time\n-        \n-        assert priority_throughput >= 50, f\"Priority queue throughput too low: {priority_throughput:.1f} tasks/second\"\n-        \n+\n+        assert (\n+            priority_throughput >= 50\n+        ), f\"Priority queue throughput too low: {priority_throughput:.1f} tasks/second\"\n+\n         print(f\"Priority queue performance:\")\n         print(f\"- Total tasks: {total_tasks}\")\n         print(f\"- Processing time: {total_time:.2f}s\")\n         print(f\"- Throughput: {priority_throughput:.1f} tasks/second\")\n-    \n-    @patch('redis.Redis')\n+\n+    @patch(\"redis.Redis\")\n     async def test_redis_queue_performance(self, mock_redis):\n         \"\"\"Test Redis queue performance and memory usage\"\"\"\n-        \n+\n         # Mock Redis operations\n         mock_redis_client = MagicMock()\n         mock_redis.return_value = mock_redis_client\n-        \n+\n         # Simulate queue operations\n         operations = 1000\n         start_time = time.time()\n-        \n+\n         for i in range(operations):\n             # Simulate typical queue operations\n             task_data = {\n                 \"id\": f\"redis-task-{i}\",\n                 \"data\": f\"test data {i}\",\n-                \"timestamp\": time.time()\n+                \"timestamp\": time.time(),\n             }\n-            \n+\n             # Mock Redis operations\n             mock_redis_client.lpush.return_value = i + 1  # Queue length\n             mock_redis_client.brpop.return_value = (b\"queue\", str(task_data).encode())\n             mock_redis_client.get.return_value = str(task_data).encode()\n             mock_redis_client.set.return_value = True\n-        \n+\n         redis_time = time.time() - start_time\n         redis_throughput = operations / redis_time\n-        \n-        assert redis_throughput >= 500, f\"Redis throughput too low: {redis_throughput:.1f} operations/second\"\n-        \n+\n+        assert (\n+            redis_throughput >= 500\n+        ), f\"Redis throughput too low: {redis_throughput:.1f} operations/second\"\n+\n         print(f\"Redis queue performance:\")\n         print(f\"- Operations: {operations}\")\n         print(f\"- Time: {redis_time:.2f}s\")\n         print(f\"- Throughput: {redis_throughput:.1f} operations/second\")\n \n \n @pytest.mark.performance\n @pytest.mark.slow\n class TestNotificationProviderPerformance:\n     \"\"\"Performance tests for notification providers\"\"\"\n-    \n-    @patch('aiosmtplib.SMTP')\n+\n+    @patch(\"aiosmtplib.SMTP\")\n     async def test_email_provider_performance(self, mock_smtp):\n         \"\"\"Test email provider performance under load\"\"\"\n-        \n+\n         # Mock SMTP operations\n         mock_smtp_instance = AsyncMock()\n         mock_smtp_instance.connect.return_value = None\n         mock_smtp_instance.send_message.return_value = {}\n         mock_smtp.return_value = mock_smtp_instance\n-        \n+\n         from providers.email import EmailProvider\n-        \n+\n         config = {\n             \"host\": \"smtp.example.com\",\n             \"port\": 587,\n             \"username\": \"test@example.com\",\n-            \"password\": \"password\"\n+            \"password\": \"password\",\n         }\n-        \n+\n         provider = EmailProvider(config)\n-        \n+\n         # Send multiple emails and measure performance\n         email_count = 100\n         start_time = time.time()\n-        \n+\n         send_times = []\n         for i in range(email_count):\n             send_start = time.time()\n             result = await provider.send(\n                 recipient=f\"perf{i}@example.com\",\n                 subject=f\"Performance Test {i}\",\n-                content=f\"Email performance test {i}\"\n+                content=f\"Email performance test {i}\",\n             )\n             send_end = time.time()\n-            \n+\n             send_times.append(send_end - send_start)\n             assert result[\"status\"] == \"sent\"\n-        \n+\n         total_time = time.time() - start_time\n-        \n+\n         # Performance analysis\n         avg_send_time = statistics.mean(send_times)\n         throughput = email_count / total_time\n-        \n-        assert avg_send_time < 0.01, f\"Average email send time too high: {avg_send_time:.4f}s\"\n-        assert throughput >= 50, f\"Email throughput too low: {throughput:.1f} emails/second\"\n-        \n+\n+        assert (\n+            avg_send_time < 0.01\n+        ), f\"Average email send time too high: {avg_send_time:.4f}s\"\n+        assert (\n+            throughput >= 50\n+        ), f\"Email throughput too low: {throughput:.1f} emails/second\"\n+\n         print(f\"Email provider performance:\")\n         print(f\"- Emails sent: {email_count}\")\n         print(f\"- Average send time: {avg_send_time:.4f}s\")\n         print(f\"- Throughput: {throughput:.1f} emails/second\")\n-    \n-    @patch('twilio.rest.Client')\n+\n+    @patch(\"twilio.rest.Client\")\n     async def test_sms_provider_performance(self, mock_twilio):\n         \"\"\"Test SMS provider performance\"\"\"\n-        \n+\n         # Mock Twilio client\n         mock_client = MagicMock()\n         mock_message = MagicMock()\n         mock_message.sid = \"SMS_PERF_123\"\n         mock_message.status = \"queued\"\n         mock_client.messages.create.return_value = mock_message\n         mock_twilio.return_value = mock_client\n-        \n+\n         from providers.sms import SMSProvider\n-        \n+\n         config = {\n             \"account_sid\": \"test_sid\",\n             \"auth_token\": \"test_token\",\n-            \"from_number\": \"+1234567890\"\n+            \"from_number\": \"+1234567890\",\n         }\n-        \n+\n         provider = SMSProvider(config)\n-        \n+\n         # Send multiple SMS messages\n         sms_count = 50\n         start_time = time.time()\n-        \n+\n         send_times = []\n         for i in range(sms_count):\n             send_start = time.time()\n             result = await provider.send(\n-                recipient=f\"+123456789{i:02d}\",\n-                content=f\"SMS performance test {i}\"\n+                recipient=f\"+123456789{i:02d}\", content=f\"SMS performance test {i}\"\n             )\n             send_end = time.time()\n-            \n+\n             send_times.append(send_end - send_start)\n             assert result[\"status\"] == \"sent\"\n-        \n+\n         total_time = time.time() - start_time\n-        \n+\n         # Performance analysis\n         avg_send_time = statistics.mean(send_times)\n         throughput = sms_count / total_time\n-        \n-        assert avg_send_time < 0.02, f\"Average SMS send time too high: {avg_send_time:.4f}s\"\n-        assert throughput >= 25, f\"SMS throughput too low: {throughput:.1f} messages/second\"\n-        \n+\n+        assert (\n+            avg_send_time < 0.02\n+        ), f\"Average SMS send time too high: {avg_send_time:.4f}s\"\n+        assert (\n+            throughput >= 25\n+        ), f\"SMS throughput too low: {throughput:.1f} messages/second\"\n+\n         print(f\"SMS provider performance:\")\n         print(f\"- Messages sent: {sms_count}\")\n         print(f\"- Average send time: {avg_send_time:.4f}s\")\n         print(f\"- Throughput: {throughput:.1f} messages/second\")\n-    \n-    @patch('httpx.AsyncClient.post')\n+\n+    @patch(\"httpx.AsyncClient.post\")\n     async def test_push_provider_performance(self, mock_post):\n         \"\"\"Test push notification provider performance\"\"\"\n-        \n+\n         # Mock FCM response\n         mock_response = AsyncMock()\n         mock_response.status_code = 200\n         mock_response.json.return_value = {\n             \"multicast_id\": 123456789,\n             \"success\": 1,\n             \"failure\": 0,\n-            \"results\": [{\"message_id\": \"push_perf_123\"}]\n+            \"results\": [{\"message_id\": \"push_perf_123\"}],\n         }\n         mock_post.return_value = mock_response\n-        \n+\n         from providers.push import PushProvider\n-        \n-        config = {\n-            \"server_key\": \"test_server_key\",\n-            \"project_id\": \"test_project\"\n-        }\n-        \n+\n+        config = {\"server_key\": \"test_server_key\", \"project_id\": \"test_project\"}\n+\n         provider = PushProvider(config)\n-        \n+\n         # Send multiple push notifications\n         push_count = 75\n         start_time = time.time()\n-        \n+\n         send_times = []\n         for i in range(push_count):\n             send_start = time.time()\n             result = await provider.send(\n                 recipient=f\"push_token_{i}\",\n                 title=f\"Push Performance Test {i}\",\n-                content=f\"Push notification performance test {i}\"\n+                content=f\"Push notification performance test {i}\",\n             )\n             send_end = time.time()\n-            \n+\n             send_times.append(send_end - send_start)\n             assert result[\"status\"] == \"sent\"\n-        \n+\n         total_time = time.time() - start_time\n-        \n+\n         # Performance analysis\n         avg_send_time = statistics.mean(send_times)\n         throughput = push_count / total_time\n-        \n-        assert avg_send_time < 0.05, f\"Average push send time too high: {avg_send_time:.4f}s\"\n-        assert throughput >= 20, f\"Push throughput too low: {throughput:.1f} notifications/second\"\n-        \n+\n+        assert (\n+            avg_send_time < 0.05\n+        ), f\"Average push send time too high: {avg_send_time:.4f}s\"\n+        assert (\n+            throughput >= 20\n+        ), f\"Push throughput too low: {throughput:.1f} notifications/second\"\n+\n         print(f\"Push provider performance:\")\n         print(f\"- Notifications sent: {push_count}\")\n         print(f\"- Average send time: {avg_send_time:.4f}s\")\n         print(f\"- Throughput: {throughput:.1f} notifications/second\")\n \n \n @pytest.mark.performance\n @pytest.mark.slow\n class TestDatabasePerformance:\n     \"\"\"Performance tests for database operations\"\"\"\n-    \n+\n     async def test_notification_query_performance(self, db_session):\n         \"\"\"Test database query performance for notifications\"\"\"\n-        \n+\n         from database.models import Notification\n-        \n+\n         # Insert test data\n         notifications = []\n         for i in range(200):\n             notification = Notification(\n                 recipient=f\"dbperf{i}@example.com\",\n                 subject=f\"DB Performance Test {i}\",\n                 content=f\"Database performance test notification {i}\",\n                 channel=\"email\" if i % 2 == 0 else \"sms\",\n                 status=\"delivered\" if i % 3 == 0 else \"pending\",\n                 organization_id=f\"org-{i % 10}\",\n-                user_id=f\"user-{i % 50}\"\n+                user_id=f\"user-{i % 50}\",\n             )\n             notifications.append(notification)\n-        \n+\n         db_session.add_all(notifications)\n         await db_session.commit()\n-        \n+\n         # Test query performance\n         queries = [\n             # Query by organization\n             lambda: db_session.execute(\n                 select(Notification).where(Notification.organization_id == \"org-1\")\n@@ -540,134 +585,149 @@\n                 select(Notification)\n                 .where(Notification.organization_id == \"org-2\")\n                 .where(Notification.status == \"pending\")\n                 .order_by(Notification.created_at.desc())\n                 .limit(10)\n-            )\n+            ),\n         ]\n-        \n+\n         query_times = []\n         for i, query_func in enumerate(queries):\n             start_time = time.time()\n             result = await query_func()\n             query_time = time.time() - start_time\n             query_times.append(query_time)\n-            \n+\n             assert query_time < 0.1, f\"Query {i} too slow: {query_time:.4f}s\"\n-        \n+\n         avg_query_time = statistics.mean(query_times)\n-        assert avg_query_time < 0.05, f\"Average query time too high: {avg_query_time:.4f}s\"\n-        \n+        assert (\n+            avg_query_time < 0.05\n+        ), f\"Average query time too high: {avg_query_time:.4f}s\"\n+\n         print(f\"Database query performance:\")\n         print(f\"- Average query time: {avg_query_time:.4f}s\")\n         print(f\"- Max query time: {max(query_times):.4f}s\")\n-    \n+\n     async def test_bulk_insert_performance(self, db_session):\n         \"\"\"Test bulk insert performance for notifications\"\"\"\n-        \n-        from database.models import NotificationCategory, NotificationTemplate, Notification\n-        \n+\n+        from database.models import (\n+            NotificationCategory,\n+            NotificationTemplate,\n+            Notification,\n+        )\n+\n         # Test bulk category insert\n         categories = []\n         for i in range(50):\n             category = NotificationCategory(\n                 name=f\"bulk_category_{i}\",\n                 description=f\"Bulk insert test category {i}\",\n-                organization_id=f\"org-bulk-{i % 5}\"\n+                organization_id=f\"org-bulk-{i % 5}\",\n             )\n             categories.append(category)\n-        \n+\n         start_time = time.time()\n         db_session.add_all(categories)\n         await db_session.commit()\n         category_insert_time = time.time() - start_time\n-        \n+\n         # Test bulk notification insert\n         notifications = []\n         for i in range(500):\n             notification = Notification(\n                 recipient=f\"bulk{i}@example.com\",\n                 subject=f\"Bulk Insert Test {i}\",\n                 content=f\"Bulk database insert test {i}\",\n                 channel=\"email\",\n                 status=\"pending\",\n                 organization_id=f\"org-bulk-{i % 5}\",\n-                user_id=f\"user-bulk-{i % 100}\"\n+                user_id=f\"user-bulk-{i % 100}\",\n             )\n             notifications.append(notification)\n-        \n+\n         start_time = time.time()\n         db_session.add_all(notifications)\n         await db_session.commit()\n         notification_insert_time = time.time() - start_time\n-        \n+\n         # Performance assertions\n         category_throughput = len(categories) / category_insert_time\n         notification_throughput = len(notifications) / notification_insert_time\n-        \n-        assert category_throughput >= 25, f\"Category insert throughput too low: {category_throughput:.1f} records/second\"\n-        assert notification_throughput >= 50, f\"Notification insert throughput too low: {notification_throughput:.1f} records/second\"\n-        \n+\n+        assert (\n+            category_throughput >= 25\n+        ), f\"Category insert throughput too low: {category_throughput:.1f} records/second\"\n+        assert (\n+            notification_throughput >= 50\n+        ), f\"Notification insert throughput too low: {notification_throughput:.1f} records/second\"\n+\n         print(f\"Bulk insert performance:\")\n         print(f\"- Category insert: {category_throughput:.1f} records/second\")\n         print(f\"- Notification insert: {notification_throughput:.1f} records/second\")\n \n \n @pytest.mark.performance\n class TestMemoryUsagePerformance:\n     \"\"\"Memory usage and leak detection tests\"\"\"\n-    \n+\n     async def test_memory_usage_under_load(self, client: TestClient):\n         \"\"\"Test memory usage doesn't grow excessively under load\"\"\"\n-        \n+\n         import psutil\n         import os\n-        \n+\n         process = psutil.Process(os.getpid())\n         initial_memory = process.memory_info().rss / 1024 / 1024  # MB\n-        \n-        with patch('httpx.AsyncClient.post') as mock_identity, \\\n-             patch('tasks.notification_tasks.send_notification') as mock_task:\n-            \n+\n+        with patch(\"httpx.AsyncClient.post\") as mock_identity, patch(\n+            \"tasks.notification_tasks.send_notification\"\n+        ) as mock_task:\n+\n             mock_response = AsyncMock()\n             mock_response.status_code = 200\n-            mock_response.json.return_value = IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+            mock_response.json.return_value = (\n+                IdentityServiceMocks.get_successful_token_validation()[\"json\"]\n+            )\n             mock_identity.return_value = mock_response\n-            \n+\n             mock_result = MagicMock()\n             mock_result.id = \"memory-test-task\"\n             mock_task.apply_async.return_value = mock_result\n-            \n+\n             headers = {\"Authorization\": \"Bearer valid.jwt.token\"}\n-            \n+\n             # Process many requests\n             for i in range(200):\n                 notification_data = {\n                     \"type\": \"email\",\n                     \"to\": f\"memory{i}@example.com\",\n                     \"subject\": f\"Memory Test {i}\",\n-                    \"message\": f\"Testing memory usage {i}\"\n+                    \"message\": f\"Testing memory usage {i}\",\n                 }\n-                \n-                response = client.post(\"/api/v1/notifications\",\n-                                     json=notification_data,\n-                                     headers=headers)\n+\n+                response = client.post(\n+                    \"/api/v1/notifications\", json=notification_data, headers=headers\n+                )\n                 assert response.status_code == 200\n-                \n+\n                 # Check memory periodically\n                 if i % 50 == 0:\n                     current_memory = process.memory_info().rss / 1024 / 1024\n                     memory_growth = current_memory - initial_memory\n-                    \n+\n                     # Memory growth should be reasonable\n-                    assert memory_growth < 100, f\"Excessive memory growth: {memory_growth:.1f}MB\"\n-        \n+                    assert (\n+                        memory_growth < 100\n+                    ), f\"Excessive memory growth: {memory_growth:.1f}MB\"\n+\n         final_memory = process.memory_info().rss / 1024 / 1024\n         total_growth = final_memory - initial_memory\n-        \n+\n         print(f\"Memory usage analysis:\")\n         print(f\"- Initial memory: {initial_memory:.1f}MB\")\n-        print(f\"- Final memory: {final_memory:.1f}MB\") \n+        print(f\"- Final memory: {final_memory:.1f}MB\")\n         print(f\"- Total growth: {total_growth:.1f}MB\")\n-        \n+\n         # Total memory growth should be reasonable\n-        assert total_growth < 50, f\"Memory leak suspected: {total_growth:.1f}MB growth\"\n\\ No newline at end of file\n+        assert total_growth < 50, f\"Memory leak suspected: {total_growth:.1f}MB growth\"\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_models.py\t2025-09-09 13:32:26.986730+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_models.py\t2025-09-10 11:37:02.899588+00:00\n@@ -1,136 +1,151 @@\n \"\"\"\n Tests for Communication Service database models\n \"\"\"\n+\n import pytest\n import uuid\n from datetime import datetime\n from sqlalchemy.exc import IntegrityError\n \n from models import (\n-    NotificationCategory, NotificationTemplate, Notification, \n-    NotificationPreference, Conversation, ConversationParticipant, Message,\n-    NotificationStatus, NotificationChannel, ConversationType, MessageType, \n-    ParticipantRole, create_notification, get_user_notification_preferences\n+    NotificationCategory,\n+    NotificationTemplate,\n+    Notification,\n+    NotificationPreference,\n+    Conversation,\n+    ConversationParticipant,\n+    Message,\n+    NotificationStatus,\n+    NotificationChannel,\n+    ConversationType,\n+    MessageType,\n+    ParticipantRole,\n+    create_notification,\n+    get_user_notification_preferences,\n )\n+\n \n class TestNotificationCategory:\n     \"\"\"Test NotificationCategory model\"\"\"\n-    \n+\n     def test_create_category(self, db_session):\n         \"\"\"Test creating a notification category\"\"\"\n         category = NotificationCategory(\n-            name=\"test_category\",\n-            description=\"Test category\",\n-            default_enabled=True\n+            name=\"test_category\", description=\"Test category\", default_enabled=True\n         )\n         db_session.add(category)\n         db_session.commit()\n-        \n+\n         assert category.id is not None\n         assert category.name == \"test_category\"\n         assert category.description == \"Test category\"\n         assert category.default_enabled is True\n         assert category.created_at is not None\n         assert category.updated_at is not None\n-    \n+\n     def test_category_unique_name(self, db_session):\n         \"\"\"Test that category names must be unique\"\"\"\n         category1 = NotificationCategory(name=\"unique_name\")\n         category2 = NotificationCategory(name=\"unique_name\")\n-        \n+\n         db_session.add(category1)\n         db_session.commit()\n-        \n+\n         db_session.add(category2)\n         with pytest.raises(IntegrityError):\n             db_session.commit()\n-    \n+\n     def test_category_str_representation(self, db_session):\n         \"\"\"Test string representation of category\"\"\"\n         category = NotificationCategory(name=\"test_repr\")\n         assert \"test_repr\" in str(category)\n \n+\n class TestNotificationTemplate:\n     \"\"\"Test NotificationTemplate model\"\"\"\n-    \n+\n     def test_create_template(self, db_session, sample_notification_category):\n         \"\"\"Test creating a notification template\"\"\"\n         template = NotificationTemplate(\n             name=\"test_template\",\n             category_id=sample_notification_category.id,\n             channel=NotificationChannel.EMAIL,\n             language=\"en\",\n             subject=\"Test Subject\",\n             content=\"Hello {{name}}\",\n-            variables={\"name\": \"string\"}\n+            variables={\"name\": \"string\"},\n         )\n         db_session.add(template)\n         db_session.commit()\n-        \n+\n         assert template.id is not None\n         assert template.name == \"test_template\"\n         assert template.channel == NotificationChannel.EMAIL\n         assert template.language == \"en\"\n         assert template.subject == \"Test Subject\"\n         assert template.content == \"Hello {{name}}\"\n         assert template.variables == {\"name\": \"string\"}\n         assert template.version == 1\n         assert template.is_active is True\n-    \n-    def test_template_category_relationship(self, db_session, sample_notification_template):\n+\n+    def test_template_category_relationship(\n+        self, db_session, sample_notification_template\n+    ):\n         \"\"\"Test template-category relationship\"\"\"\n         assert sample_notification_template.category is not None\n         assert sample_notification_template.category.name == \"test_category\"\n \n+\n class TestNotification:\n     \"\"\"Test Notification model\"\"\"\n-    \n+\n     def test_create_notification(self, db_session, sample_notification_category):\n         \"\"\"Test creating a notification\"\"\"\n         user_id = uuid.uuid4()\n         notification = Notification(\n             user_id=user_id,\n             category_id=sample_notification_category.id,\n             channel=NotificationChannel.EMAIL,\n             subject=\"Test\",\n             content=\"Test notification\",\n             recipient=\"test@example.com\",\n-            status=NotificationStatus.PENDING\n+            status=NotificationStatus.PENDING,\n         )\n         db_session.add(notification)\n         db_session.commit()\n-        \n+\n         assert notification.id is not None\n         assert notification.user_id == user_id\n         assert notification.channel == NotificationChannel.EMAIL\n         assert notification.status == NotificationStatus.PENDING\n         assert notification.recipient == \"test@example.com\"\n         assert notification.retry_count == 0\n         assert notification.max_retries == 3\n-    \n+\n     def test_notification_helper_function(self, db_session):\n         \"\"\"Test create_notification helper function\"\"\"\n         user_id = uuid.uuid4()\n         notification = create_notification(\n             db_session=db_session,\n             user_id=user_id,\n             channel=NotificationChannel.EMAIL,\n             content=\"Test content\",\n             recipient=\"test@example.com\",\n-            category_name=\"system\"\n-        )\n-        \n+            category_name=\"system\",\n+        )\n+\n         assert notification.user_id == user_id\n         assert notification.channel == NotificationChannel.EMAIL\n         assert notification.content == \"Test content\"\n         assert notification.recipient == \"test@example.com\"\n         assert notification.category.name == \"system\"\n \n+\n class TestNotificationPreference:\n     \"\"\"Test NotificationPreference model\"\"\"\n-    \n+\n     def test_create_preference(self, db_session, sample_notification_category):\n         \"\"\"Test creating notification preferences\"\"\"\n         user_id = uuid.uuid4()\n         preference = NotificationPreference(\n             user_id=user_id,\n@@ -139,209 +154,207 @@\n             sms_enabled=False,\n             push_enabled=True,\n             in_app_enabled=True,\n             email_address=\"user@example.com\",\n             phone_number=\"+1234567890\",\n-            timezone=\"US/Pacific\"\n+            timezone=\"US/Pacific\",\n         )\n         db_session.add(preference)\n         db_session.commit()\n-        \n+\n         assert preference.id is not None\n         assert preference.user_id == user_id\n         assert preference.email_enabled is True\n         assert preference.sms_enabled is False\n         assert preference.email_address == \"user@example.com\"\n         assert preference.phone_number == \"+1234567890\"\n         assert preference.timezone == \"US/Pacific\"\n-    \n+\n     def test_get_user_preferences_helper(self, db_session):\n         \"\"\"Test get_user_notification_preferences helper function\"\"\"\n         user_id = uuid.uuid4()\n-        \n+\n         # Create category and preference\n         category = NotificationCategory(name=\"test_pref_category\")\n         db_session.add(category)\n         db_session.flush()\n-        \n+\n         preference = NotificationPreference(\n-            user_id=user_id,\n-            category_id=category.id,\n-            email_enabled=True\n+            user_id=user_id, category_id=category.id, email_enabled=True\n         )\n         db_session.add(preference)\n         db_session.commit()\n-        \n+\n         preferences = get_user_notification_preferences(db_session, user_id)\n         assert \"test_pref_category\" in preferences\n         assert preferences[\"test_pref_category\"].email_enabled is True\n \n+\n class TestConversation:\n     \"\"\"Test Conversation model\"\"\"\n-    \n+\n     def test_create_conversation(self, db_session):\n         \"\"\"Test creating a conversation\"\"\"\n         conversation = Conversation(\n             type=ConversationType.DIRECT,\n             subject=\"Test conversation\",\n-            metadata={\"priority\": \"high\"}\n-        )\n-        db_session.add(conversation)\n-        db_session.commit()\n-        \n+            metadata={\"priority\": \"high\"},\n+        )\n+        db_session.add(conversation)\n+        db_session.commit()\n+\n         assert conversation.id is not None\n         assert conversation.type == ConversationType.DIRECT\n         assert conversation.subject == \"Test conversation\"\n         assert conversation.metadata == {\"priority\": \"high\"}\n         assert conversation.is_active is True\n         assert conversation.is_archived is False\n \n+\n class TestConversationParticipant:\n     \"\"\"Test ConversationParticipant model\"\"\"\n-    \n+\n     def test_create_participant(self, db_session):\n         \"\"\"Test creating a conversation participant\"\"\"\n         # Create conversation first\n         conversation = Conversation(type=ConversationType.GROUP)\n         db_session.add(conversation)\n         db_session.flush()\n-        \n+\n         user_id = uuid.uuid4()\n         participant = ConversationParticipant(\n             conversation_id=conversation.id,\n             user_id=user_id,\n             role=ParticipantRole.ADMIN,\n-            notifications_enabled=True\n+            notifications_enabled=True,\n         )\n         db_session.add(participant)\n         db_session.commit()\n-        \n+\n         assert participant.id is not None\n         assert participant.conversation_id == conversation.id\n         assert participant.user_id == user_id\n         assert participant.role == ParticipantRole.ADMIN\n         assert participant.is_active is True\n         assert participant.notifications_enabled is True\n-    \n+\n     def test_participant_conversation_relationship(self, db_session):\n         \"\"\"Test participant-conversation relationship\"\"\"\n         conversation = Conversation(type=ConversationType.GROUP)\n         user_id = uuid.uuid4()\n         participant = ConversationParticipant(\n-            conversation=conversation,\n-            user_id=user_id,\n-            role=ParticipantRole.MEMBER\n-        )\n-        \n+            conversation=conversation, user_id=user_id, role=ParticipantRole.MEMBER\n+        )\n+\n         db_session.add(conversation)\n         db_session.add(participant)\n         db_session.commit()\n-        \n+\n         assert participant.conversation == conversation\n         assert conversation.participants[0] == participant\n \n+\n class TestMessage:\n     \"\"\"Test Message model\"\"\"\n-    \n+\n     def test_create_message(self, db_session):\n         \"\"\"Test creating a message\"\"\"\n         # Create conversation and participant\n         conversation = Conversation(type=ConversationType.DIRECT)\n         db_session.add(conversation)\n         db_session.flush()\n-        \n+\n         user_id = uuid.uuid4()\n         participant = ConversationParticipant(\n             conversation_id=conversation.id,\n             user_id=user_id,\n-            role=ParticipantRole.MEMBER\n+            role=ParticipantRole.MEMBER,\n         )\n         db_session.add(participant)\n         db_session.flush()\n-        \n+\n         # Create message\n         message = Message(\n             conversation_id=conversation.id,\n             sender_id=participant.id,\n             content=\"Test message\",\n             message_type=MessageType.TEXT,\n-            metadata={\"formatted\": True}\n+            metadata={\"formatted\": True},\n         )\n         db_session.add(message)\n         db_session.commit()\n-        \n+\n         assert message.id is not None\n         assert message.conversation_id == conversation.id\n         assert message.sender_id == participant.id\n         assert message.content == \"Test message\"\n         assert message.message_type == MessageType.TEXT\n         assert message.metadata == {\"formatted\": True}\n         assert message.is_edited is False\n         assert message.is_deleted is False\n-    \n+\n     def test_message_relationships(self, db_session):\n         \"\"\"Test message relationships\"\"\"\n         conversation = Conversation(type=ConversationType.DIRECT)\n         user_id = uuid.uuid4()\n         participant = ConversationParticipant(\n-            conversation=conversation,\n-            user_id=user_id,\n-            role=ParticipantRole.MEMBER\n+            conversation=conversation, user_id=user_id, role=ParticipantRole.MEMBER\n         )\n         message = Message(\n             conversation=conversation,\n             sender=participant,\n             content=\"Test message\",\n-            message_type=MessageType.TEXT\n-        )\n-        \n+            message_type=MessageType.TEXT,\n+        )\n+\n         db_session.add(conversation)\n         db_session.add(participant)\n         db_session.add(message)\n         db_session.commit()\n-        \n+\n         assert message.conversation == conversation\n         assert message.sender == participant\n         assert conversation.messages[0] == message\n         assert participant.messages[0] == message\n \n+\n class TestModelEnums:\n     \"\"\"Test model enums\"\"\"\n-    \n+\n     def test_notification_status_enum(self):\n         \"\"\"Test NotificationStatus enum values\"\"\"\n         assert NotificationStatus.PENDING.value == \"pending\"\n         assert NotificationStatus.QUEUED.value == \"queued\"\n         assert NotificationStatus.SENT.value == \"sent\"\n         assert NotificationStatus.DELIVERED.value == \"delivered\"\n         assert NotificationStatus.FAILED.value == \"failed\"\n         assert NotificationStatus.CANCELLED.value == \"cancelled\"\n-    \n+\n     def test_notification_channel_enum(self):\n         \"\"\"Test NotificationChannel enum values\"\"\"\n         assert NotificationChannel.EMAIL.value == \"email\"\n         assert NotificationChannel.SMS.value == \"sms\"\n         assert NotificationChannel.PUSH.value == \"push\"\n         assert NotificationChannel.IN_APP.value == \"in_app\"\n-    \n+\n     def test_conversation_type_enum(self):\n         \"\"\"Test ConversationType enum values\"\"\"\n         assert ConversationType.DIRECT.value == \"direct\"\n         assert ConversationType.GROUP.value == \"group\"\n         assert ConversationType.SUPPORT.value == \"support\"\n         assert ConversationType.SYSTEM.value == \"system\"\n-    \n+\n     def test_message_type_enum(self):\n         \"\"\"Test MessageType enum values\"\"\"\n         assert MessageType.TEXT.value == \"text\"\n         assert MessageType.HTML.value == \"html\"\n         assert MessageType.MARKDOWN.value == \"markdown\"\n         assert MessageType.FILE.value == \"file\"\n         assert MessageType.IMAGE.value == \"image\"\n         assert MessageType.SYSTEM.value == \"system\"\n-    \n+\n     def test_participant_role_enum(self):\n         \"\"\"Test ParticipantRole enum values\"\"\"\n         assert ParticipantRole.MEMBER.value == \"member\"\n         assert ParticipantRole.ADMIN.value == \"admin\"\n         assert ParticipantRole.MODERATOR.value == \"moderator\"\n-        assert ParticipantRole.READONLY.value == \"readonly\"\n\\ No newline at end of file\n+        assert ParticipantRole.READONLY.value == \"readonly\"\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/integration/test_notification_providers.py\t2025-09-09 19:29:40.727419+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/integration/test_notification_providers.py\t2025-09-10 11:37:02.986209+00:00\n@@ -7,914 +7,903 @@\n from datetime import datetime, timedelta\n from unittest.mock import patch, AsyncMock, MagicMock\n import json\n \n from tests.fixtures.mock_responses import (\n-    EmailProviderMocks, SMSProviderMocks, PushProviderMocks\n+    EmailProviderMocks,\n+    SMSProviderMocks,\n+    PushProviderMocks,\n )\n from tests.fixtures.sample_data import SampleNotificationData\n+\n \n @pytest.mark.integration\n @pytest.mark.requires_external\n class TestEmailNotificationProvider:\n     \"\"\"Integration tests for email notification provider\"\"\"\n-    \n+\n     @pytest.fixture\n     async def email_provider(self):\n         \"\"\"Create email provider instance\"\"\"\n         from providers.email import EmailProvider\n+\n         config = {\n             \"host\": \"smtp.example.com\",\n             \"port\": 587,\n             \"username\": \"test@example.com\",\n             \"password\": \"test_password\",\n-            \"use_tls\": True\n+            \"use_tls\": True,\n         }\n         return EmailProvider(config)\n-    \n+\n     async def test_send_email_success(self, email_provider):\n         \"\"\"Test successful email sending\"\"\"\n         # Mock SMTP client\n-        with patch('aiosmtplib.SMTP') as mock_smtp:\n+        with patch(\"aiosmtplib.SMTP\") as mock_smtp:\n             mock_smtp_instance = AsyncMock()\n             mock_smtp_instance.connect.return_value = None\n             mock_smtp_instance.starttls.return_value = None\n             mock_smtp_instance.login.return_value = None\n             mock_smtp_instance.send_message.return_value = {}\n             mock_smtp_instance.quit.return_value = None\n             mock_smtp.return_value = mock_smtp_instance\n-            \n+\n             notification_data = SampleNotificationData.get_notification_email()\n-            \n+\n             result = await email_provider.send(\n                 recipient=notification_data[\"recipient\"],\n                 subject=notification_data[\"subject\"],\n                 content=notification_data[\"content\"],\n-                data=notification_data[\"data\"]\n-            )\n-            \n+                data=notification_data[\"data\"],\n+            )\n+\n             assert result[\"status\"] == \"sent\"\n             assert \"message_id\" in result\n             assert result[\"provider\"] == \"smtp\"\n-            \n+\n             # Verify SMTP operations were called\n             mock_smtp_instance.connect.assert_called_once()\n             mock_smtp_instance.send_message.assert_called_once()\n             mock_smtp_instance.quit.assert_called_once()\n-    \n+\n     async def test_send_email_smtp_connection_error(self, email_provider):\n         \"\"\"Test email sending with SMTP connection error\"\"\"\n-        with patch('aiosmtplib.SMTP') as mock_smtp:\n+        with patch(\"aiosmtplib.SMTP\") as mock_smtp:\n             mock_smtp_instance = AsyncMock()\n             mock_smtp_instance.connect.side_effect = Exception(\"Connection refused\")\n             mock_smtp.return_value = mock_smtp_instance\n-            \n+\n             notification_data = SampleNotificationData.get_notification_email()\n-            \n+\n             result = await email_provider.send(\n                 recipient=notification_data[\"recipient\"],\n                 subject=notification_data[\"subject\"],\n-                content=notification_data[\"content\"]\n-            )\n-            \n+                content=notification_data[\"content\"],\n+            )\n+\n             assert result[\"status\"] == \"failed\"\n             assert \"error\" in result\n             assert \"connection\" in result[\"error\"].lower()\n-    \n+\n     async def test_send_email_authentication_error(self, email_provider):\n         \"\"\"Test email sending with authentication error\"\"\"\n-        with patch('aiosmtplib.SMTP') as mock_smtp:\n+        with patch(\"aiosmtplib.SMTP\") as mock_smtp:\n             mock_smtp_instance = AsyncMock()\n             mock_smtp_instance.connect.return_value = None\n             mock_smtp_instance.login.side_effect = Exception(\"Authentication failed\")\n             mock_smtp.return_value = mock_smtp_instance\n-            \n+\n             notification_data = SampleNotificationData.get_notification_email()\n-            \n+\n             result = await email_provider.send(\n                 recipient=notification_data[\"recipient\"],\n                 subject=notification_data[\"subject\"],\n-                content=notification_data[\"content\"]\n-            )\n-            \n+                content=notification_data[\"content\"],\n+            )\n+\n             assert result[\"status\"] == \"failed\"\n             assert \"error\" in result\n             assert \"authentication\" in result[\"error\"].lower()\n-    \n+\n     async def test_send_email_rate_limit_error(self, email_provider):\n         \"\"\"Test email sending with rate limit error\"\"\"\n-        with patch('aiosmtplib.SMTP') as mock_smtp:\n+        with patch(\"aiosmtplib.SMTP\") as mock_smtp:\n             mock_smtp_instance = AsyncMock()\n             mock_smtp_instance.connect.return_value = None\n-            mock_smtp_instance.send_message.side_effect = Exception(\"Rate limit exceeded\")\n+            mock_smtp_instance.send_message.side_effect = Exception(\n+                \"Rate limit exceeded\"\n+            )\n             mock_smtp.return_value = mock_smtp_instance\n-            \n+\n             notification_data = SampleNotificationData.get_notification_email()\n-            \n+\n             result = await email_provider.send(\n                 recipient=notification_data[\"recipient\"],\n                 subject=notification_data[\"subject\"],\n-                content=notification_data[\"content\"]\n-            )\n-            \n+                content=notification_data[\"content\"],\n+            )\n+\n             assert result[\"status\"] == \"failed\"\n             assert \"error\" in result\n             assert \"rate limit\" in result[\"error\"].lower()\n-    \n+\n     async def test_send_email_invalid_recipient(self, email_provider):\n         \"\"\"Test email sending with invalid recipient\"\"\"\n-        with patch('aiosmtplib.SMTP') as mock_smtp:\n+        with patch(\"aiosmtplib.SMTP\") as mock_smtp:\n             mock_smtp_instance = AsyncMock()\n             mock_smtp_instance.connect.return_value = None\n             mock_smtp_instance.send_message.side_effect = Exception(\"Invalid recipient\")\n             mock_smtp.return_value = mock_smtp_instance\n-            \n+\n             result = await email_provider.send(\n                 recipient=\"invalid-email\",\n                 subject=\"Test Subject\",\n-                content=\"Test Content\"\n-            )\n-            \n+                content=\"Test Content\",\n+            )\n+\n             assert result[\"status\"] == \"failed\"\n             assert \"error\" in result\n-    \n+\n     async def test_send_email_with_html_content(self, email_provider):\n         \"\"\"Test sending HTML email content\"\"\"\n-        with patch('aiosmtplib.SMTP') as mock_smtp:\n+        with patch(\"aiosmtplib.SMTP\") as mock_smtp:\n             mock_smtp_instance = AsyncMock()\n             mock_smtp_instance.connect.return_value = None\n             mock_smtp_instance.send_message.return_value = {}\n             mock_smtp.return_value = mock_smtp_instance\n-            \n+\n             html_content = \"\"\"\n             <html>\n                 <body>\n                     <h1>Welcome {{name}}!</h1>\n                     <p>Thank you for joining <strong>{{platform}}</strong>.</p>\n                 </body>\n             </html>\n             \"\"\"\n-            \n+\n             result = await email_provider.send(\n                 recipient=\"test@example.com\",\n                 subject=\"Welcome!\",\n                 content=html_content,\n                 content_type=\"html\",\n-                data={\"name\": \"John\", \"platform\": \"Our Service\"}\n-            )\n-            \n+                data={\"name\": \"John\", \"platform\": \"Our Service\"},\n+            )\n+\n             assert result[\"status\"] == \"sent\"\n-            \n+\n             # Verify HTML content was processed\n             call_args = mock_smtp_instance.send_message.call_args\n             sent_message = call_args[0][0]  # First argument should be the message\n             assert \"html\" in str(sent_message).lower() or \"John\" in str(sent_message)\n \n \n @pytest.mark.integration\n @pytest.mark.requires_external\n class TestSMSNotificationProvider:\n     \"\"\"Integration tests for SMS notification provider\"\"\"\n-    \n+\n     @pytest.fixture\n     async def sms_provider(self):\n         \"\"\"Create SMS provider instance\"\"\"\n         from providers.sms import SMSProvider\n+\n         config = {\n             \"account_sid\": \"test_sid\",\n             \"auth_token\": \"test_token\",\n-            \"from_number\": \"+1234567890\"\n+            \"from_number\": \"+1234567890\",\n         }\n         return SMSProvider(config)\n-    \n+\n     async def test_send_sms_success(self, sms_provider):\n         \"\"\"Test successful SMS sending\"\"\"\n         # Mock Twilio client\n-        with patch('twilio.rest.Client') as mock_twilio:\n+        with patch(\"twilio.rest.Client\") as mock_twilio:\n             mock_client = MagicMock()\n             mock_message = MagicMock()\n             mock_message.sid = \"SMS123456789\"\n             mock_message.status = \"queued\"\n             mock_client.messages.create.return_value = mock_message\n             mock_twilio.return_value = mock_client\n-            \n+\n             notification_data = SampleNotificationData.get_notification_sms()\n-            \n+\n             result = await sms_provider.send(\n                 recipient=notification_data[\"recipient\"],\n                 content=notification_data[\"content\"],\n-                data=notification_data[\"data\"]\n-            )\n-            \n+                data=notification_data[\"data\"],\n+            )\n+\n             assert result[\"status\"] == \"sent\"\n             assert result[\"message_id\"] == \"SMS123456789\"\n             assert result[\"provider\"] == \"twilio\"\n-            \n+\n             # Verify Twilio client was used correctly\n             mock_client.messages.create.assert_called_once()\n             call_args = mock_client.messages.create.call_args\n             assert call_args.kwargs[\"to\"] == notification_data[\"recipient\"]\n             assert call_args.kwargs[\"body\"] == notification_data[\"content\"]\n-    \n+\n     async def test_send_sms_invalid_phone_number(self, sms_provider):\n         \"\"\"Test SMS sending with invalid phone number\"\"\"\n-        with patch('twilio.rest.Client') as mock_twilio:\n+        with patch(\"twilio.rest.Client\") as mock_twilio:\n             mock_client = MagicMock()\n             mock_client.messages.create.side_effect = Exception(\"Invalid phone number\")\n             mock_twilio.return_value = mock_client\n-            \n+\n             result = await sms_provider.send(\n-                recipient=\"invalid-phone\",\n-                content=\"Test message\"\n-            )\n-            \n+                recipient=\"invalid-phone\", content=\"Test message\"\n+            )\n+\n             assert result[\"status\"] == \"failed\"\n             assert \"error\" in result\n             assert \"invalid\" in result[\"error\"].lower()\n-    \n+\n     async def test_send_sms_insufficient_balance(self, sms_provider):\n         \"\"\"Test SMS sending with insufficient account balance\"\"\"\n-        with patch('twilio.rest.Client') as mock_twilio:\n+        with patch(\"twilio.rest.Client\") as mock_twilio:\n             mock_client = MagicMock()\n             mock_client.messages.create.side_effect = Exception(\"Insufficient balance\")\n             mock_twilio.return_value = mock_client\n-            \n+\n             result = await sms_provider.send(\n-                recipient=\"+1234567890\",\n-                content=\"Test message\"\n-            )\n-            \n+                recipient=\"+1234567890\", content=\"Test message\"\n+            )\n+\n             assert result[\"status\"] == \"failed\"\n             assert \"error\" in result\n-    \n+\n     async def test_send_sms_with_long_message(self, sms_provider):\n         \"\"\"Test SMS sending with long message (multiple segments)\"\"\"\n-        with patch('twilio.rest.Client') as mock_twilio:\n+        with patch(\"twilio.rest.Client\") as mock_twilio:\n             mock_client = MagicMock()\n             mock_message = MagicMock()\n             mock_message.sid = \"SMS_LONG_123\"\n             mock_message.status = \"queued\"\n             mock_message.num_segments = 3\n             mock_client.messages.create.return_value = mock_message\n             mock_twilio.return_value = mock_client\n-            \n+\n             long_message = \"This is a very long SMS message that will likely be split into multiple segments because it exceeds the standard SMS length limit of 160 characters for GSM encoding or 70 characters for Unicode encoding.\"\n-            \n+\n             result = await sms_provider.send(\n-                recipient=\"+1234567890\",\n-                content=long_message\n-            )\n-            \n+                recipient=\"+1234567890\", content=long_message\n+            )\n+\n             assert result[\"status\"] == \"sent\"\n             assert result[\"segments\"] == 3\n-    \n+\n     async def test_send_sms_rate_limiting(self, sms_provider):\n         \"\"\"Test SMS sending with rate limiting\"\"\"\n-        with patch('twilio.rest.Client') as mock_twilio:\n+        with patch(\"twilio.rest.Client\") as mock_twilio:\n             mock_client = MagicMock()\n             mock_client.messages.create.side_effect = Exception(\"Rate limit exceeded\")\n             mock_twilio.return_value = mock_client\n-            \n+\n             result = await sms_provider.send(\n-                recipient=\"+1234567890\",\n-                content=\"Test message\"\n-            )\n-            \n+                recipient=\"+1234567890\", content=\"Test message\"\n+            )\n+\n             assert result[\"status\"] == \"failed\"\n             assert \"rate limit\" in result[\"error\"].lower()\n \n \n @pytest.mark.integration\n @pytest.mark.requires_external\n class TestPushNotificationProvider:\n     \"\"\"Integration tests for push notification provider\"\"\"\n-    \n+\n     @pytest.fixture\n     async def push_provider(self):\n         \"\"\"Create push provider instance\"\"\"\n         from providers.push import PushProvider\n-        config = {\n-            \"server_key\": \"test_server_key\",\n-            \"project_id\": \"test_project\"\n-        }\n+\n+        config = {\"server_key\": \"test_server_key\", \"project_id\": \"test_project\"}\n         return PushProvider(config)\n-    \n+\n     async def test_send_push_notification_success(self, push_provider):\n         \"\"\"Test successful push notification sending\"\"\"\n         # Mock FCM client\n-        with patch('httpx.AsyncClient.post') as mock_post:\n+        with patch(\"httpx.AsyncClient.post\") as mock_post:\n             mock_response = AsyncMock()\n             mock_response.status_code = 200\n             mock_response.json.return_value = {\n                 \"multicast_id\": 123456789,\n                 \"success\": 1,\n                 \"failure\": 0,\n-                \"results\": [{\"message_id\": \"push_msg_123\"}]\n+                \"results\": [{\"message_id\": \"push_msg_123\"}],\n             }\n             mock_post.return_value = mock_response\n-            \n+\n             notification_data = SampleNotificationData.get_notification_push()\n-            \n+\n             result = await push_provider.send(\n                 recipient=notification_data[\"recipient\"],\n                 title=notification_data[\"subject\"],\n                 content=notification_data[\"content\"],\n-                data=notification_data[\"data\"]\n-            )\n-            \n+                data=notification_data[\"data\"],\n+            )\n+\n             assert result[\"status\"] == \"sent\"\n             assert result[\"message_id\"] == \"push_msg_123\"\n             assert result[\"provider\"] == \"fcm\"\n-            \n+\n             # Verify FCM API was called correctly\n             mock_post.assert_called_once()\n             call_args = mock_post.call_args\n             assert \"fcm.googleapis.com\" in str(call_args)\n-    \n+\n     async def test_send_push_invalid_token(self, push_provider):\n         \"\"\"Test push notification with invalid token\"\"\"\n-        with patch('httpx.AsyncClient.post') as mock_post:\n+        with patch(\"httpx.AsyncClient.post\") as mock_post:\n             mock_response = AsyncMock()\n             mock_response.status_code = 200\n             mock_response.json.return_value = {\n                 \"multicast_id\": 123456789,\n                 \"success\": 0,\n                 \"failure\": 1,\n-                \"results\": [{\"error\": \"NotRegistered\"}]\n+                \"results\": [{\"error\": \"NotRegistered\"}],\n             }\n             mock_post.return_value = mock_response\n-            \n+\n             result = await push_provider.send(\n-                recipient=\"invalid_token\",\n-                title=\"Test Title\",\n-                content=\"Test content\"\n-            )\n-            \n+                recipient=\"invalid_token\", title=\"Test Title\", content=\"Test content\"\n+            )\n+\n             assert result[\"status\"] == \"failed\"\n             assert \"error\" in result\n             assert \"NotRegistered\" in result[\"error\"]\n-    \n+\n     async def test_send_push_quota_exceeded(self, push_provider):\n         \"\"\"Test push notification with quota exceeded\"\"\"\n-        with patch('httpx.AsyncClient.post') as mock_post:\n+        with patch(\"httpx.AsyncClient.post\") as mock_post:\n             mock_response = AsyncMock()\n             mock_response.status_code = 429\n             mock_response.json.return_value = {\"error\": \"QuotaExceeded\"}\n             mock_post.return_value = mock_response\n-            \n+\n             result = await push_provider.send(\n-                recipient=\"valid_token\",\n-                title=\"Test Title\", \n-                content=\"Test content\"\n-            )\n-            \n+                recipient=\"valid_token\", title=\"Test Title\", content=\"Test content\"\n+            )\n+\n             assert result[\"status\"] == \"failed\"\n             assert \"quota\" in result[\"error\"].lower()\n-    \n+\n     async def test_send_push_with_data_payload(self, push_provider):\n         \"\"\"Test push notification with custom data payload\"\"\"\n-        with patch('httpx.AsyncClient.post') as mock_post:\n+        with patch(\"httpx.AsyncClient.post\") as mock_post:\n             mock_response = AsyncMock()\n             mock_response.status_code = 200\n             mock_response.json.return_value = {\n                 \"multicast_id\": 123456789,\n                 \"success\": 1,\n                 \"failure\": 0,\n-                \"results\": [{\"message_id\": \"push_data_123\"}]\n+                \"results\": [{\"message_id\": \"push_data_123\"}],\n             }\n             mock_post.return_value = mock_response\n-            \n+\n             custom_data = {\n                 \"deep_link\": \"/messages/123\",\n                 \"action\": \"open_conversation\",\n                 \"conversation_id\": \"conv_456\",\n-                \"sender_avatar\": \"https://example.com/avatar.jpg\"\n+                \"sender_avatar\": \"https://example.com/avatar.jpg\",\n             }\n-            \n+\n             result = await push_provider.send(\n                 recipient=\"valid_token\",\n                 title=\"New Message\",\n                 content=\"You have a new message\",\n-                data=custom_data\n-            )\n-            \n+                data=custom_data,\n+            )\n+\n             assert result[\"status\"] == \"sent\"\n-            \n+\n             # Verify custom data was included in payload\n             call_args = mock_post.call_args\n             request_data = json.loads(call_args.kwargs[\"data\"])\n             assert \"data\" in request_data\n             assert request_data[\"data\"][\"deep_link\"] == \"/messages/123\"\n-    \n+\n     async def test_send_push_to_multiple_tokens(self, push_provider):\n         \"\"\"Test push notification to multiple device tokens\"\"\"\n-        with patch('httpx.AsyncClient.post') as mock_post:\n+        with patch(\"httpx.AsyncClient.post\") as mock_post:\n             mock_response = AsyncMock()\n             mock_response.status_code = 200\n             mock_response.json.return_value = {\n                 \"multicast_id\": 123456789,\n                 \"success\": 2,\n                 \"failure\": 1,\n                 \"results\": [\n                     {\"message_id\": \"push_1\"},\n                     {\"message_id\": \"push_2\"},\n-                    {\"error\": \"InvalidRegistration\"}\n-                ]\n+                    {\"error\": \"InvalidRegistration\"},\n+                ],\n             }\n             mock_post.return_value = mock_response\n-            \n+\n             tokens = [\"token1\", \"token2\", \"invalid_token\"]\n-            \n+\n             result = await push_provider.send_to_multiple(\n                 recipients=tokens,\n                 title=\"Broadcast Message\",\n-                content=\"This is a broadcast notification\"\n-            )\n-            \n+                content=\"This is a broadcast notification\",\n+            )\n+\n             assert result[\"status\"] == \"partial_success\"\n             assert result[\"successful_count\"] == 2\n             assert result[\"failed_count\"] == 1\n \n \n @pytest.mark.integration\n class TestInAppNotificationProvider:\n     \"\"\"Integration tests for in-app notification provider\"\"\"\n-    \n+\n     @pytest.fixture\n     async def in_app_provider(self, db_session, mock_redis):\n         \"\"\"Create in-app provider instance\"\"\"\n         from providers.in_app import InAppProvider\n+\n         return InAppProvider(db_session=db_session, cache=mock_redis)\n-    \n-    async def test_send_in_app_notification_success(self, in_app_provider, mock_user_data):\n+\n+    async def test_send_in_app_notification_success(\n+        self, in_app_provider, mock_user_data\n+    ):\n         \"\"\"Test successful in-app notification creation\"\"\"\n         notification_data = SampleNotificationData.get_notification_in_app()\n         notification_data[\"user_id\"] = mock_user_data[\"user_id\"]\n-        \n+\n         result = await in_app_provider.send(\n             user_id=notification_data[\"user_id\"],\n             title=notification_data[\"subject\"],\n             content=notification_data[\"content\"],\n-            data=notification_data[\"data\"]\n+            data=notification_data[\"data\"],\n         )\n-        \n+\n         assert result[\"status\"] == \"sent\"\n         assert \"message_id\" in result\n         assert result[\"provider\"] == \"in_app\"\n-    \n+\n     async def test_get_unread_notifications(self, in_app_provider, mock_user_data):\n         \"\"\"Test retrieving unread in-app notifications\"\"\"\n         user_id = mock_user_data[\"user_id\"]\n-        \n+\n         # First, create some notifications\n         for i in range(3):\n             await in_app_provider.send(\n                 user_id=user_id,\n                 title=f\"Test Notification {i+1}\",\n                 content=f\"This is test notification {i+1}\",\n-                data={\"sequence\": i+1}\n-            )\n-        \n+                data={\"sequence\": i + 1},\n+            )\n+\n         # Get unread notifications\n         unread_notifications = await in_app_provider.get_unread_notifications(user_id)\n-        \n+\n         assert len(unread_notifications) == 3\n         assert all(not notif[\"is_read\"] for notif in unread_notifications)\n-        \n+\n         # Get unread count\n         unread_count = await in_app_provider.get_unread_count(user_id)\n         assert unread_count == 3\n-    \n+\n     async def test_mark_notifications_as_read(self, in_app_provider, mock_user_data):\n         \"\"\"Test marking notifications as read\"\"\"\n         user_id = mock_user_data[\"user_id\"]\n-        \n+\n         # Create notifications\n         notification_ids = []\n         for i in range(3):\n             result = await in_app_provider.send(\n                 user_id=user_id,\n                 title=f\"Test Notification {i+1}\",\n-                content=f\"Content {i+1}\"\n+                content=f\"Content {i+1}\",\n             )\n             notification_ids.append(result[\"message_id\"])\n-        \n+\n         # Mark first two as read\n         marked_count = await in_app_provider.mark_notifications_read(\n-            user_id=user_id,\n-            notification_ids=notification_ids[:2]\n+            user_id=user_id, notification_ids=notification_ids[:2]\n         )\n-        \n+\n         assert marked_count == 2\n-        \n+\n         # Verify unread count decreased\n         unread_count = await in_app_provider.get_unread_count(user_id)\n         assert unread_count == 1\n-    \n+\n     async def test_get_notification_history(self, in_app_provider, mock_user_data):\n         \"\"\"Test retrieving notification history with pagination\"\"\"\n         user_id = mock_user_data[\"user_id\"]\n-        \n+\n         # Create multiple notifications\n         for i in range(10):\n             await in_app_provider.send(\n                 user_id=user_id,\n                 title=f\"Historical Notification {i+1}\",\n-                content=f\"Content {i+1}\"\n-            )\n-        \n+                content=f\"Content {i+1}\",\n+            )\n+\n         # Get first page\n         page1 = await in_app_provider.get_notification_history(\n-            user_id=user_id,\n-            page=1,\n-            page_size=5\n+            user_id=user_id, page=1, page_size=5\n         )\n-        \n+\n         assert len(page1[\"notifications\"]) == 5\n         assert page1[\"total\"] == 10\n         assert page1[\"page\"] == 1\n         assert page1[\"has_more\"] is True\n-        \n+\n         # Get second page\n         page2 = await in_app_provider.get_notification_history(\n-            user_id=user_id,\n-            page=2,\n-            page_size=5\n+            user_id=user_id, page=2, page_size=5\n         )\n-        \n+\n         assert len(page2[\"notifications\"]) == 5\n         assert page2[\"page\"] == 2\n         assert page2[\"has_more\"] is False\n-    \n+\n     async def test_delete_old_notifications(self, in_app_provider, mock_user_data):\n         \"\"\"Test cleanup of old notifications\"\"\"\n         user_id = mock_user_data[\"user_id\"]\n-        \n+\n         # Create notifications with different ages\n         old_date = datetime.utcnow() - timedelta(days=90)\n         recent_date = datetime.utcnow() - timedelta(days=10)\n-        \n+\n         # Mock old notifications (would need to manipulate created_at dates)\n         # This test would verify cleanup functionality\n-        \n+\n         initial_count = await in_app_provider.get_total_count(user_id)\n-        \n+\n         # Perform cleanup (remove notifications older than 30 days)\n         cleaned_count = await in_app_provider.cleanup_old_notifications(\n-            user_id=user_id,\n-            days_to_keep=30\n+            user_id=user_id, days_to_keep=30\n         )\n-        \n+\n         final_count = await in_app_provider.get_total_count(user_id)\n-        \n+\n         assert final_count <= initial_count\n         assert cleaned_count >= 0\n \n \n @pytest.mark.integration\n class TestAdvancedEmailProviderIntegration:\n     \"\"\"Advanced integration tests for email provider with failover and rate limiting\"\"\"\n-    \n+\n     @pytest.fixture\n     async def multi_provider_config(self):\n         \"\"\"Email provider with multiple SMTP backends\"\"\"\n         return {\n             \"primary\": {\n                 \"host\": \"primary-smtp.example.com\",\n                 \"port\": 587,\n                 \"username\": \"primary@example.com\",\n-                \"password\": \"primary_pass\"\n+                \"password\": \"primary_pass\",\n             },\n             \"secondary\": {\n-                \"host\": \"backup-smtp.example.com\", \n+                \"host\": \"backup-smtp.example.com\",\n                 \"port\": 587,\n                 \"username\": \"backup@example.com\",\n-                \"password\": \"backup_pass\"\n+                \"password\": \"backup_pass\",\n             },\n             \"sendgrid\": {\n                 \"api_key\": \"SG.test_api_key\",\n-                \"endpoint\": \"https://api.sendgrid.com/v3/mail/send\"\n-            }\n+                \"endpoint\": \"https://api.sendgrid.com/v3/mail/send\",\n+            },\n         }\n-    \n+\n     async def test_email_provider_failover_sequence(self, multi_provider_config):\n         \"\"\"Test email provider failover when primary fails\"\"\"\n         from providers.email import MultiEmailProvider\n-        \n+\n         provider = MultiEmailProvider(multi_provider_config)\n-        \n-        with patch('aiosmtplib.SMTP') as mock_smtp, \\\n-             patch('httpx.AsyncClient.post') as mock_sendgrid:\n-            \n+\n+        with patch(\"aiosmtplib.SMTP\") as mock_smtp, patch(\n+            \"httpx.AsyncClient.post\"\n+        ) as mock_sendgrid:\n+\n             # Mock primary SMTP failure\n             mock_smtp_primary = AsyncMock()\n             mock_smtp_primary.connect.side_effect = Exception(\"Primary SMTP down\")\n-            \n+\n             # Mock secondary SMTP success\n             mock_smtp_secondary = AsyncMock()\n             mock_smtp_secondary.connect.return_value = None\n             mock_smtp_secondary.send_message.return_value = {}\n-            \n+\n             # Configure SMTP mock to return different instances\n             mock_smtp.side_effect = [mock_smtp_primary, mock_smtp_secondary]\n-            \n+\n             result = await provider.send_with_failover(\n                 recipient=\"test@example.com\",\n                 subject=\"Failover Test\",\n-                content=\"Testing failover mechanism\"\n-            )\n-            \n+                content=\"Testing failover mechanism\",\n+            )\n+\n             assert result[\"status\"] == \"sent\"\n             assert result[\"provider_used\"] == \"secondary\"\n             assert \"failover_attempted\" in result\n             assert result[\"failover_attempted\"] is True\n-    \n+\n     async def test_email_provider_sendgrid_integration(self, multi_provider_config):\n         \"\"\"Test SendGrid API integration with comprehensive error handling\"\"\"\n         from providers.email import SendGridEmailProvider\n-        \n+\n         provider = SendGridEmailProvider(multi_provider_config[\"sendgrid\"])\n-        \n+\n         # Test successful send\n-        with patch('httpx.AsyncClient.post') as mock_post:\n+        with patch(\"httpx.AsyncClient.post\") as mock_post:\n             mock_response = AsyncMock()\n             mock_response.status_code = 202\n             mock_response.json.return_value = {\"message\": \"success\"}\n             mock_response.headers = {\"X-Message-Id\": \"sg-message-123\"}\n             mock_post.return_value = mock_response\n-            \n+\n             result = await provider.send(\n                 recipient=\"user@example.com\",\n                 subject=\"SendGrid Test\",\n                 content=\"Testing SendGrid integration\",\n-                data={\"user_name\": \"John Doe\"}\n-            )\n-            \n+                data={\"user_name\": \"John Doe\"},\n+            )\n+\n             assert result[\"status\"] == \"sent\"\n             assert result[\"message_id\"] == \"sg-message-123\"\n             assert result[\"provider\"] == \"sendgrid\"\n-            \n+\n             # Verify request structure\n             call_args = mock_post.call_args\n             request_data = json.loads(call_args.kwargs[\"content\"])\n             assert \"personalizations\" in request_data\n             assert \"from\" in request_data\n             assert \"content\" in request_data\n-    \n+\n     async def test_email_rate_limiting_with_backoff(self, multi_provider_config):\n         \"\"\"Test email rate limiting with exponential backoff\"\"\"\n         from providers.email import RateLimitedEmailProvider\n-        \n+\n         provider = RateLimitedEmailProvider(\n             config=multi_provider_config[\"primary\"],\n             rate_limit_per_minute=10,\n-            rate_limit_per_hour=100\n+            rate_limit_per_hour=100,\n         )\n-        \n-        with patch('aiosmtplib.SMTP') as mock_smtp:\n+\n+        with patch(\"aiosmtplib.SMTP\") as mock_smtp:\n             mock_smtp_instance = AsyncMock()\n-            \n+\n             # First few requests succeed\n             mock_smtp_instance.send_message.return_value = {}\n             mock_smtp.return_value = mock_smtp_instance\n-            \n+\n             # Send requests rapidly\n             results = []\n             for i in range(15):  # Exceed rate limit of 10/minute\n                 result = await provider.send(\n                     recipient=f\"user{i}@example.com\",\n                     subject=f\"Rate Test {i}\",\n-                    content=f\"Message {i}\"\n+                    content=f\"Message {i}\",\n                 )\n                 results.append(result)\n-            \n+\n             # Verify rate limiting kicked in\n             successful_sends = [r for r in results if r[\"status\"] == \"sent\"]\n             rate_limited = [r for r in results if r[\"status\"] == \"rate_limited\"]\n-            \n+\n             assert len(successful_sends) <= 10  # Within rate limit\n-            assert len(rate_limited) >= 5      # Exceeded limit\n-            \n+            assert len(rate_limited) >= 5  # Exceeded limit\n+\n             # Verify backoff information is provided\n             for limited_result in rate_limited:\n                 assert \"retry_after\" in limited_result\n                 assert \"rate_limit_type\" in limited_result\n \n \n-@pytest.mark.integration \n+@pytest.mark.integration\n class TestAdvancedSMSProviderIntegration:\n     \"\"\"Advanced SMS provider integration tests with multiple providers and failover\"\"\"\n-    \n+\n     @pytest.fixture\n     async def multi_sms_config(self):\n         \"\"\"Multi-provider SMS configuration\"\"\"\n         return {\n             \"twilio\": {\n                 \"account_sid\": \"twilio_test_sid\",\n                 \"auth_token\": \"twilio_test_token\",\n-                \"from_number\": \"+1234567890\"\n+                \"from_number\": \"+1234567890\",\n             },\n             \"aws_sns\": {\n                 \"access_key\": \"aws_access_key\",\n                 \"secret_key\": \"aws_secret_key\",\n-                \"region\": \"us-east-1\"\n+                \"region\": \"us-east-1\",\n             },\n             \"ovh\": {\n                 \"application_key\": \"ovh_app_key\",\n                 \"application_secret\": \"ovh_app_secret\",\n                 \"consumer_key\": \"ovh_consumer_key\",\n-                \"account\": \"ovh_account\"\n-            }\n+                \"account\": \"ovh_account\",\n+            },\n         }\n-    \n+\n     async def test_sms_multi_provider_cost_optimization(self, multi_sms_config):\n         \"\"\"Test SMS routing based on cost optimization\"\"\"\n         from providers.sms import CostOptimizedSMSProvider\n-        \n+\n         provider = CostOptimizedSMSProvider(multi_sms_config)\n-        \n-        with patch('twilio.rest.Client') as mock_twilio, \\\n-             patch('boto3.client') as mock_aws, \\\n-             patch('ovh.Api') as mock_ovh:\n-            \n+\n+        with patch(\"twilio.rest.Client\") as mock_twilio, patch(\n+            \"boto3.client\"\n+        ) as mock_aws, patch(\"ovh.Api\") as mock_ovh:\n+\n             # Mock cost responses for different regions/countries\n             mock_twilio_client = MagicMock()\n             mock_twilio_client.messages.create.return_value.sid = \"twilio_123\"\n             mock_twilio.return_value = mock_twilio_client\n-            \n+\n             # Test domestic US number (should use cheapest US provider)\n             us_result = await provider.send_optimized(\n-                recipient=\"+1234567890\",\n-                content=\"Test US message\"\n-            )\n-            \n+                recipient=\"+1234567890\", content=\"Test US message\"\n+            )\n+\n             assert us_result[\"status\"] == \"sent\"\n             assert \"cost_estimate\" in us_result\n             assert \"provider_selected\" in us_result\n             assert us_result[\"provider_selected\"] in [\"twilio\", \"aws_sns\"]\n-            \n+\n             # Test international number (should route to best international rate)\n             intl_result = await provider.send_optimized(\n                 recipient=\"+33123456789\",  # French number\n-                content=\"Test international message\"\n-            )\n-            \n+                content=\"Test international message\",\n+            )\n+\n             assert intl_result[\"status\"] == \"sent\"\n             assert \"cost_estimate\" in intl_result\n             assert \"provider_selected\" in intl_result\n-    \n+\n     async def test_sms_delivery_tracking_integration(self, multi_sms_config):\n         \"\"\"Test comprehensive SMS delivery tracking\"\"\"\n         from providers.sms import DeliveryTrackingSMSProvider\n-        \n+\n         provider = DeliveryTrackingSMSProvider(multi_sms_config[\"twilio\"])\n-        \n-        with patch('twilio.rest.Client') as mock_twilio:\n+\n+        with patch(\"twilio.rest.Client\") as mock_twilio:\n             mock_client = MagicMock()\n-            \n+\n             # Mock message creation\n             mock_message = MagicMock()\n             mock_message.sid = \"SMS_TRACK_123\"\n             mock_message.status = \"queued\"\n             mock_message.date_sent = datetime.utcnow()\n             mock_client.messages.create.return_value = mock_message\n-            \n+\n             # Mock status updates\n             mock_client.messages.get.return_value = mock_message\n             mock_twilio.return_value = mock_client\n-            \n+\n             # Send message with tracking\n             result = await provider.send_with_tracking(\n                 recipient=\"+1234567890\",\n                 content=\"Tracked message\",\n-                webhook_url=\"https://api.example.com/sms/webhook\"\n-            )\n-            \n+                webhook_url=\"https://api.example.com/sms/webhook\",\n+            )\n+\n             assert result[\"status\"] == \"sent\"\n             assert result[\"message_id\"] == \"SMS_TRACK_123\"\n             assert \"tracking_id\" in result\n-            \n+\n             # Simulate status updates\n             status_updates = [\n                 {\"status\": \"sent\", \"timestamp\": datetime.utcnow()},\n-                {\"status\": \"delivered\", \"timestamp\": datetime.utcnow() + timedelta(minutes=1)}\n+                {\n+                    \"status\": \"delivered\",\n+                    \"timestamp\": datetime.utcnow() + timedelta(minutes=1),\n+                },\n             ]\n-            \n+\n             for update in status_updates:\n                 tracking_result = await provider.update_delivery_status(\n                     message_id=\"SMS_TRACK_123\",\n                     status=update[\"status\"],\n-                    timestamp=update[\"timestamp\"]\n+                    timestamp=update[\"timestamp\"],\n                 )\n-                \n+\n                 assert tracking_result[\"updated\"] is True\n                 assert tracking_result[\"current_status\"] == update[\"status\"]\n-    \n+\n     async def test_sms_content_optimization(self, multi_sms_config):\n         \"\"\"Test SMS content optimization for different providers\"\"\"\n         from providers.sms import ContentOptimizedSMSProvider\n-        \n+\n         provider = ContentOptimizedSMSProvider(multi_sms_config[\"twilio\"])\n-        \n-        with patch('twilio.rest.Client') as mock_twilio:\n+\n+        with patch(\"twilio.rest.Client\") as mock_twilio:\n             mock_client = MagicMock()\n             mock_message = MagicMock()\n             mock_client.messages.create.return_value = mock_message\n             mock_twilio.return_value = mock_client\n-            \n+\n             # Test long message optimization\n             long_message = \"This is a very long SMS message that exceeds the standard 160 character limit for GSM encoding. The provider should automatically optimize this by either splitting it into multiple segments or using Unicode encoding efficiently to minimize cost while maintaining readability.\"\n-            \n+\n             result = await provider.send_optimized(\n-                recipient=\"+1234567890\",\n-                content=long_message\n-            )\n-            \n+                recipient=\"+1234567890\", content=long_message\n+            )\n+\n             assert result[\"status\"] == \"sent\"\n             assert \"optimization_applied\" in result\n             assert \"segment_count\" in result\n             assert \"encoding_used\" in result\n             assert result[\"segment_count\"] >= 1\n-            \n+\n             # Verify optimization decisions\n             call_args = mock_client.messages.create.call_args\n             optimized_content = call_args.kwargs[\"body\"]\n             assert len(optimized_content) <= len(long_message)  # Should be optimized\n \n \n @pytest.mark.integration\n class TestNotificationProviderFactory:\n     \"\"\"Integration tests for notification provider factory\"\"\"\n-    \n+\n     async def test_provider_factory_email(self):\n         \"\"\"Test creating email provider through factory\"\"\"\n         from providers.factory import NotificationProviderFactory\n-        \n+\n         config = {\n             \"type\": \"email\",\n             \"host\": \"smtp.example.com\",\n             \"port\": 587,\n             \"username\": \"test@example.com\",\n-            \"password\": \"password\"\n+            \"password\": \"password\",\n         }\n-        \n+\n         provider = NotificationProviderFactory.create_provider(config)\n-        \n+\n         assert provider is not None\n-        assert hasattr(provider, 'send')\n+        assert hasattr(provider, \"send\")\n         assert provider.__class__.__name__ == \"EmailProvider\"\n-    \n+\n     async def test_provider_factory_sms(self):\n         \"\"\"Test creating SMS provider through factory\"\"\"\n         from providers.factory import NotificationProviderFactory\n-        \n-        config = {\n-            \"type\": \"sms\",\n-            \"account_sid\": \"test_sid\",\n-            \"auth_token\": \"test_token\"\n-        }\n-        \n+\n+        config = {\"type\": \"sms\", \"account_sid\": \"test_sid\", \"auth_token\": \"test_token\"}\n+\n         provider = NotificationProviderFactory.create_provider(config)\n-        \n+\n         assert provider is not None\n-        assert hasattr(provider, 'send')\n+        assert hasattr(provider, \"send\")\n         assert provider.__class__.__name__ == \"SMSProvider\"\n-    \n+\n     async def test_provider_factory_push(self):\n         \"\"\"Test creating push provider through factory\"\"\"\n         from providers.factory import NotificationProviderFactory\n-        \n+\n         config = {\n             \"type\": \"push\",\n             \"server_key\": \"test_key\",\n-            \"project_id\": \"test_project\"\n+            \"project_id\": \"test_project\",\n         }\n-        \n+\n         provider = NotificationProviderFactory.create_provider(config)\n-        \n+\n         assert provider is not None\n-        assert hasattr(provider, 'send')\n+        assert hasattr(provider, \"send\")\n         assert provider.__class__.__name__ == \"PushProvider\"\n-    \n+\n     async def test_provider_factory_invalid_type(self):\n         \"\"\"Test factory with invalid provider type\"\"\"\n         from providers.factory import NotificationProviderFactory\n-        \n-        config = {\n-            \"type\": \"invalid_type\",\n-            \"some_config\": \"value\"\n-        }\n-        \n+\n+        config = {\"type\": \"invalid_type\", \"some_config\": \"value\"}\n+\n         with pytest.raises(ValueError, match=\"Unsupported provider type\"):\n             NotificationProviderFactory.create_provider(config)\n-    \n+\n     async def test_provider_factory_missing_config(self):\n         \"\"\"Test factory with missing required configuration\"\"\"\n         from providers.factory import NotificationProviderFactory\n-        \n+\n         config = {\n             \"type\": \"email\"\n             # Missing required email configuration\n         }\n-        \n+\n         with pytest.raises((ValueError, KeyError)):\n-            NotificationProviderFactory.create_provider(config)\n\\ No newline at end of file\n+            NotificationProviderFactory.create_provider(config)\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_redis.py\t2025-09-09 13:34:05.532292+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_redis.py\t2025-09-10 11:37:03.011885+00:00\n@@ -1,428 +1,455 @@\n \"\"\"\n Tests for Redis client and caching functionality\n \"\"\"\n+\n import pytest\n from unittest.mock import patch, MagicMock\n import json\n import os\n \n from redis_client import (\n-    RedisConfig, CacheManager, TemplateCache, UserPreferenceCache, \n-    SessionManager, NotificationQueue, get_cache_stats, clear_all_cache\n+    RedisConfig,\n+    CacheManager,\n+    TemplateCache,\n+    UserPreferenceCache,\n+    SessionManager,\n+    NotificationQueue,\n+    get_cache_stats,\n+    clear_all_cache,\n )\n+\n \n class TestRedisConfig:\n     \"\"\"Test RedisConfig class\"\"\"\n-    \n+\n     def test_redis_url_from_env(self):\n         \"\"\"Test Redis URL configuration from environment\"\"\"\n-        with patch.dict(os.environ, {'REDIS_URL': 'redis://localhost:6379/5'}):\n+        with patch.dict(os.environ, {\"REDIS_URL\": \"redis://localhost:6379/5\"}):\n             config = RedisConfig()\n-            assert config.redis_url == 'redis://localhost:6379/5'\n-    \n+            assert config.redis_url == \"redis://localhost:6379/5\"\n+\n     def test_redis_url_from_components(self):\n         \"\"\"Test Redis URL construction from components\"\"\"\n         env_vars = {\n-            'REDIS_HOST': 'redis-host',\n-            'REDIS_PORT': '6380',\n-            'REDIS_DB': '3',\n-            'REDIS_PASSWORD': 'secret'\n+            \"REDIS_HOST\": \"redis-host\",\n+            \"REDIS_PORT\": \"6380\",\n+            \"REDIS_DB\": \"3\",\n+            \"REDIS_PASSWORD\": \"secret\",\n         }\n-        \n+\n         with patch.dict(os.environ, env_vars, clear=True):\n             config = RedisConfig()\n-            expected_url = 'redis://:secret@redis-host:6380/3'\n+            expected_url = \"redis://:secret@redis-host:6380/3\"\n             assert config.redis_url == expected_url\n-    \n+\n     def test_redis_url_without_password(self):\n         \"\"\"Test Redis URL construction without password\"\"\"\n-        env_vars = {\n-            'REDIS_HOST': 'redis-host',\n-            'REDIS_PORT': '6380',\n-            'REDIS_DB': '3'\n-        }\n-        \n+        env_vars = {\"REDIS_HOST\": \"redis-host\", \"REDIS_PORT\": \"6380\", \"REDIS_DB\": \"3\"}\n+\n         with patch.dict(os.environ, env_vars, clear=True):\n             config = RedisConfig()\n-            expected_url = 'redis://redis-host:6380/3'\n+            expected_url = \"redis://redis-host:6380/3\"\n             assert config.redis_url == expected_url\n-    \n+\n     def test_default_redis_url(self):\n         \"\"\"Test default Redis URL\"\"\"\n-        env_vars_to_clear = ['REDIS_URL', 'REDIS_HOST', 'REDIS_PORT', 'REDIS_DB', 'REDIS_PASSWORD']\n-        \n+        env_vars_to_clear = [\n+            \"REDIS_URL\",\n+            \"REDIS_HOST\",\n+            \"REDIS_PORT\",\n+            \"REDIS_DB\",\n+            \"REDIS_PASSWORD\",\n+        ]\n+\n         with patch.dict(os.environ, {}, clear=True):\n-            with patch('redis_client.redis.from_url') as mock_redis:\n+            with patch(\"redis_client.redis.from_url\") as mock_redis:\n                 mock_redis.return_value.ping.return_value = True\n                 config = RedisConfig()\n-                expected_url = 'redis://localhost:6382/0'\n+                expected_url = \"redis://localhost:6382/0\"\n                 assert config.redis_url == expected_url\n-    \n+\n     def test_health_check_success(self, mock_redis):\n         \"\"\"Test successful Redis health check\"\"\"\n         config = RedisConfig()\n         config.sync_client = mock_redis\n-        \n+\n         mock_redis.ping.return_value = True\n         assert config.health_check() is True\n-    \n+\n     def test_health_check_failure(self, mock_redis):\n         \"\"\"Test failed Redis health check\"\"\"\n         config = RedisConfig()\n         config.sync_client = mock_redis\n-        \n+\n         mock_redis.ping.side_effect = Exception(\"Connection failed\")\n         assert config.health_check() is False\n \n+\n class TestCacheManager:\n     \"\"\"Test CacheManager functionality\"\"\"\n-    \n+\n     def test_cache_key_prefix(self, mock_redis):\n         \"\"\"Test cache key prefixing\"\"\"\n         cache = CacheManager(mock_redis, prefix=\"test\")\n-        \n+\n         cache.set(\"key1\", \"value1\")\n-        mock_redis.setex.assert_called_with(\"test:key1\", cache.client.cache_ttl, \"value1\")\n-    \n+        mock_redis.setex.assert_called_with(\n+            \"test:key1\", cache.client.cache_ttl, \"value1\"\n+        )\n+\n     def test_set_cache_with_ttl(self, mock_redis):\n         \"\"\"Test setting cache value with TTL\"\"\"\n         cache = CacheManager(mock_redis)\n-        \n+\n         cache.set(\"test_key\", {\"data\": \"value\"}, ttl=300)\n-        \n+\n         expected_value = json.dumps({\"data\": \"value\"})\n         mock_redis.setex.assert_called_with(\"comm:test_key\", 300, expected_value)\n-    \n+\n     def test_set_cache_without_ttl(self, mock_redis):\n         \"\"\"Test setting cache value without TTL\"\"\"\n         cache = CacheManager(mock_redis)\n-        \n+\n         cache.set(\"test_key\", \"simple_value\")\n         mock_redis.set.assert_called_with(\"comm:test_key\", \"simple_value\")\n-    \n+\n     def test_get_cache_json_value(self, mock_redis):\n         \"\"\"Test getting JSON cache value\"\"\"\n         cache = CacheManager(mock_redis)\n-        \n+\n         json_value = json.dumps({\"data\": \"value\"})\n         mock_redis.get.return_value = json_value\n-        \n+\n         result = cache.get(\"test_key\")\n         assert result == {\"data\": \"value\"}\n-    \n+\n     def test_get_cache_string_value(self, mock_redis):\n         \"\"\"Test getting string cache value\"\"\"\n         cache = CacheManager(mock_redis)\n-        \n+\n         mock_redis.get.return_value = \"simple_value\"\n-        \n+\n         result = cache.get(\"test_key\")\n         assert result == \"simple_value\"\n-    \n+\n     def test_get_cache_nonexistent(self, mock_redis):\n         \"\"\"Test getting nonexistent cache value\"\"\"\n         cache = CacheManager(mock_redis)\n-        \n+\n         mock_redis.get.return_value = None\n-        \n+\n         result = cache.get(\"nonexistent_key\", default=\"default_value\")\n         assert result == \"default_value\"\n-    \n+\n     def test_delete_cache(self, mock_redis):\n         \"\"\"Test deleting cache entry\"\"\"\n         cache = CacheManager(mock_redis)\n-        \n+\n         mock_redis.delete.return_value = 1\n         result = cache.delete(\"test_key\")\n-        \n+\n         assert result is True\n         mock_redis.delete.assert_called_with(\"comm:test_key\")\n-    \n+\n     def test_cache_exists(self, mock_redis):\n         \"\"\"Test checking cache existence\"\"\"\n         cache = CacheManager(mock_redis)\n-        \n+\n         mock_redis.exists.return_value = 1\n         result = cache.exists(\"test_key\")\n-        \n+\n         assert result is True\n         mock_redis.exists.assert_called_with(\"comm:test_key\")\n-    \n+\n     def test_cache_ttl(self, mock_redis):\n         \"\"\"Test getting cache TTL\"\"\"\n         cache = CacheManager(mock_redis)\n-        \n+\n         mock_redis.ttl.return_value = 300\n         result = cache.ttl(\"test_key\")\n-        \n+\n         assert result == 300\n         mock_redis.ttl.assert_called_with(\"comm:test_key\")\n-    \n+\n     def test_clear_pattern(self, mock_redis):\n         \"\"\"Test clearing cache entries by pattern\"\"\"\n         cache = CacheManager(mock_redis)\n-        \n+\n         mock_redis.keys.return_value = [\"comm:pattern:key1\", \"comm:pattern:key2\"]\n         mock_redis.delete.return_value = 2\n-        \n+\n         result = cache.clear_pattern(\"pattern:*\")\n-        \n+\n         assert result == 2\n         mock_redis.keys.assert_called_with(\"comm:pattern:*\")\n         mock_redis.delete.assert_called_with(\"comm:pattern:key1\", \"comm:pattern:key2\")\n \n+\n class TestTemplateCache:\n     \"\"\"Test TemplateCache functionality\"\"\"\n-    \n+\n     def test_get_template(self, mock_cache_manager):\n         \"\"\"Test getting cached template\"\"\"\n         template_cache = TemplateCache(mock_cache_manager)\n-        \n-        mock_cache_manager.get.return_value = {\"name\": \"test_template\", \"content\": \"Hello {{name}}\"}\n-        \n+\n+        mock_cache_manager.get.return_value = {\n+            \"name\": \"test_template\",\n+            \"content\": \"Hello {{name}}\",\n+        }\n+\n         result = template_cache.get_template(\"template_123\")\n-        \n+\n         assert result[\"name\"] == \"test_template\"\n         mock_cache_manager.get.assert_called_with(\"template:template_123\")\n-    \n+\n     def test_set_template(self, mock_cache_manager):\n         \"\"\"Test setting cached template\"\"\"\n         template_cache = TemplateCache(mock_cache_manager)\n-        \n+\n         template_data = {\"name\": \"test_template\", \"content\": \"Hello {{name}}\"}\n-        \n+\n         template_cache.set_template(\"template_123\", template_data, ttl=600)\n-        \n-        mock_cache_manager.set.assert_called_with(\"template:template_123\", template_data, 600)\n-    \n+\n+        mock_cache_manager.set.assert_called_with(\n+            \"template:template_123\", template_data, 600\n+        )\n+\n     def test_invalidate_template(self, mock_cache_manager):\n         \"\"\"Test invalidating cached template\"\"\"\n         template_cache = TemplateCache(mock_cache_manager)\n-        \n+\n         template_cache.invalidate_template(\"template_123\")\n-        \n+\n         mock_cache_manager.delete.assert_called_with(\"template:template_123\")\n-    \n+\n     def test_rendered_template_cache(self, mock_cache_manager):\n         \"\"\"Test rendered template caching\"\"\"\n         template_cache = TemplateCache(mock_cache_manager)\n-        \n+\n         # Test setting rendered template\n-        template_cache.set_rendered_template(\"template_123\", \"hash_abc\", \"Rendered content\", ttl=300)\n-        mock_cache_manager.set.assert_called_with(\"rendered:template_123:hash_abc\", \"Rendered content\", 300)\n-        \n+        template_cache.set_rendered_template(\n+            \"template_123\", \"hash_abc\", \"Rendered content\", ttl=300\n+        )\n+        mock_cache_manager.set.assert_called_with(\n+            \"rendered:template_123:hash_abc\", \"Rendered content\", 300\n+        )\n+\n         # Test getting rendered template\n         mock_cache_manager.get.return_value = \"Rendered content\"\n         result = template_cache.get_rendered_template(\"template_123\", \"hash_abc\")\n-        \n+\n         assert result == \"Rendered content\"\n         mock_cache_manager.get.assert_called_with(\"rendered:template_123:hash_abc\")\n \n+\n class TestUserPreferenceCache:\n     \"\"\"Test UserPreferenceCache functionality\"\"\"\n-    \n+\n     def test_get_preferences(self, mock_cache_manager):\n         \"\"\"Test getting cached user preferences\"\"\"\n         pref_cache = UserPreferenceCache(mock_cache_manager)\n-        \n+\n         prefs = {\"email_enabled\": True, \"sms_enabled\": False}\n         mock_cache_manager.get.return_value = prefs\n-        \n+\n         result = pref_cache.get_preferences(\"user_123\")\n-        \n+\n         assert result == prefs\n         mock_cache_manager.get.assert_called_with(\"prefs:user_123\")\n-    \n+\n     def test_set_preferences(self, mock_cache_manager):\n         \"\"\"Test setting cached user preferences\"\"\"\n         pref_cache = UserPreferenceCache(mock_cache_manager)\n-        \n+\n         prefs = {\"email_enabled\": True, \"sms_enabled\": False}\n-        \n+\n         pref_cache.set_preferences(\"user_123\", prefs, ttl=600)\n-        \n+\n         mock_cache_manager.set.assert_called_with(\"prefs:user_123\", prefs, 600)\n-    \n+\n     def test_invalidate_preferences(self, mock_cache_manager):\n         \"\"\"Test invalidating cached user preferences\"\"\"\n         pref_cache = UserPreferenceCache(mock_cache_manager)\n-        \n+\n         pref_cache.invalidate_preferences(\"user_123\")\n-        \n+\n         mock_cache_manager.delete.assert_called_with(\"prefs:user_123\")\n+\n \n class TestSessionManager:\n     \"\"\"Test SessionManager functionality\"\"\"\n-    \n+\n     def test_create_session(self, mock_cache_manager):\n         \"\"\"Test creating user session\"\"\"\n         session_manager = SessionManager(mock_cache_manager)\n-        \n+\n         metadata = {\"device\": \"mobile\", \"location\": \"US\"}\n         session_manager.create_session(\"user_123\", \"session_abc\", metadata)\n-        \n+\n         # Verify cache.set was called with session data\n         call_args = mock_cache_manager.set.call_args\n         assert call_args[0][0] == \"session:session_abc\"\n-        \n+\n         session_data = call_args[0][1]\n         assert session_data[\"user_id\"] == \"user_123\"\n         assert session_data[\"metadata\"] == metadata\n         assert \"created_at\" in session_data\n-    \n+\n     def test_get_session(self, mock_cache_manager):\n         \"\"\"Test getting session data\"\"\"\n         session_manager = SessionManager(mock_cache_manager)\n-        \n+\n         session_data = {\n             \"user_id\": \"user_123\",\n             \"created_at\": \"2023-01-01T00:00:00\",\n-            \"metadata\": {\"device\": \"mobile\"}\n+            \"metadata\": {\"device\": \"mobile\"},\n         }\n         mock_cache_manager.get.return_value = session_data\n-        \n+\n         result = session_manager.get_session(\"session_abc\")\n-        \n+\n         assert result == session_data\n         mock_cache_manager.get.assert_called_with(\"session:session_abc\")\n-    \n+\n     def test_update_session_activity(self, mock_cache_manager):\n         \"\"\"Test updating session activity\"\"\"\n         session_manager = SessionManager(mock_cache_manager)\n-        \n+\n         # Mock existing session\n         session_data = {\n             \"user_id\": \"user_123\",\n             \"created_at\": \"2023-01-01T00:00:00\",\n-            \"metadata\": {}\n+            \"metadata\": {},\n         }\n         mock_cache_manager.get.return_value = session_data\n-        \n+\n         session_manager.update_session_activity(\"session_abc\")\n-        \n+\n         # Verify that set was called with updated session data\n         call_args = mock_cache_manager.set.call_args\n         updated_data = call_args[0][1]\n         assert \"last_activity\" in updated_data\n-    \n+\n     def test_delete_session(self, mock_cache_manager):\n         \"\"\"Test deleting session\"\"\"\n         session_manager = SessionManager(mock_cache_manager)\n-        \n+\n         session_manager.delete_session(\"session_abc\")\n-        \n+\n         mock_cache_manager.delete.assert_called_with(\"session:session_abc\")\n+\n \n class TestNotificationQueue:\n     \"\"\"Test NotificationQueue functionality\"\"\"\n-    \n+\n     def test_enqueue_notification(self, mock_redis):\n         \"\"\"Test enqueueing notification\"\"\"\n         queue = NotificationQueue(mock_redis)\n-        \n+\n         notification_data = {\"user_id\": \"123\", \"content\": \"Test notification\"}\n-        \n+\n         mock_redis.lpush.return_value = 1\n         result = queue.enqueue_notification(notification_data)\n-        \n+\n         assert result is True\n-        \n+\n         # Verify data was serialized and enqueued\n         call_args = mock_redis.lpush.call_args[0]\n         assert call_args[0] == \"comm:notification_queue\"\n         assert json.loads(call_args[1]) == notification_data\n-    \n+\n     def test_dequeue_notification(self, mock_redis):\n         \"\"\"Test dequeueing notification\"\"\"\n         queue = NotificationQueue(mock_redis)\n-        \n+\n         notification_data = {\"user_id\": \"123\", \"content\": \"Test notification\"}\n         serialized_data = json.dumps(notification_data)\n         mock_redis.brpop.return_value = (\"comm:notification_queue\", serialized_data)\n-        \n+\n         result = queue.dequeue_notification()\n-        \n+\n         assert result == notification_data\n         mock_redis.brpop.assert_called_with(\"comm:notification_queue\", timeout=0)\n-    \n+\n     def test_dequeue_empty_queue(self, mock_redis):\n         \"\"\"Test dequeueing from empty queue\"\"\"\n         queue = NotificationQueue(mock_redis)\n-        \n+\n         mock_redis.brpop.return_value = None\n-        \n+\n         result = queue.dequeue_notification()\n-        \n+\n         assert result is None\n-    \n+\n     def test_get_queue_length(self, mock_redis):\n         \"\"\"Test getting queue length\"\"\"\n         queue = NotificationQueue(mock_redis)\n-        \n+\n         mock_redis.llen.return_value = 5\n         result = queue.get_queue_length()\n-        \n+\n         assert result == 5\n         mock_redis.llen.assert_called_with(\"comm:notification_queue\")\n-    \n+\n     def test_move_to_failed(self, mock_redis):\n         \"\"\"Test moving notification to failed queue\"\"\"\n         queue = NotificationQueue(mock_redis)\n-        \n+\n         notification_data = {\"user_id\": \"123\", \"content\": \"Test notification\"}\n-        \n+\n         mock_redis.lpush.return_value = 1\n         result = queue.move_to_failed(notification_data)\n-        \n+\n         assert result is True\n-        \n+\n         # Verify data includes failed_at timestamp\n         call_args = mock_redis.lpush.call_args[0]\n         assert call_args[0] == \"comm:failed_queue\"\n-        \n+\n         failed_data = json.loads(call_args[1])\n         assert \"failed_at\" in failed_data\n         assert failed_data[\"user_id\"] == \"123\"\n \n+\n class TestRedisUtilities:\n     \"\"\"Test Redis utility functions\"\"\"\n-    \n+\n     def test_get_cache_stats(self, mock_redis):\n         \"\"\"Test getting cache statistics\"\"\"\n-        with patch('redis_client.redis_config') as mock_config:\n+        with patch(\"redis_client.redis_config\") as mock_config:\n             mock_config.sync_client = mock_redis\n-            \n+\n             # Mock Redis info\n             mock_redis.info.return_value = {\n                 \"redis_version\": \"6.2.0\",\n                 \"used_memory_human\": \"1.5M\",\n                 \"connected_clients\": 5,\n                 \"total_commands_processed\": 1000,\n-                \"db0\": {\"keys\": 100, \"expires\": 50}\n+                \"db0\": {\"keys\": 100, \"expires\": 50},\n             }\n-            \n+\n             # Mock queue lengths\n             mock_redis.llen.side_effect = [10, 2]  # notification queue, failed queue\n-            \n-            with patch('redis_client.notification_queue') as mock_queue:\n+\n+            with patch(\"redis_client.notification_queue\") as mock_queue:\n                 mock_queue.get_queue_length.return_value = 10\n-                \n+\n                 stats = get_cache_stats()\n-                \n+\n                 assert stats[\"redis_version\"] == \"6.2.0\"\n                 assert stats[\"used_memory\"] == \"1.5M\"\n                 assert stats[\"connected_clients\"] == 5\n                 assert stats[\"queue_lengths\"][\"notifications\"] == 10\n-    \n+\n     def test_clear_all_cache(self, mock_redis):\n         \"\"\"Test clearing all cache entries\"\"\"\n-        with patch('redis_client.redis_config') as mock_config:\n+        with patch(\"redis_client.redis_config\") as mock_config:\n             mock_config.sync_client = mock_redis\n-            \n+\n             mock_redis.keys.return_value = [\"comm:key1\", \"comm:key2\", \"comm:key3\"]\n-            \n+\n             result = clear_all_cache()\n-            \n+\n             assert result is True\n             mock_redis.keys.assert_called_with(\"comm:*\")\n-            mock_redis.delete.assert_called_with(\"comm:key1\", \"comm:key2\", \"comm:key3\")\n\\ No newline at end of file\n+            mock_redis.delete.assert_called_with(\"comm:key1\", \"comm:key2\", \"comm:key3\")\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_identity_client.py\t2025-09-09 13:35:04.440462+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/test_identity_client.py\t2025-09-10 11:37:03.049762+00:00\n@@ -1,548 +1,522 @@\n \"\"\"\n Tests for Identity Service client integration\n \"\"\"\n+\n import pytest\n import jwt\n import uuid\n from datetime import datetime, timedelta\n from unittest.mock import AsyncMock, patch, MagicMock\n from fastapi import HTTPException\n \n from identity_client import (\n-    IdentityServiceClient, IdentityServiceError, get_current_user,\n-    require_permissions, require_roles, UserContactResolver\n+    IdentityServiceClient,\n+    IdentityServiceError,\n+    get_current_user,\n+    require_permissions,\n+    require_roles,\n+    UserContactResolver,\n )\n+\n \n class TestIdentityServiceClient:\n     \"\"\"Test IdentityServiceClient functionality\"\"\"\n-    \n+\n     def test_jwt_validation_success(self):\n         \"\"\"Test successful JWT validation\"\"\"\n         client = IdentityServiceClient()\n-        \n+\n         # Create a valid token\n         payload = {\n             \"sub\": \"user_123\",\n             \"email\": \"test@example.com\",\n             \"roles\": [\"user\"],\n             \"permissions\": [\"read\", \"write\"],\n-            \"exp\": datetime.utcnow() + timedelta(hours=1)\n-        }\n-        \n-        with patch.object(client, 'jwt_secret', 'test-secret'):\n-            token = jwt.encode(payload, 'test-secret', algorithm='HS256')\n+            \"exp\": datetime.utcnow() + timedelta(hours=1),\n+        }\n+\n+        with patch.object(client, \"jwt_secret\", \"test-secret\"):\n+            token = jwt.encode(payload, \"test-secret\", algorithm=\"HS256\")\n             result = client.validate_jwt_token(token)\n-            \n+\n             assert result[\"sub\"] == \"user_123\"\n             assert result[\"email\"] == \"test@example.com\"\n             assert result[\"roles\"] == [\"user\"]\n-    \n+\n     def test_jwt_validation_expired(self):\n         \"\"\"Test JWT validation with expired token\"\"\"\n         client = IdentityServiceClient()\n-        \n+\n         # Create an expired token\n-        payload = {\n-            \"sub\": \"user_123\",\n-            \"exp\": datetime.utcnow() - timedelta(hours=1)\n-        }\n-        \n-        with patch.object(client, 'jwt_secret', 'test-secret'):\n-            token = jwt.encode(payload, 'test-secret', algorithm='HS256')\n-            \n+        payload = {\"sub\": \"user_123\", \"exp\": datetime.utcnow() - timedelta(hours=1)}\n+\n+        with patch.object(client, \"jwt_secret\", \"test-secret\"):\n+            token = jwt.encode(payload, \"test-secret\", algorithm=\"HS256\")\n+\n             with pytest.raises(IdentityServiceError, match=\"Token expired\"):\n                 client.validate_jwt_token(token)\n-    \n+\n     def test_jwt_validation_invalid(self):\n         \"\"\"Test JWT validation with invalid token\"\"\"\n         client = IdentityServiceClient()\n-        \n-        with patch.object(client, 'jwt_secret', 'test-secret'):\n+\n+        with patch.object(client, \"jwt_secret\", \"test-secret\"):\n             with pytest.raises(IdentityServiceError, match=\"Invalid token\"):\n                 client.validate_jwt_token(\"invalid.token.here\")\n-    \n+\n     def test_jwt_validation_no_secret(self):\n         \"\"\"Test JWT validation without secret configured\"\"\"\n         client = IdentityServiceClient()\n         client.jwt_secret = None\n-        \n+\n         with pytest.raises(IdentityServiceError, match=\"JWT secret not configured\"):\n             client.validate_jwt_token(\"some.jwt.token\")\n-    \n+\n     @pytest.mark.asyncio\n     async def test_make_request_success(self):\n         \"\"\"Test successful HTTP request to Identity Service\"\"\"\n         client = IdentityServiceClient()\n-        \n+\n         mock_response = MagicMock()\n         mock_response.status_code = 200\n-        mock_response.json.return_value = {\"user_id\": \"123\", \"email\": \"test@example.com\"}\n-        \n-        with patch('identity_client.httpx.AsyncClient') as mock_httpx:\n+        mock_response.json.return_value = {\n+            \"user_id\": \"123\",\n+            \"email\": \"test@example.com\",\n+        }\n+\n+        with patch(\"identity_client.httpx.AsyncClient\") as mock_httpx:\n             mock_client = AsyncMock()\n             mock_httpx.return_value.__aenter__.return_value = mock_client\n             mock_client.request.return_value = mock_response\n-            \n+\n             result = await client._make_request(\"GET\", \"/test\")\n-            \n+\n             assert result == {\"user_id\": \"123\", \"email\": \"test@example.com\"}\n-    \n+\n     @pytest.mark.asyncio\n     async def test_make_request_retry_on_timeout(self):\n         \"\"\"Test request retry on timeout\"\"\"\n         client = IdentityServiceClient()\n         client.retry_count = 2\n-        \n-        with patch('identity_client.httpx.AsyncClient') as mock_httpx, \\\n-             patch('identity_client.asyncio.sleep') as mock_sleep:\n-            \n+\n+        with patch(\"identity_client.httpx.AsyncClient\") as mock_httpx, patch(\n+            \"identity_client.asyncio.sleep\"\n+        ) as mock_sleep:\n+\n             mock_client = AsyncMock()\n             mock_httpx.return_value.__aenter__.return_value = mock_client\n-            \n+\n             # First call times out, second succeeds\n             mock_response = MagicMock()\n             mock_response.status_code = 200\n             mock_response.json.return_value = {\"success\": True}\n-            \n-            mock_client.request.side_effect = [\n-                Exception(\"Timeout\"),\n-                mock_response\n-            ]\n-            \n+\n+            mock_client.request.side_effect = [Exception(\"Timeout\"), mock_response]\n+\n             result = await client._make_request(\"GET\", \"/test\")\n-            \n+\n             assert result == {\"success\": True}\n             assert mock_client.request.call_count == 2\n             mock_sleep.assert_called_once_with(1)  # 2^0 = 1 second\n-    \n+\n     @pytest.mark.asyncio\n     async def test_make_request_max_retries_exceeded(self):\n         \"\"\"Test request fails after max retries\"\"\"\n         client = IdentityServiceClient()\n         client.retry_count = 2\n-        \n-        with patch('identity_client.httpx.AsyncClient') as mock_httpx, \\\n-             patch('identity_client.asyncio.sleep'):\n-            \n+\n+        with patch(\"identity_client.httpx.AsyncClient\") as mock_httpx, patch(\n+            \"identity_client.asyncio.sleep\"\n+        ):\n+\n             mock_client = AsyncMock()\n             mock_httpx.return_value.__aenter__.return_value = mock_client\n             mock_client.request.side_effect = Exception(\"Persistent error\")\n-            \n+\n             with pytest.raises(IdentityServiceError, match=\"Request failed\"):\n                 await client._make_request(\"GET\", \"/test\")\n-    \n+\n     @pytest.mark.asyncio\n     async def test_validate_token_with_cache(self):\n         \"\"\"Test token validation with caching\"\"\"\n         client = IdentityServiceClient()\n-        \n+\n         # Mock cache manager\n-        with patch('identity_client.cache_manager') as mock_cache:\n+        with patch(\"identity_client.cache_manager\") as mock_cache:\n             cached_user = {\n                 \"user_id\": \"user_123\",\n                 \"email\": \"test@example.com\",\n-                \"validated_at\": datetime.utcnow().isoformat()\n+                \"validated_at\": datetime.utcnow().isoformat(),\n             }\n             mock_cache.get.return_value = cached_user\n-            \n+\n             result = await client.validate_token(\"test.jwt.token\")\n-            \n+\n             assert result == cached_user\n             mock_cache.get.assert_called_once()\n-    \n+\n     @pytest.mark.asyncio\n     async def test_validate_token_fallback_to_service(self):\n         \"\"\"Test token validation fallback to service call\"\"\"\n         client = IdentityServiceClient()\n-        \n-        with patch('identity_client.cache_manager') as mock_cache, \\\n-             patch.object(client, 'validate_jwt_token') as mock_jwt_validate, \\\n-             patch.object(client, '_make_request') as mock_request:\n-            \n+\n+        with patch(\"identity_client.cache_manager\") as mock_cache, patch.object(\n+            client, \"validate_jwt_token\"\n+        ) as mock_jwt_validate, patch.object(client, \"_make_request\") as mock_request:\n+\n             # No cached data\n             mock_cache.get.return_value = None\n-            \n+\n             # JWT validation fails\n             mock_jwt_validate.side_effect = IdentityServiceError(\"Invalid token\")\n-            \n+\n             # Service validation succeeds\n             service_response = {\n                 \"user_id\": \"user_123\",\n                 \"email\": \"test@example.com\",\n-                \"roles\": [\"user\"]\n+                \"roles\": [\"user\"],\n             }\n             mock_request.return_value = service_response\n-            \n+\n             result = await client.validate_token(\"test.jwt.token\")\n-            \n+\n             assert result == service_response\n             mock_request.assert_called_once_with(\n                 \"POST\",\n                 \"/auth/validate\",\n-                headers={\"Authorization\": \"Bearer test.jwt.token\"}\n+                headers={\"Authorization\": \"Bearer test.jwt.token\"},\n             )\n             mock_cache.set.assert_called_once()\n-    \n+\n     @pytest.mark.asyncio\n     async def test_get_user_profile_with_cache(self):\n         \"\"\"Test getting user profile with caching\"\"\"\n         client = IdentityServiceClient()\n-        \n-        with patch('identity_client.cache_manager') as mock_cache:\n+\n+        with patch(\"identity_client.cache_manager\") as mock_cache:\n             cached_profile = {\n                 \"user_id\": \"user_123\",\n                 \"name\": \"Test User\",\n-                \"email\": \"test@example.com\"\n+                \"email\": \"test@example.com\",\n             }\n             mock_cache.get.return_value = cached_profile\n-            \n+\n             result = await client.get_user_profile(\"user_123\", \"auth_token\")\n-            \n+\n             assert result == cached_profile\n             mock_cache.get.assert_called_with(\"profile:user_123\")\n-    \n+\n     @pytest.mark.asyncio\n     async def test_get_user_contact_info(self):\n         \"\"\"Test getting user contact information\"\"\"\n         client = IdentityServiceClient()\n-        \n+\n         contact_data = {\n             \"email\": \"test@example.com\",\n             \"phone\": \"+1234567890\",\n-            \"push_tokens\": [\"token1\", \"token2\"]\n-        }\n-        \n-        with patch('identity_client.cache_manager') as mock_cache, \\\n-             patch.object(client, '_make_request') as mock_request:\n-            \n+            \"push_tokens\": [\"token1\", \"token2\"],\n+        }\n+\n+        with patch(\"identity_client.cache_manager\") as mock_cache, patch.object(\n+            client, \"_make_request\"\n+        ) as mock_request:\n+\n             mock_cache.get.return_value = None  # No cache\n             mock_request.return_value = contact_data\n-            \n+\n             result = await client.get_user_contact_info(\"user_123\", \"auth_token\")\n-            \n+\n             assert result == contact_data\n             mock_request.assert_called_with(\n-                \"GET\",\n-                \"/users/user_123/contact\",\n-                auth_token=\"auth_token\"\n+                \"GET\", \"/users/user_123/contact\", auth_token=\"auth_token\"\n             )\n             mock_cache.set.assert_called_once()\n-    \n+\n     @pytest.mark.asyncio\n     async def test_check_user_permissions_success(self):\n         \"\"\"Test successful user permission check\"\"\"\n         client = IdentityServiceClient()\n-        \n-        user_data = {\n-            \"permissions\": [\"read\", \"write\", \"admin\"]\n-        }\n-        \n-        with patch.object(client, 'validate_token') as mock_validate:\n+\n+        user_data = {\"permissions\": [\"read\", \"write\", \"admin\"]}\n+\n+        with patch.object(client, \"validate_token\") as mock_validate:\n             mock_validate.return_value = user_data\n-            \n+\n             result = await client.check_user_permissions(\n-                \"user_123\", \n-                [\"read\", \"write\"], \n-                \"auth_token\"\n+                \"user_123\", [\"read\", \"write\"], \"auth_token\"\n             )\n-            \n+\n             assert result is True\n-    \n+\n     @pytest.mark.asyncio\n     async def test_check_user_permissions_failure(self):\n         \"\"\"Test failed user permission check\"\"\"\n         client = IdentityServiceClient()\n-        \n-        user_data = {\n-            \"permissions\": [\"read\"]\n-        }\n-        \n-        with patch.object(client, 'validate_token') as mock_validate:\n+\n+        user_data = {\"permissions\": [\"read\"]}\n+\n+        with patch.object(client, \"validate_token\") as mock_validate:\n             mock_validate.return_value = user_data\n-            \n+\n             result = await client.check_user_permissions(\n-                \"user_123\", \n-                [\"read\", \"admin\"], \n-                \"auth_token\"\n+                \"user_123\", [\"read\", \"admin\"], \"auth_token\"\n             )\n-            \n+\n             assert result is False\n-    \n+\n     @pytest.mark.asyncio\n     async def test_invalidate_user_cache(self):\n         \"\"\"Test invalidating user cache\"\"\"\n         client = IdentityServiceClient()\n-        \n-        with patch('identity_client.cache_manager') as mock_cache:\n+\n+        with patch(\"identity_client.cache_manager\") as mock_cache:\n             await client.invalidate_user_cache(\"user_123\")\n-            \n+\n             # Should delete specific keys and clear token pattern\n-            expected_calls = [\n-                (\"profile:user_123\",),\n-                (\"contact:user_123\",)\n-            ]\n-            \n+            expected_calls = [(\"profile:user_123\",), (\"contact:user_123\",)]\n+\n             for call in expected_calls:\n                 mock_cache.delete.assert_any_call(*call)\n-            \n+\n             mock_cache.clear_pattern.assert_called_with(\"token:*\")\n-    \n+\n     @pytest.mark.asyncio\n     async def test_health_check_success(self):\n         \"\"\"Test successful health check\"\"\"\n         client = IdentityServiceClient()\n-        \n-        with patch.object(client, '_make_request') as mock_request:\n+\n+        with patch.object(client, \"_make_request\") as mock_request:\n             mock_request.return_value = {\"status\": \"healthy\"}\n-            \n+\n             result = await client.health_check()\n-            \n+\n             assert result is True\n             mock_request.assert_called_with(\"GET\", \"/health\")\n-    \n+\n     @pytest.mark.asyncio\n     async def test_health_check_failure(self):\n         \"\"\"Test failed health check\"\"\"\n         client = IdentityServiceClient()\n-        \n-        with patch.object(client, '_make_request') as mock_request:\n+\n+        with patch.object(client, \"_make_request\") as mock_request:\n             mock_request.side_effect = IdentityServiceError(\"Service unavailable\")\n-            \n+\n             result = await client.health_check()\n-            \n+\n             assert result is False\n+\n \n class TestFastAPIDependencies:\n     \"\"\"Test FastAPI dependencies\"\"\"\n-    \n+\n     @pytest.mark.asyncio\n     async def test_get_current_user_success(self):\n         \"\"\"Test successful current user retrieval\"\"\"\n         mock_token = MagicMock()\n         mock_token.credentials = \"valid.jwt.token\"\n-        \n+\n         user_data = {\n             \"user_id\": \"user_123\",\n             \"email\": \"test@example.com\",\n-            \"roles\": [\"user\"]\n-        }\n-        \n-        with patch('identity_client.identity_client') as mock_client:\n+            \"roles\": [\"user\"],\n+        }\n+\n+        with patch(\"identity_client.identity_client\") as mock_client:\n             mock_client.validate_token.return_value = user_data\n-            \n+\n             result = await get_current_user(mock_token)\n-            \n+\n             assert result == user_data\n             mock_client.validate_token.assert_called_with(\"valid.jwt.token\")\n-    \n+\n     @pytest.mark.asyncio\n     async def test_get_current_user_invalid_token(self):\n         \"\"\"Test current user retrieval with invalid token\"\"\"\n         mock_token = MagicMock()\n         mock_token.credentials = \"invalid.jwt.token\"\n-        \n-        with patch('identity_client.identity_client') as mock_client:\n-            mock_client.validate_token.side_effect = IdentityServiceError(\"Invalid token\")\n-            \n+\n+        with patch(\"identity_client.identity_client\") as mock_client:\n+            mock_client.validate_token.side_effect = IdentityServiceError(\n+                \"Invalid token\"\n+            )\n+\n             with pytest.raises(HTTPException) as exc_info:\n                 await get_current_user(mock_token)\n-            \n+\n             assert exc_info.value.status_code == 401\n             assert \"Invalid token\" in str(exc_info.value.detail)\n-    \n+\n     def test_require_permissions_success(self):\n         \"\"\"Test successful permission requirement\"\"\"\n         current_user = {\n             \"user_id\": \"user_123\",\n-            \"permissions\": [\"read\", \"write\", \"admin\"]\n-        }\n-        \n+            \"permissions\": [\"read\", \"write\", \"admin\"],\n+        }\n+\n         permission_checker = require_permissions([\"read\", \"write\"])\n         result = permission_checker(current_user)\n-        \n+\n         assert result == current_user\n-    \n+\n     def test_require_permissions_failure(self):\n         \"\"\"Test failed permission requirement\"\"\"\n-        current_user = {\n-            \"user_id\": \"user_123\",\n-            \"permissions\": [\"read\"]\n-        }\n-        \n+        current_user = {\"user_id\": \"user_123\", \"permissions\": [\"read\"]}\n+\n         permission_checker = require_permissions([\"read\", \"admin\"])\n-        \n+\n         with pytest.raises(HTTPException) as exc_info:\n             permission_checker(current_user)\n-        \n+\n         assert exc_info.value.status_code == 403\n         assert \"Missing required permissions\" in str(exc_info.value.detail)\n-    \n+\n     def test_require_roles_success(self):\n         \"\"\"Test successful role requirement\"\"\"\n-        current_user = {\n-            \"user_id\": \"user_123\",\n-            \"roles\": [\"user\", \"admin\"]\n-        }\n-        \n+        current_user = {\"user_id\": \"user_123\", \"roles\": [\"user\", \"admin\"]}\n+\n         role_checker = require_roles([\"admin\", \"moderator\"])  # User has admin\n         result = role_checker(current_user)\n-        \n+\n         assert result == current_user\n-    \n+\n     def test_require_roles_failure(self):\n         \"\"\"Test failed role requirement\"\"\"\n-        current_user = {\n-            \"user_id\": \"user_123\",\n-            \"roles\": [\"user\"]\n-        }\n-        \n+        current_user = {\"user_id\": \"user_123\", \"roles\": [\"user\"]}\n+\n         role_checker = require_roles([\"admin\", \"moderator\"])\n-        \n+\n         with pytest.raises(HTTPException) as exc_info:\n             role_checker(current_user)\n-        \n+\n         assert exc_info.value.status_code == 403\n         assert \"Missing required roles\" in str(exc_info.value.detail)\n \n+\n class TestUserContactResolver:\n     \"\"\"Test UserContactResolver functionality\"\"\"\n-    \n+\n     def test_init(self):\n         \"\"\"Test UserContactResolver initialization\"\"\"\n         mock_client = MagicMock()\n         resolver = UserContactResolver(mock_client)\n-        \n+\n         assert resolver.identity_client == mock_client\n-    \n+\n     @pytest.mark.asyncio\n     async def test_get_email_address_success(self):\n         \"\"\"Test successful email address retrieval\"\"\"\n         mock_client = AsyncMock()\n         mock_client.get_user_contact_info.return_value = {\n             \"email\": \"test@example.com\",\n-            \"phone\": \"+1234567890\"\n-        }\n-        \n+            \"phone\": \"+1234567890\",\n+        }\n+\n         resolver = UserContactResolver(mock_client)\n         result = await resolver.get_email_address(\"user_123\", \"auth_token\")\n-        \n+\n         assert result == \"test@example.com\"\n         mock_client.get_user_contact_info.assert_called_with(\"user_123\", \"auth_token\")\n-    \n+\n     @pytest.mark.asyncio\n     async def test_get_email_address_failure(self):\n         \"\"\"Test email address retrieval failure\"\"\"\n         mock_client = AsyncMock()\n         mock_client.get_user_contact_info.side_effect = Exception(\"Service error\")\n-        \n+\n         resolver = UserContactResolver(mock_client)\n         result = await resolver.get_email_address(\"user_123\", \"auth_token\")\n-        \n+\n         assert result is None\n-    \n+\n     @pytest.mark.asyncio\n     async def test_get_phone_number(self):\n         \"\"\"Test phone number retrieval\"\"\"\n         mock_client = AsyncMock()\n-        mock_client.get_user_contact_info.return_value = {\n-            \"phone\": \"+1234567890\"\n-        }\n-        \n+        mock_client.get_user_contact_info.return_value = {\"phone\": \"+1234567890\"}\n+\n         resolver = UserContactResolver(mock_client)\n         result = await resolver.get_phone_number(\"user_123\", \"auth_token\")\n-        \n+\n         assert result == \"+1234567890\"\n-    \n+\n     @pytest.mark.asyncio\n     async def test_get_push_tokens(self):\n         \"\"\"Test push tokens retrieval\"\"\"\n         mock_client = AsyncMock()\n         mock_client.get_user_contact_info.return_value = {\n             \"push_tokens\": [\"token1\", \"token2\", \"token3\"]\n         }\n-        \n+\n         resolver = UserContactResolver(mock_client)\n         result = await resolver.get_push_tokens(\"user_123\", \"auth_token\")\n-        \n+\n         assert result == [\"token1\", \"token2\", \"token3\"]\n-    \n+\n     @pytest.mark.asyncio\n     async def test_resolve_recipients_email(self):\n         \"\"\"Test resolving email recipients\"\"\"\n         mock_client = AsyncMock()\n         resolver = UserContactResolver(mock_client)\n-        \n+\n         # Mock email addresses for multiple users\n         def mock_get_contact_info(user_id, auth_token):\n             contacts = {\n                 \"user_1\": {\"email\": \"user1@example.com\"},\n                 \"user_2\": {\"email\": \"user2@example.com\"},\n-                \"user_3\": {\"email\": None}  # No email\n+                \"user_3\": {\"email\": None},  # No email\n             }\n             return contacts.get(user_id, {})\n-        \n+\n         mock_client.get_user_contact_info.side_effect = mock_get_contact_info\n-        \n+\n         result = await resolver.resolve_recipients(\n-            [\"user_1\", \"user_2\", \"user_3\"], \n-            \"email\", \n-            \"auth_token\"\n+            [\"user_1\", \"user_2\", \"user_3\"], \"email\", \"auth_token\"\n         )\n-        \n+\n         expected = {\n             \"user_1\": \"user1@example.com\",\n-            \"user_2\": \"user2@example.com\"\n+            \"user_2\": \"user2@example.com\",\n             # user_3 should be excluded due to no email\n         }\n-        \n+\n         assert result == expected\n-    \n+\n     @pytest.mark.asyncio\n     async def test_resolve_recipients_sms(self):\n         \"\"\"Test resolving SMS recipients\"\"\"\n         mock_client = AsyncMock()\n         resolver = UserContactResolver(mock_client)\n-        \n+\n         def mock_get_contact_info(user_id, auth_token):\n             contacts = {\n                 \"user_1\": {\"phone\": \"+1234567890\"},\n-                \"user_2\": {\"phone\": \"+0987654321\"}\n+                \"user_2\": {\"phone\": \"+0987654321\"},\n             }\n             return contacts.get(user_id, {})\n-        \n+\n         mock_client.get_user_contact_info.side_effect = mock_get_contact_info\n-        \n+\n         result = await resolver.resolve_recipients(\n-            [\"user_1\", \"user_2\"], \n-            \"sms\", \n-            \"auth_token\"\n+            [\"user_1\", \"user_2\"], \"sms\", \"auth_token\"\n         )\n-        \n-        expected = {\n-            \"user_1\": \"+1234567890\",\n-            \"user_2\": \"+0987654321\"\n-        }\n-        \n+\n+        expected = {\"user_1\": \"+1234567890\", \"user_2\": \"+0987654321\"}\n+\n         assert result == expected\n-    \n+\n     @pytest.mark.asyncio\n     async def test_resolve_recipients_in_app(self):\n         \"\"\"Test resolving in-app recipients\"\"\"\n         mock_client = AsyncMock()\n         resolver = UserContactResolver(mock_client)\n-        \n+\n         # For in-app notifications, should return user IDs as contacts\n         result = await resolver.resolve_recipients(\n-            [\"user_1\", \"user_2\"], \n-            \"in_app\", \n-            \"auth_token\"\n+            [\"user_1\", \"user_2\"], \"in_app\", \"auth_token\"\n         )\n-        \n-        expected = {\n-            \"user_1\": \"user_1\",\n-            \"user_2\": \"user_2\"\n-        }\n-        \n+\n+        expected = {\"user_1\": \"user_1\", \"user_2\": \"user_2\"}\n+\n         assert result == expected\n         # Should not call get_user_contact_info for in-app\n-        mock_client.get_user_contact_info.assert_not_called()\n\\ No newline at end of file\n+        mock_client.get_user_contact_info.assert_not_called()\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/unit/test_models.py\t2025-09-09 18:07:30.876057+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/unit/test_models.py\t2025-09-10 11:37:03.144121+00:00\n@@ -8,185 +8,192 @@\n from datetime import datetime, timedelta\n from sqlalchemy.ext.asyncio import AsyncSession\n from sqlalchemy.exc import IntegrityError\n \n from models import (\n-    NotificationCategory, NotificationTemplate, Notification,\n-    NotificationChannel, NotificationStatus, NotificationPriority\n+    NotificationCategory,\n+    NotificationTemplate,\n+    Notification,\n+    NotificationChannel,\n+    NotificationStatus,\n+    NotificationPriority,\n )\n+\n \n @pytest.mark.unit\n @pytest.mark.asyncio\n class TestNotificationCategory:\n     \"\"\"Unit tests for NotificationCategory model\"\"\"\n-    \n+\n     async def test_create_notification_category(self, db_session: AsyncSession):\n         \"\"\"Test creating a notification category\"\"\"\n         category_data = {\n             \"name\": \"test_category\",\n             \"description\": \"Test category for notifications\",\n             \"default_enabled\": True,\n-            \"color\": \"#FF0000\"\n+            \"color\": \"#FF0000\",\n         }\n-        \n+\n         category = NotificationCategory(**category_data)\n         db_session.add(category)\n         await db_session.commit()\n         await db_session.refresh(category)\n-        \n+\n         assert category.id is not None\n         assert category.name == \"test_category\"\n         assert category.description == \"Test category for notifications\"\n         assert category.default_enabled is True\n         assert category.color == \"#FF0000\"\n         assert category.created_at is not None\n         assert isinstance(category.created_at, datetime)\n         assert category.updated_at is not None\n-    \n+\n     async def test_category_name_uniqueness(self, db_session: AsyncSession):\n         \"\"\"Test that category names must be unique\"\"\"\n         # Create first category\n         category1 = NotificationCategory(\n-            name=\"unique_category\",\n-            description=\"First category\"\n+            name=\"unique_category\", description=\"First category\"\n         )\n         db_session.add(category1)\n         await db_session.commit()\n-        \n+\n         # Try to create second category with same name\n         category2 = NotificationCategory(\n-            name=\"unique_category\",\n-            description=\"Second category\"\n+            name=\"unique_category\", description=\"Second category\"\n         )\n         db_session.add(category2)\n-        \n+\n         with pytest.raises(IntegrityError):\n             await db_session.commit()\n-    \n+\n     async def test_category_default_values(self, db_session: AsyncSession):\n         \"\"\"Test default values for category\"\"\"\n         category = NotificationCategory(\n-            name=\"default_test\",\n-            description=\"Test default values\"\n+            name=\"default_test\", description=\"Test default values\"\n         )\n         db_session.add(category)\n         await db_session.commit()\n         await db_session.refresh(category)\n-        \n+\n         assert category.default_enabled is True  # Default should be True\n         assert category.color is None  # Default should be None\n \n \n @pytest.mark.unit\n @pytest.mark.asyncio\n class TestNotificationTemplate:\n     \"\"\"Unit tests for NotificationTemplate model\"\"\"\n-    \n+\n     @pytest.fixture\n     async def test_category(self, db_session: AsyncSession):\n         \"\"\"Create a test category for templates\"\"\"\n         category = NotificationCategory(\n-            name=\"template_test_category\",\n-            description=\"Category for template tests\"\n+            name=\"template_test_category\", description=\"Category for template tests\"\n         )\n         db_session.add(category)\n         await db_session.commit()\n         await db_session.refresh(category)\n         return category\n-    \n-    async def test_create_notification_template(self, db_session: AsyncSession, test_category):\n+\n+    async def test_create_notification_template(\n+        self, db_session: AsyncSession, test_category\n+    ):\n         \"\"\"Test creating a notification template\"\"\"\n         template_data = {\n             \"name\": \"welcome_email\",\n             \"category_id\": test_category.id,\n             \"channel\": NotificationChannel.EMAIL,\n             \"language\": \"en\",\n             \"subject\": \"Welcome {{name}}!\",\n             \"content\": \"Hello {{name}}, welcome to our platform!\",\n-            \"variables\": {\"name\": \"string\", \"email\": \"string\"}\n+            \"variables\": {\"name\": \"string\", \"email\": \"string\"},\n         }\n-        \n+\n         template = NotificationTemplate(**template_data)\n         db_session.add(template)\n         await db_session.commit()\n         await db_session.refresh(template)\n-        \n+\n         assert template.id is not None\n         assert template.name == \"welcome_email\"\n         assert template.category_id == test_category.id\n         assert template.channel == NotificationChannel.EMAIL\n         assert template.language == \"en\"\n         assert template.subject == \"Welcome {{name}}!\"\n         assert template.content == \"Hello {{name}}, welcome to our platform!\"\n         assert template.variables == {\"name\": \"string\", \"email\": \"string\"}\n         assert template.created_at is not None\n-    \n-    async def test_template_category_relationship(self, db_session: AsyncSession, test_category):\n+\n+    async def test_template_category_relationship(\n+        self, db_session: AsyncSession, test_category\n+    ):\n         \"\"\"Test template-category relationship\"\"\"\n         template = NotificationTemplate(\n             name=\"relationship_test\",\n             category_id=test_category.id,\n             channel=NotificationChannel.SMS,\n             language=\"en\",\n-            content=\"Test message\"\n+            content=\"Test message\",\n         )\n         db_session.add(template)\n         await db_session.commit()\n         await db_session.refresh(template)\n-        \n+\n         # Test relationship\n         assert template.category is not None\n         assert template.category.id == test_category.id\n         assert template.category.name == \"template_test_category\"\n-    \n-    async def test_template_channel_validation(self, db_session: AsyncSession, test_category):\n+\n+    async def test_template_channel_validation(\n+        self, db_session: AsyncSession, test_category\n+    ):\n         \"\"\"Test that template channel is properly validated\"\"\"\n         template = NotificationTemplate(\n             name=\"channel_test\",\n             category_id=test_category.id,\n             channel=NotificationChannel.PUSH,\n             language=\"en\",\n-            content=\"Test notification\"\n+            content=\"Test notification\",\n         )\n         db_session.add(template)\n         await db_session.commit()\n         await db_session.refresh(template)\n-        \n+\n         assert template.channel == NotificationChannel.PUSH\n         assert isinstance(template.channel, NotificationChannel)\n \n \n @pytest.mark.unit\n @pytest.mark.asyncio\n class TestNotification:\n     \"\"\"Unit tests for Notification model\"\"\"\n-    \n+\n     @pytest.fixture\n     async def test_setup(self, db_session: AsyncSession):\n         \"\"\"Setup test category and template\"\"\"\n         category = NotificationCategory(\n             name=\"notification_test_category\",\n-            description=\"Category for notification tests\"\n+            description=\"Category for notification tests\",\n         )\n         db_session.add(category)\n         await db_session.commit()\n         await db_session.refresh(category)\n-        \n+\n         template = NotificationTemplate(\n             name=\"test_template\",\n             category_id=category.id,\n             channel=NotificationChannel.EMAIL,\n             language=\"en\",\n             subject=\"Test Subject\",\n-            content=\"Test content with {{name}}\"\n+            content=\"Test content with {{name}}\",\n         )\n         db_session.add(template)\n         await db_session.commit()\n         await db_session.refresh(template)\n-        \n+\n         return {\"category\": category, \"template\": template}\n-    \n+\n     async def test_create_notification(self, db_session: AsyncSession, test_setup):\n         \"\"\"Test creating a notification\"\"\"\n         notification_data = {\n             \"user_id\": uuid.uuid4(),\n             \"category_id\": test_setup[\"category\"].id,\n@@ -195,18 +202,18 @@\n             \"subject\": \"Welcome John!\",\n             \"content\": \"Hello John, welcome to our platform!\",\n             \"recipient\": \"john@example.com\",\n             \"data\": {\"name\": \"John\", \"action\": \"welcome\"},\n             \"priority\": NotificationPriority.NORMAL,\n-            \"status\": NotificationStatus.PENDING\n+            \"status\": NotificationStatus.PENDING,\n         }\n-        \n+\n         notification = Notification(**notification_data)\n         db_session.add(notification)\n         await db_session.commit()\n         await db_session.refresh(notification)\n-        \n+\n         assert notification.id is not None\n         assert notification.user_id == notification_data[\"user_id\"]\n         assert notification.category_id == test_setup[\"category\"].id\n         assert notification.template_id == test_setup[\"template\"].id\n         assert notification.channel == NotificationChannel.EMAIL\n@@ -215,186 +222,195 @@\n         assert notification.recipient == \"john@example.com\"\n         assert notification.data == {\"name\": \"John\", \"action\": \"welcome\"}\n         assert notification.priority == NotificationPriority.NORMAL\n         assert notification.status == NotificationStatus.PENDING\n         assert notification.created_at is not None\n-    \n-    async def test_notification_relationships(self, db_session: AsyncSession, test_setup):\n+\n+    async def test_notification_relationships(\n+        self, db_session: AsyncSession, test_setup\n+    ):\n         \"\"\"Test notification relationships\"\"\"\n         notification = Notification(\n             user_id=uuid.uuid4(),\n             category_id=test_setup[\"category\"].id,\n             template_id=test_setup[\"template\"].id,\n             channel=NotificationChannel.EMAIL,\n             subject=\"Relationship Test\",\n             content=\"Test content\",\n             recipient=\"test@example.com\",\n-            status=NotificationStatus.PENDING\n+            status=NotificationStatus.PENDING,\n         )\n         db_session.add(notification)\n         await db_session.commit()\n         await db_session.refresh(notification)\n-        \n+\n         # Test category relationship\n         assert notification.category is not None\n         assert notification.category.id == test_setup[\"category\"].id\n         assert notification.category.name == \"notification_test_category\"\n-        \n+\n         # Test template relationship\n         assert notification.template is not None\n         assert notification.template.id == test_setup[\"template\"].id\n         assert notification.template.name == \"test_template\"\n-    \n-    async def test_notification_status_transitions(self, db_session: AsyncSession, test_setup):\n+\n+    async def test_notification_status_transitions(\n+        self, db_session: AsyncSession, test_setup\n+    ):\n         \"\"\"Test notification status transitions\"\"\"\n         notification = Notification(\n             user_id=uuid.uuid4(),\n             category_id=test_setup[\"category\"].id,\n             template_id=test_setup[\"template\"].id,\n             channel=NotificationChannel.EMAIL,\n             subject=\"Status Test\",\n             content=\"Test content\",\n             recipient=\"test@example.com\",\n-            status=NotificationStatus.PENDING\n+            status=NotificationStatus.PENDING,\n         )\n         db_session.add(notification)\n         await db_session.commit()\n         await db_session.refresh(notification)\n-        \n+\n         # Test initial status\n         assert notification.status == NotificationStatus.PENDING\n         assert notification.sent_at is None\n-        \n+\n         # Update to sent\n         notification.status = NotificationStatus.SENT\n         notification.sent_at = datetime.utcnow()\n         await db_session.commit()\n         await db_session.refresh(notification)\n-        \n+\n         assert notification.status == NotificationStatus.SENT\n         assert notification.sent_at is not None\n         assert isinstance(notification.sent_at, datetime)\n-        \n+\n         # Update to failed\n         notification.status = NotificationStatus.FAILED\n         notification.error_message = \"SMTP server unavailable\"\n         await db_session.commit()\n         await db_session.refresh(notification)\n-        \n+\n         assert notification.status == NotificationStatus.FAILED\n         assert notification.error_message == \"SMTP server unavailable\"\n-    \n-    async def test_notification_priority_levels(self, db_session: AsyncSession, test_setup):\n+\n+    async def test_notification_priority_levels(\n+        self, db_session: AsyncSession, test_setup\n+    ):\n         \"\"\"Test different notification priority levels\"\"\"\n         priorities = [\n             NotificationPriority.LOW,\n             NotificationPriority.NORMAL,\n             NotificationPriority.HIGH,\n-            NotificationPriority.URGENT\n+            NotificationPriority.URGENT,\n         ]\n-        \n+\n         for priority in priorities:\n             notification = Notification(\n                 user_id=uuid.uuid4(),\n                 category_id=test_setup[\"category\"].id,\n                 template_id=test_setup[\"template\"].id,\n                 channel=NotificationChannel.EMAIL,\n                 subject=f\"Priority {priority.value} Test\",\n                 content=\"Test content\",\n                 recipient=\"test@example.com\",\n                 priority=priority,\n-                status=NotificationStatus.PENDING\n+                status=NotificationStatus.PENDING,\n             )\n             db_session.add(notification)\n-        \n-        await db_session.commit()\n-        \n+\n+        await db_session.commit()\n+\n         # Verify all notifications were created with correct priorities\n         from sqlalchemy import select\n+\n         result = await db_session.execute(\n             select(Notification).where(Notification.subject.like(\"Priority % Test\"))\n         )\n         notifications = result.scalars().all()\n-        \n+\n         assert len(notifications) == 4\n         created_priorities = [n.priority for n in notifications]\n         assert set(created_priorities) == set(priorities)\n-    \n-    async def test_notification_channel_validation(self, db_session: AsyncSession, test_setup):\n+\n+    async def test_notification_channel_validation(\n+        self, db_session: AsyncSession, test_setup\n+    ):\n         \"\"\"Test notification channel validation\"\"\"\n         channels = [\n             NotificationChannel.EMAIL,\n             NotificationChannel.SMS,\n             NotificationChannel.PUSH,\n-            NotificationChannel.IN_APP\n+            NotificationChannel.IN_APP,\n         ]\n-        \n+\n         for channel in channels:\n             notification = Notification(\n                 user_id=uuid.uuid4(),\n                 category_id=test_setup[\"category\"].id,\n                 template_id=test_setup[\"template\"].id,\n                 channel=channel,\n                 subject=f\"Channel {channel.value} Test\",\n                 content=\"Test content\",\n                 recipient=\"test@example.com\",\n-                status=NotificationStatus.PENDING\n+                status=NotificationStatus.PENDING,\n             )\n             db_session.add(notification)\n-        \n-        await db_session.commit()\n-        \n+\n+        await db_session.commit()\n+\n         # Verify all notifications were created with correct channels\n         from sqlalchemy import select\n+\n         result = await db_session.execute(\n             select(Notification).where(Notification.subject.like(\"Channel % Test\"))\n         )\n         notifications = result.scalars().all()\n-        \n+\n         assert len(notifications) == 4\n         created_channels = [n.channel for n in notifications]\n         assert set(created_channels) == set(channels)\n-    \n-    async def test_notification_data_json_field(self, db_session: AsyncSession, test_setup):\n+\n+    async def test_notification_data_json_field(\n+        self, db_session: AsyncSession, test_setup\n+    ):\n         \"\"\"Test notification data JSON field storage and retrieval\"\"\"\n         complex_data = {\n             \"user_info\": {\n                 \"name\": \"John Doe\",\n                 \"email\": \"john@example.com\",\n-                \"preferences\": {\n-                    \"language\": \"en\",\n-                    \"timezone\": \"UTC\"\n-                }\n+                \"preferences\": {\"language\": \"en\", \"timezone\": \"UTC\"},\n             },\n             \"action_data\": {\n                 \"action_type\": \"purchase\",\n                 \"amount\": 99.99,\n                 \"currency\": \"USD\",\n-                \"items\": [\"item1\", \"item2\", \"item3\"]\n+                \"items\": [\"item1\", \"item2\", \"item3\"],\n             },\n             \"metadata\": {\n                 \"source\": \"web_app\",\n                 \"version\": \"1.2.3\",\n-                \"timestamp\": \"2024-01-01T00:00:00Z\"\n-            }\n+                \"timestamp\": \"2024-01-01T00:00:00Z\",\n+            },\n         }\n-        \n+\n         notification = Notification(\n             user_id=uuid.uuid4(),\n             category_id=test_setup[\"category\"].id,\n             template_id=test_setup[\"template\"].id,\n             channel=NotificationChannel.EMAIL,\n             subject=\"JSON Data Test\",\n             content=\"Test content\",\n             recipient=\"test@example.com\",\n             data=complex_data,\n-            status=NotificationStatus.PENDING\n+            status=NotificationStatus.PENDING,\n         )\n         db_session.add(notification)\n         await db_session.commit()\n         await db_session.refresh(notification)\n-        \n+\n         # Verify JSON data is properly stored and retrieved\n         assert notification.data == complex_data\n         assert notification.data[\"user_info\"][\"name\"] == \"John Doe\"\n         assert notification.data[\"action_data\"][\"amount\"] == 99.99\n         assert notification.data[\"metadata\"][\"source\"] == \"web_app\"\n@@ -402,26 +418,26 @@\n \n \n @pytest.mark.unit\n class TestModelEnums:\n     \"\"\"Test model enum values\"\"\"\n-    \n+\n     def test_notification_channel_values(self):\n         \"\"\"Test NotificationChannel enum values\"\"\"\n         assert NotificationChannel.EMAIL.value == \"email\"\n         assert NotificationChannel.SMS.value == \"sms\"\n         assert NotificationChannel.PUSH.value == \"push\"\n         assert NotificationChannel.IN_APP.value == \"in_app\"\n-    \n+\n     def test_notification_status_values(self):\n         \"\"\"Test NotificationStatus enum values\"\"\"\n         assert NotificationStatus.PENDING.value == \"pending\"\n         assert NotificationStatus.SENT.value == \"sent\"\n         assert NotificationStatus.DELIVERED.value == \"delivered\"\n         assert NotificationStatus.FAILED.value == \"failed\"\n         assert NotificationStatus.READ.value == \"read\"\n-    \n+\n     def test_notification_priority_values(self):\n         \"\"\"Test NotificationPriority enum values\"\"\"\n         assert NotificationPriority.LOW.value == \"low\"\n         assert NotificationPriority.NORMAL.value == \"normal\"\n         assert NotificationPriority.HIGH.value == \"high\"\n@@ -430,74 +446,70 @@\n \n @pytest.mark.unit\n @pytest.mark.asyncio\n class TestModelEdgeCases:\n     \"\"\"Test edge cases and error conditions\"\"\"\n-    \n+\n     async def test_notification_without_template(self, db_session: AsyncSession):\n         \"\"\"Test creating notification without template\"\"\"\n         category = NotificationCategory(\n-            name=\"no_template_category\",\n-            description=\"Category for no template test\"\n+            name=\"no_template_category\", description=\"Category for no template test\"\n         )\n         db_session.add(category)\n         await db_session.commit()\n         await db_session.refresh(category)\n-        \n+\n         notification = Notification(\n             user_id=uuid.uuid4(),\n             category_id=category.id,\n             template_id=None,  # No template\n             channel=NotificationChannel.EMAIL,\n             subject=\"No Template Test\",\n             content=\"Direct content without template\",\n             recipient=\"test@example.com\",\n-            status=NotificationStatus.PENDING\n+            status=NotificationStatus.PENDING,\n         )\n         db_session.add(notification)\n         await db_session.commit()\n         await db_session.refresh(notification)\n-        \n+\n         assert notification.template_id is None\n         assert notification.template is None\n         assert notification.subject == \"No Template Test\"\n         assert notification.content == \"Direct content without template\"\n-    \n+\n     async def test_notification_large_data_field(self, db_session: AsyncSession):\n         \"\"\"Test notification with large data field\"\"\"\n         category = NotificationCategory(\n-            name=\"large_data_category\",\n-            description=\"Category for large data test\"\n+            name=\"large_data_category\", description=\"Category for large data test\"\n         )\n         db_session.add(category)\n         await db_session.commit()\n         await db_session.refresh(category)\n-        \n+\n         # Create large data object\n         large_data = {\n             \"large_array\": [f\"item_{i}\" for i in range(1000)],\n-            \"nested_object\": {\n-                f\"key_{i}\": f\"value_{i}\" for i in range(100)\n-            },\n-            \"description\": \"A\" * 1000  # 1000 character string\n+            \"nested_object\": {f\"key_{i}\": f\"value_{i}\" for i in range(100)},\n+            \"description\": \"A\" * 1000,  # 1000 character string\n         }\n-        \n+\n         notification = Notification(\n             user_id=uuid.uuid4(),\n             category_id=category.id,\n             template_id=None,\n             channel=NotificationChannel.EMAIL,\n             subject=\"Large Data Test\",\n             content=\"Test with large data\",\n             recipient=\"test@example.com\",\n             data=large_data,\n-            status=NotificationStatus.PENDING\n+            status=NotificationStatus.PENDING,\n         )\n         db_session.add(notification)\n         await db_session.commit()\n         await db_session.refresh(notification)\n-        \n+\n         # Verify large data is properly stored\n         assert len(notification.data[\"large_array\"]) == 1000\n         assert len(notification.data[\"nested_object\"]) == 100\n         assert len(notification.data[\"description\"]) == 1000\n-        assert notification.data[\"large_array\"][999] == \"item_999\"\n\\ No newline at end of file\n+        assert notification.data[\"large_array\"][999] == \"item_999\"\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/unit/test_utils.py\t2025-09-09 18:10:37.435332+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/unit/test_utils.py\t2025-09-10 11:37:03.170494+00:00\n@@ -10,211 +10,245 @@\n import uuid\n \n # Import utility modules (adjust based on actual structure)\n try:\n     from utils.validators import (\n-        validate_email, validate_phone_number, validate_push_token,\n-        validate_notification_data\n+        validate_email,\n+        validate_phone_number,\n+        validate_push_token,\n+        validate_notification_data,\n     )\n     from utils.formatters import (\n-        format_notification_content, format_phone_number,\n-        sanitize_html_content, truncate_content\n+        format_notification_content,\n+        format_phone_number,\n+        sanitize_html_content,\n+        truncate_content,\n     )\n     from utils.helpers import (\n-        generate_notification_id, parse_template_variables,\n-        calculate_retry_delay, is_valid_timezone\n+        generate_notification_id,\n+        parse_template_variables,\n+        calculate_retry_delay,\n+        is_valid_timezone,\n     )\n except ImportError:\n     # Mock utilities if they don't exist yet\n-    def validate_email(email): return \"@\" in email\n-    def validate_phone_number(phone): return phone.startswith(\"+\")\n-    def validate_push_token(token): return len(token) > 10\n-    def validate_notification_data(data): return isinstance(data, dict)\n-    def format_notification_content(content, data): return content.format(**data)\n-    def format_phone_number(phone): return phone\n-    def sanitize_html_content(content): return content\n-    def truncate_content(content, length=100): return content[:length]\n-    def generate_notification_id(): return str(uuid.uuid4())\n-    def parse_template_variables(template): return []\n-    def calculate_retry_delay(attempt): return attempt * 60\n-    def is_valid_timezone(tz): return tz in [\"UTC\", \"EST\", \"PST\"]\n+    def validate_email(email):\n+        return \"@\" in email\n+\n+    def validate_phone_number(phone):\n+        return phone.startswith(\"+\")\n+\n+    def validate_push_token(token):\n+        return len(token) > 10\n+\n+    def validate_notification_data(data):\n+        return isinstance(data, dict)\n+\n+    def format_notification_content(content, data):\n+        return content.format(**data)\n+\n+    def format_phone_number(phone):\n+        return phone\n+\n+    def sanitize_html_content(content):\n+        return content\n+\n+    def truncate_content(content, length=100):\n+        return content[:length]\n+\n+    def generate_notification_id():\n+        return str(uuid.uuid4())\n+\n+    def parse_template_variables(template):\n+        return []\n+\n+    def calculate_retry_delay(attempt):\n+        return attempt * 60\n+\n+    def is_valid_timezone(tz):\n+        return tz in [\"UTC\", \"EST\", \"PST\"]\n+\n \n @pytest.mark.unit\n class TestValidators:\n     \"\"\"Test validation utility functions\"\"\"\n-    \n+\n     def test_validate_email_valid_addresses(self):\n         \"\"\"Test email validation with valid addresses\"\"\"\n         valid_emails = [\n             \"user@example.com\",\n             \"test.email@domain.org\",\n             \"user+tag@example.co.uk\",\n             \"firstname.lastname@company.com\",\n-            \"user123@test-domain.com\"\n-        ]\n-        \n+            \"user123@test-domain.com\",\n+        ]\n+\n         for email in valid_emails:\n             assert validate_email(email) is True, f\"Valid email {email} should pass\"\n-    \n+\n     def test_validate_email_invalid_addresses(self):\n         \"\"\"Test email validation with invalid addresses\"\"\"\n         invalid_emails = [\n             \"invalid-email\",\n             \"user@\",\n             \"@domain.com\",\n             \"user space@domain.com\",\n             \"user@domain\",\n             \"\",\n             None,\n-            \"user@@domain.com\"\n-        ]\n-        \n+            \"user@@domain.com\",\n+        ]\n+\n         for email in invalid_emails:\n             assert validate_email(email) is False, f\"Invalid email {email} should fail\"\n-    \n+\n     def test_validate_phone_number_valid_numbers(self):\n         \"\"\"Test phone number validation with valid numbers\"\"\"\n         valid_phones = [\n             \"+1234567890\",\n             \"+44123456789\",\n             \"+33123456789\",\n             \"+12345678901\",\n-            \"+999123456789\"\n-        ]\n-        \n+            \"+999123456789\",\n+        ]\n+\n         for phone in valid_phones:\n-            assert validate_phone_number(phone) is True, f\"Valid phone {phone} should pass\"\n-    \n+            assert (\n+                validate_phone_number(phone) is True\n+            ), f\"Valid phone {phone} should pass\"\n+\n     def test_validate_phone_number_invalid_numbers(self):\n         \"\"\"Test phone number validation with invalid numbers\"\"\"\n         invalid_phones = [\n             \"1234567890\",  # Missing +\n-            \"+123\",        # Too short\n-            \"+\",           # Just +\n-            \"abc123\",      # Contains letters\n-            \"\",            # Empty\n-            None,          # None\n-            \"+1234567890123456\"  # Too long\n-        ]\n-        \n+            \"+123\",  # Too short\n+            \"+\",  # Just +\n+            \"abc123\",  # Contains letters\n+            \"\",  # Empty\n+            None,  # None\n+            \"+1234567890123456\",  # Too long\n+        ]\n+\n         for phone in invalid_phones:\n-            assert validate_phone_number(phone) is False, f\"Invalid phone {phone} should fail\"\n-    \n+            assert (\n+                validate_phone_number(phone) is False\n+            ), f\"Invalid phone {phone} should fail\"\n+\n     def test_validate_push_token(self):\n         \"\"\"Test push token validation\"\"\"\n         valid_tokens = [\n             \"abcdef123456789012345\",\n             \"push-token-with-dashes-and-numbers-123\",\n-            \"A1B2C3D4E5F6G7H8I9J0K1L2M3N4O5P6\"\n-        ]\n-        \n+            \"A1B2C3D4E5F6G7H8I9J0K1L2M3N4O5P6\",\n+        ]\n+\n         invalid_tokens = [\n-            \"short\",       # Too short\n-            \"\",            # Empty\n-            None,          # None\n-            \"123\"          # Very short\n-        ]\n-        \n+            \"short\",  # Too short\n+            \"\",  # Empty\n+            None,  # None\n+            \"123\",  # Very short\n+        ]\n+\n         for token in valid_tokens:\n             assert validate_push_token(token) is True, f\"Valid token should pass\"\n-        \n+\n         for token in invalid_tokens:\n             assert validate_push_token(token) is False, f\"Invalid token should fail\"\n-    \n+\n     def test_validate_notification_data(self):\n         \"\"\"Test notification data validation\"\"\"\n         valid_data = [\n             {\"name\": \"John\", \"action\": \"login\"},\n             {\"user\": {\"id\": 123, \"name\": \"John\"}},\n             {},  # Empty dict is valid\n-            {\"complex\": {\"nested\": {\"data\": [1, 2, 3]}}}\n-        ]\n-        \n-        invalid_data = [\n-            None,\n-            \"string\",\n-            123,\n-            [],\n-            set()\n-        ]\n-        \n+            {\"complex\": {\"nested\": {\"data\": [1, 2, 3]}}},\n+        ]\n+\n+        invalid_data = [None, \"string\", 123, [], set()]\n+\n         for data in valid_data:\n             assert validate_notification_data(data) is True, f\"Valid data should pass\"\n-        \n+\n         for data in invalid_data:\n-            assert validate_notification_data(data) is False, f\"Invalid data should fail\"\n+            assert (\n+                validate_notification_data(data) is False\n+            ), f\"Invalid data should fail\"\n \n \n @pytest.mark.unit\n class TestFormatters:\n     \"\"\"Test formatting utility functions\"\"\"\n-    \n+\n     def test_format_notification_content_basic(self):\n         \"\"\"Test basic content formatting\"\"\"\n         content = \"Hello {name}, welcome to {platform}!\"\n         data = {\"name\": \"John\", \"platform\": \"Our Service\"}\n-        \n+\n         result = format_notification_content(content, data)\n-        \n+\n         assert result == \"Hello John, welcome to Our Service!\"\n-    \n+\n     def test_format_notification_content_missing_data(self):\n         \"\"\"Test content formatting with missing data\"\"\"\n         content = \"Hello {name}, your {action} was {status}!\"\n         data = {\"name\": \"John\", \"action\": \"login\"}  # Missing 'status'\n-        \n+\n         # Should handle gracefully (behavior depends on implementation)\n         try:\n             result = format_notification_content(content, data)\n             # If it doesn't raise exception, verify result makes sense\n             assert \"John\" in result\n             assert \"login\" in result\n         except KeyError:\n             # It's acceptable for this to raise KeyError\n             pass\n-    \n+\n     def test_format_phone_number(self):\n         \"\"\"Test phone number formatting\"\"\"\n         test_cases = [\n             (\"+1234567890\", \"+1234567890\"),  # Already formatted\n-            (\"1234567890\", \"+1234567890\"),   # Add country code\n-            (\"+44123456789\", \"+44123456789\") # International\n-        ]\n-        \n+            (\"1234567890\", \"+1234567890\"),  # Add country code\n+            (\"+44123456789\", \"+44123456789\"),  # International\n+        ]\n+\n         for input_phone, expected in test_cases:\n             result = format_phone_number(input_phone)\n             # Basic test - implementation may vary\n             assert result is not None\n             assert len(result) > 0\n-    \n+\n     def test_sanitize_html_content(self):\n         \"\"\"Test HTML content sanitization\"\"\"\n         test_cases = [\n             (\"Hello <b>world</b>!\", \"Hello world!\"),\n             (\"Click <a href='http://evil.com'>here</a>\", \"Click here\"),\n             (\"Simple text\", \"Simple text\"),\n             (\"<script>alert('xss')</script>Safe content\", \"Safe content\"),\n-            (\"\", \"\")\n-        ]\n-        \n+            (\"\", \"\"),\n+        ]\n+\n         for input_html, expected_clean in test_cases:\n             result = sanitize_html_content(input_html)\n             # Basic test - actual implementation may differ\n             assert result is not None\n             # Should not contain dangerous tags\n             assert \"<script>\" not in result\n             assert \"<a href=\" not in result or \"here\" in result\n-    \n+\n     def test_truncate_content(self):\n         \"\"\"Test content truncation\"\"\"\n         test_cases = [\n             (\"Short text\", 100, \"Short text\"),\n-            (\"This is a very long text that should be truncated\", 20, \"This is a very long\"),\n+            (\n+                \"This is a very long text that should be truncated\",\n+                20,\n+                \"This is a very long\",\n+            ),\n             (\"\", 50, \"\"),\n-            (\"Exact length\", 12, \"Exact length\")\n-        ]\n-        \n+            (\"Exact length\", 12, \"Exact length\"),\n+        ]\n+\n         for content, length, expected in test_cases:\n             result = truncate_content(content, length)\n             assert len(result) <= length\n             if len(content) <= length:\n                 assert result == content\n@@ -223,286 +257,293 @@\n \n \n @pytest.mark.unit\n class TestHelpers:\n     \"\"\"Test helper utility functions\"\"\"\n-    \n+\n     def test_generate_notification_id(self):\n         \"\"\"Test notification ID generation\"\"\"\n         # Generate multiple IDs\n         ids = [generate_notification_id() for _ in range(10)]\n-        \n+\n         # All should be unique\n         assert len(set(ids)) == 10\n-        \n+\n         # Should be valid UUID format\n         for notification_id in ids:\n             assert isinstance(notification_id, str)\n             assert len(notification_id) > 0\n             # Try to parse as UUID\n             try:\n                 uuid.UUID(notification_id)\n             except ValueError:\n                 pytest.fail(f\"Generated ID {notification_id} is not valid UUID\")\n-    \n+\n     def test_parse_template_variables(self):\n         \"\"\"Test template variable parsing\"\"\"\n         test_cases = [\n             (\"Hello {{name}}!\", [\"name\"]),\n-            (\"{{greeting}} {{name}}, your {{action}} was {{status}}.\", \n-             [\"greeting\", \"name\", \"action\", \"status\"]),\n+            (\n+                \"{{greeting}} {{name}}, your {{action}} was {{status}}.\",\n+                [\"greeting\", \"name\", \"action\", \"status\"],\n+            ),\n             (\"No variables here\", []),\n             (\"Mixed {{var1}} and {var2} and {{var3}}\", [\"var1\", \"var3\"]),\n-            (\"\", [])\n-        ]\n-        \n+            (\"\", []),\n+        ]\n+\n         for template, expected_vars in test_cases:\n             result = parse_template_variables(template)\n             # Implementation may vary, but should find template variables\n             assert isinstance(result, list)\n             if expected_vars:\n                 # Should find at least some variables\n                 assert len(result) >= 0\n-    \n+\n     def test_calculate_retry_delay(self):\n         \"\"\"Test retry delay calculation\"\"\"\n         test_cases = [\n-            (1, 60),    # First retry: 1 minute\n-            (2, 120),   # Second retry: 2 minutes\n-            (3, 180),   # Third retry: 3 minutes\n-            (5, 300),   # Fifth retry: 5 minutes\n-        ]\n-        \n+            (1, 60),  # First retry: 1 minute\n+            (2, 120),  # Second retry: 2 minutes\n+            (3, 180),  # Third retry: 3 minutes\n+            (5, 300),  # Fifth retry: 5 minutes\n+        ]\n+\n         for attempt, expected_delay in test_cases:\n             result = calculate_retry_delay(attempt)\n             assert result >= 0\n             # Should increase with attempt number\n             if attempt > 1:\n                 assert result > calculate_retry_delay(attempt - 1)\n-    \n+\n     def test_is_valid_timezone(self):\n         \"\"\"Test timezone validation\"\"\"\n         valid_timezones = [\"UTC\", \"EST\", \"PST\", \"GMT\"]\n         invalid_timezones = [\"INVALID\", \"XYZ\", \"\", None, 123]\n-        \n+\n         for tz in valid_timezones:\n             result = is_valid_timezone(tz)\n             # Should return boolean\n             assert isinstance(result, bool)\n-        \n+\n         for tz in invalid_timezones:\n             result = is_valid_timezone(tz)\n             assert isinstance(result, bool)\n \n \n @pytest.mark.unit\n class TestDataProcessingUtils:\n     \"\"\"Test data processing and transformation utilities\"\"\"\n-    \n+\n     def test_json_serialization_with_datetime(self):\n         \"\"\"Test JSON serialization with datetime objects\"\"\"\n         data = {\n             \"user_id\": str(uuid.uuid4()),\n             \"created_at\": datetime.utcnow(),\n             \"scheduled_for\": datetime.utcnow() + timedelta(hours=1),\n-            \"data\": {\"key\": \"value\"}\n+            \"data\": {\"key\": \"value\"},\n         }\n-        \n+\n         # Custom JSON encoder for datetime (if implemented)\n         try:\n             json_str = json.dumps(data, default=str)\n             parsed_data = json.loads(json_str)\n-            \n+\n             assert \"user_id\" in parsed_data\n             assert \"created_at\" in parsed_data\n             assert \"scheduled_for\" in parsed_data\n             assert parsed_data[\"data\"][\"key\"] == \"value\"\n         except TypeError:\n             # It's acceptable if datetime serialization isn't implemented\n             pass\n-    \n+\n     def test_notification_priority_sorting(self):\n         \"\"\"Test notification priority sorting utility\"\"\"\n         # Test data with different priorities\n         notifications = [\n             {\"id\": 1, \"priority\": \"low\"},\n             {\"id\": 2, \"priority\": \"urgent\"},\n             {\"id\": 3, \"priority\": \"normal\"},\n             {\"id\": 4, \"priority\": \"high\"},\n         ]\n-        \n+\n         # Define priority order\n         priority_order = {\"urgent\": 1, \"high\": 2, \"normal\": 3, \"low\": 4}\n-        \n+\n         # Sort by priority\n         sorted_notifications = sorted(\n-            notifications, \n-            key=lambda x: priority_order.get(x[\"priority\"], 999)\n+            notifications, key=lambda x: priority_order.get(x[\"priority\"], 999)\n         )\n-        \n+\n         assert sorted_notifications[0][\"priority\"] == \"urgent\"\n         assert sorted_notifications[-1][\"priority\"] == \"low\"\n-    \n+\n     def test_batch_processing_utility(self):\n         \"\"\"Test batch processing utility function\"\"\"\n+\n         def process_batch(items, batch_size=3):\n             \"\"\"Simple batch processor\"\"\"\n             batches = []\n             for i in range(0, len(items), batch_size):\n-                batches.append(items[i:i + batch_size])\n+                batches.append(items[i : i + batch_size])\n             return batches\n-        \n+\n         items = list(range(10))  # [0, 1, 2, ..., 9]\n         batches = process_batch(items, batch_size=3)\n-        \n+\n         assert len(batches) == 4  # 10 items / 3 per batch = 4 batches\n         assert batches[0] == [0, 1, 2]\n         assert batches[1] == [3, 4, 5]\n         assert batches[2] == [6, 7, 8]\n         assert batches[3] == [9]  # Last batch with remainder\n-    \n+\n     def test_content_hash_generation(self):\n         \"\"\"Test content hash generation for deduplication\"\"\"\n         import hashlib\n-        \n+\n         def generate_content_hash(content):\n             \"\"\"Generate hash for content deduplication\"\"\"\n             return hashlib.md5(content.encode()).hexdigest()\n-        \n+\n         content1 = \"This is test content\"\n         content2 = \"This is test content\"  # Same content\n         content3 = \"This is different content\"\n-        \n+\n         hash1 = generate_content_hash(content1)\n         hash2 = generate_content_hash(content2)\n         hash3 = generate_content_hash(content3)\n-        \n+\n         assert hash1 == hash2  # Same content should have same hash\n         assert hash1 != hash3  # Different content should have different hash\n         assert len(hash1) == 32  # MD5 hash length\n \n \n @pytest.mark.unit\n class TestCacheUtils:\n     \"\"\"Test caching utility functions\"\"\"\n-    \n+\n     def test_cache_key_generation(self):\n         \"\"\"Test cache key generation\"\"\"\n+\n         def generate_cache_key(prefix, *args, **kwargs):\n             \"\"\"Generate cache key from prefix and arguments\"\"\"\n             key_parts = [prefix]\n             key_parts.extend(str(arg) for arg in args)\n             key_parts.extend(f\"{k}:{v}\" for k, v in sorted(kwargs.items()))\n             return \":\".join(key_parts)\n-        \n+\n         key1 = generate_cache_key(\"notifications\", \"user123\", status=\"unread\")\n         key2 = generate_cache_key(\"notifications\", \"user123\", status=\"unread\")\n         key3 = generate_cache_key(\"notifications\", \"user456\", status=\"unread\")\n-        \n+\n         assert key1 == key2  # Same parameters should generate same key\n         assert key1 != key3  # Different parameters should generate different key\n         assert \"notifications\" in key1\n         assert \"user123\" in key1\n         assert \"status:unread\" in key1\n-    \n+\n     def test_cache_expiration_calculation(self):\n         \"\"\"Test cache expiration time calculation\"\"\"\n+\n         def calculate_cache_expiration(base_ttl=3600, jitter=0.1):\n             \"\"\"Calculate cache expiration with jitter to avoid thundering herd\"\"\"\n             import random\n+\n             jitter_amount = int(base_ttl * jitter * random.random())\n             return base_ttl + jitter_amount\n-        \n+\n         base_ttl = 3600  # 1 hour\n         expirations = [calculate_cache_expiration(base_ttl) for _ in range(10)]\n-        \n+\n         # All should be around base_ttl\n         for exp in expirations:\n             assert exp >= base_ttl\n             assert exp <= base_ttl * 1.1  # Within 10% jitter\n-        \n+\n         # Should have some variation\n         assert len(set(expirations)) > 1  # Not all exactly the same\n \n \n @pytest.mark.unit\n class TestErrorHandlingUtils:\n     \"\"\"Test error handling and logging utilities\"\"\"\n-    \n+\n     def test_sanitize_error_message(self):\n         \"\"\"Test error message sanitization\"\"\"\n+\n         def sanitize_error_message(error_msg):\n             \"\"\"Sanitize error message for logging\"\"\"\n             # Remove sensitive information\n             sensitive_patterns = [\"password\", \"token\", \"key\", \"secret\"]\n             sanitized = error_msg.lower()\n-            \n+\n             for pattern in sensitive_patterns:\n                 if pattern in sanitized:\n                     return f\"Error contains sensitive information: {pattern}\"\n-            \n+\n             return error_msg\n-        \n+\n         test_cases = [\n             (\"Database connection failed\", \"Database connection failed\"),\n-            (\"Invalid password provided\", \"Error contains sensitive information: password\"),\n+            (\n+                \"Invalid password provided\",\n+                \"Error contains sensitive information: password\",\n+            ),\n             (\"JWT token expired\", \"Error contains sensitive information: token\"),\n             (\"API key is invalid\", \"Error contains sensitive information: key\"),\n-            (\"Normal error message\", \"Normal error message\")\n-        ]\n-        \n+            (\"Normal error message\", \"Normal error message\"),\n+        ]\n+\n         for input_msg, expected in test_cases:\n             result = sanitize_error_message(input_msg)\n             assert expected.lower() in result.lower()\n-    \n+\n     def test_retry_logic_utility(self):\n         \"\"\"Test retry logic utility\"\"\"\n+\n         def should_retry(attempt, max_attempts=3, error_type=None):\n             \"\"\"Determine if operation should be retried\"\"\"\n             if attempt >= max_attempts:\n                 return False\n-            \n+\n             # Don't retry for certain error types\n             non_retryable_errors = [\"ValidationError\", \"AuthenticationError\"]\n             if error_type in non_retryable_errors:\n                 return False\n-            \n+\n             return True\n-        \n+\n         # Test normal retry logic\n         assert should_retry(1, 3) is True\n         assert should_retry(2, 3) is True\n         assert should_retry(3, 3) is False\n         assert should_retry(4, 3) is False\n-        \n+\n         # Test non-retryable errors\n         assert should_retry(1, 3, \"ValidationError\") is False\n         assert should_retry(1, 3, \"AuthenticationError\") is False\n         assert should_retry(1, 3, \"NetworkError\") is True\n-    \n+\n     def test_error_context_builder(self):\n         \"\"\"Test error context building for better debugging\"\"\"\n+\n         def build_error_context(error, operation, **context):\n             \"\"\"Build error context for logging\"\"\"\n             return {\n                 \"error\": str(error),\n                 \"operation\": operation,\n                 \"timestamp\": datetime.utcnow().isoformat(),\n-                \"context\": context\n+                \"context\": context,\n             }\n-        \n+\n         error = Exception(\"Test error\")\n         context = build_error_context(\n-            error, \n-            \"send_notification\",\n-            user_id=\"123\",\n-            channel=\"email\",\n-            attempt=1\n+            error, \"send_notification\", user_id=\"123\", channel=\"email\", attempt=1\n         )\n-        \n+\n         assert \"error\" in context\n         assert \"operation\" in context\n         assert \"timestamp\" in context\n         assert \"context\" in context\n         assert context[\"operation\"] == \"send_notification\"\n         assert context[\"context\"][\"user_id\"] == \"123\"\n-        assert context[\"context\"][\"channel\"] == \"email\"\n\\ No newline at end of file\n+        assert context[\"context\"][\"channel\"] == \"email\"\n--- /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/unit/test_services.py\t2025-09-09 18:09:15.332890+00:00\n+++ /Users/stephanerichard/Documents/CODING/ReactDjango-Hub/services/communication-service/tests/unit/test_services.py\t2025-09-10 11:37:03.230788+00:00\n@@ -14,636 +14,631 @@\n from services.template_engine import TemplateEngine\n from services.queue_manager import QueueManager\n \n # Import models and enums\n from models import (\n-    Notification, NotificationCategory, NotificationTemplate,\n-    NotificationChannel, NotificationStatus, NotificationPriority\n+    Notification,\n+    NotificationCategory,\n+    NotificationTemplate,\n+    NotificationChannel,\n+    NotificationStatus,\n+    NotificationPriority,\n )\n+\n \n @pytest.mark.unit\n @pytest.mark.asyncio\n class TestNotificationService:\n     \"\"\"Unit tests for NotificationService\"\"\"\n-    \n+\n     @pytest.fixture\n     async def notification_service(self, db_session: AsyncSession, mock_redis):\n         \"\"\"Create NotificationService instance with mocked dependencies\"\"\"\n-        with patch('services.notification_service.CacheManager') as mock_cache:\n+        with patch(\"services.notification_service.CacheManager\") as mock_cache:\n             mock_cache_instance = AsyncMock()\n             mock_cache.return_value = mock_cache_instance\n-            \n+\n             service = NotificationService(\n-                db_session=db_session,\n-                cache=mock_cache_instance\n+                db_session=db_session, cache=mock_cache_instance\n             )\n             yield service\n-    \n+\n     @pytest.fixture\n     async def sample_category(self, db_session: AsyncSession):\n         \"\"\"Create sample notification category\"\"\"\n         category = NotificationCategory(\n             name=\"test_service_category\",\n             description=\"Category for service tests\",\n-            default_enabled=True\n+            default_enabled=True,\n         )\n         db_session.add(category)\n         await db_session.commit()\n         await db_session.refresh(category)\n         return category\n-    \n+\n     @pytest.fixture\n     async def sample_template(self, db_session: AsyncSession, sample_category):\n         \"\"\"Create sample notification template\"\"\"\n         template = NotificationTemplate(\n             name=\"test_service_template\",\n             category_id=sample_category.id,\n             channel=NotificationChannel.EMAIL,\n             language=\"en\",\n             subject=\"Welcome {{name}}!\",\n             content=\"Hello {{name}}, your {{action}} was successful.\",\n-            variables={\"name\": \"string\", \"action\": \"string\"}\n+            variables={\"name\": \"string\", \"action\": \"string\"},\n         )\n         db_session.add(template)\n         await db_session.commit()\n         await db_session.refresh(template)\n         return template\n-    \n+\n     async def test_create_notification_with_template(\n-        self, \n-        notification_service: NotificationService, \n-        sample_template: NotificationTemplate\n+        self,\n+        notification_service: NotificationService,\n+        sample_template: NotificationTemplate,\n     ):\n         \"\"\"Test creating notification using template\"\"\"\n         user_id = uuid.uuid4()\n         recipient = \"test@example.com\"\n-        template_data = {\n-            \"name\": \"John Doe\",\n-            \"action\": \"account registration\"\n-        }\n-        \n+        template_data = {\"name\": \"John Doe\", \"action\": \"account registration\"}\n+\n         notification = await notification_service.create_notification(\n             user_id=user_id,\n             template_id=sample_template.id,\n             recipient=recipient,\n-            data=template_data\n-        )\n-        \n+            data=template_data,\n+        )\n+\n         assert notification is not None\n         assert notification.user_id == user_id\n         assert notification.template_id == sample_template.id\n         assert notification.recipient == recipient\n         assert notification.channel == NotificationChannel.EMAIL\n         assert notification.status == NotificationStatus.PENDING\n         assert notification.data == template_data\n         # Template should be rendered\n         assert \"John Doe\" in notification.subject\n         assert \"account registration\" in notification.content\n-    \n+\n     async def test_create_notification_without_template(\n-        self, \n-        notification_service: NotificationService,\n-        sample_category: NotificationCategory\n+        self,\n+        notification_service: NotificationService,\n+        sample_category: NotificationCategory,\n     ):\n         \"\"\"Test creating notification without template\"\"\"\n         user_id = uuid.uuid4()\n         recipient = \"test@example.com\"\n-        \n+\n         notification = await notification_service.create_notification(\n             user_id=user_id,\n             category_id=sample_category.id,\n             channel=NotificationChannel.SMS,\n             subject=\"Direct SMS\",\n             content=\"This is a direct SMS message\",\n-            recipient=recipient\n-        )\n-        \n+            recipient=recipient,\n+        )\n+\n         assert notification is not None\n         assert notification.user_id == user_id\n         assert notification.category_id == sample_category.id\n         assert notification.template_id is None\n         assert notification.channel == NotificationChannel.SMS\n         assert notification.subject == \"Direct SMS\"\n         assert notification.content == \"This is a direct SMS message\"\n         assert notification.recipient == recipient\n         assert notification.status == NotificationStatus.PENDING\n-    \n+\n     async def test_get_notification_by_id(\n-        self, \n-        notification_service: NotificationService,\n-        sample_template: NotificationTemplate\n+        self,\n+        notification_service: NotificationService,\n+        sample_template: NotificationTemplate,\n     ):\n         \"\"\"Test retrieving notification by ID\"\"\"\n         # Create notification first\n         notification = await notification_service.create_notification(\n             user_id=uuid.uuid4(),\n             template_id=sample_template.id,\n             recipient=\"test@example.com\",\n-            data={\"name\": \"Test User\", \"action\": \"test\"}\n-        )\n-        \n+            data={\"name\": \"Test User\", \"action\": \"test\"},\n+        )\n+\n         # Retrieve by ID\n-        found_notification = await notification_service.get_notification_by_id(notification.id)\n-        \n+        found_notification = await notification_service.get_notification_by_id(\n+            notification.id\n+        )\n+\n         assert found_notification is not None\n         assert found_notification.id == notification.id\n         assert found_notification.user_id == notification.user_id\n         assert found_notification.template_id == sample_template.id\n-    \n+\n     async def test_get_nonexistent_notification(\n-        self, \n-        notification_service: NotificationService\n+        self, notification_service: NotificationService\n     ):\n         \"\"\"Test retrieving non-existent notification\"\"\"\n         non_existent_id = uuid.uuid4()\n-        \n-        notification = await notification_service.get_notification_by_id(non_existent_id)\n-        \n+\n+        notification = await notification_service.get_notification_by_id(\n+            non_existent_id\n+        )\n+\n         assert notification is None\n-    \n+\n     async def test_get_user_notifications(\n-        self, \n-        notification_service: NotificationService,\n-        sample_template: NotificationTemplate\n+        self,\n+        notification_service: NotificationService,\n+        sample_template: NotificationTemplate,\n     ):\n         \"\"\"Test retrieving notifications for a user\"\"\"\n         user_id = uuid.uuid4()\n-        \n+\n         # Create multiple notifications for the user\n         for i in range(3):\n             await notification_service.create_notification(\n                 user_id=user_id,\n                 template_id=sample_template.id,\n                 recipient=f\"test{i}@example.com\",\n-                data={\"name\": f\"Test User {i}\", \"action\": \"test\"}\n+                data={\"name\": f\"Test User {i}\", \"action\": \"test\"},\n             )\n-        \n+\n         # Create notification for different user\n         different_user_id = uuid.uuid4()\n         await notification_service.create_notification(\n             user_id=different_user_id,\n             template_id=sample_template.id,\n             recipient=\"other@example.com\",\n-            data={\"name\": \"Other User\", \"action\": \"test\"}\n-        )\n-        \n+            data={\"name\": \"Other User\", \"action\": \"test\"},\n+        )\n+\n         # Get notifications for the first user\n         user_notifications = await notification_service.get_user_notifications(\n             user_id=user_id\n         )\n-        \n+\n         assert len(user_notifications) == 3\n         assert all(n.user_id == user_id for n in user_notifications)\n-    \n+\n     async def test_get_user_notifications_by_channel(\n-        self, \n-        notification_service: NotificationService,\n-        sample_category: NotificationCategory\n+        self,\n+        notification_service: NotificationService,\n+        sample_category: NotificationCategory,\n     ):\n         \"\"\"Test retrieving user notifications filtered by channel\"\"\"\n         user_id = uuid.uuid4()\n-        \n+\n         # Create notifications with different channels\n         await notification_service.create_notification(\n             user_id=user_id,\n             category_id=sample_category.id,\n             channel=NotificationChannel.EMAIL,\n             subject=\"Email notification\",\n             content=\"Test email\",\n-            recipient=\"test@example.com\"\n-        )\n-        \n+            recipient=\"test@example.com\",\n+        )\n+\n         await notification_service.create_notification(\n             user_id=user_id,\n             category_id=sample_category.id,\n             channel=NotificationChannel.SMS,\n             subject=\"SMS notification\",\n             content=\"Test SMS\",\n-            recipient=\"+1234567890\"\n-        )\n-        \n+            recipient=\"+1234567890\",\n+        )\n+\n         await notification_service.create_notification(\n             user_id=user_id,\n             category_id=sample_category.id,\n             channel=NotificationChannel.PUSH,\n             subject=\"Push notification\",\n             content=\"Test push\",\n-            recipient=\"push-token-123\"\n-        )\n-        \n+            recipient=\"push-token-123\",\n+        )\n+\n         # Get only email notifications\n         email_notifications = await notification_service.get_user_notifications(\n-            user_id=user_id,\n-            channel=NotificationChannel.EMAIL\n-        )\n-        \n+            user_id=user_id, channel=NotificationChannel.EMAIL\n+        )\n+\n         assert len(email_notifications) == 1\n         assert email_notifications[0].channel == NotificationChannel.EMAIL\n         assert email_notifications[0].subject == \"Email notification\"\n-    \n+\n     async def test_update_notification_status(\n-        self, \n-        notification_service: NotificationService,\n-        sample_template: NotificationTemplate\n+        self,\n+        notification_service: NotificationService,\n+        sample_template: NotificationTemplate,\n     ):\n         \"\"\"Test updating notification status\"\"\"\n         # Create notification\n         notification = await notification_service.create_notification(\n             user_id=uuid.uuid4(),\n             template_id=sample_template.id,\n             recipient=\"test@example.com\",\n-            data={\"name\": \"Test User\", \"action\": \"test\"}\n-        )\n-        \n+            data={\"name\": \"Test User\", \"action\": \"test\"},\n+        )\n+\n         assert notification.status == NotificationStatus.PENDING\n         assert notification.sent_at is None\n-        \n+\n         # Update to sent\n         updated_notification = await notification_service.update_notification_status(\n             notification_id=notification.id,\n             status=NotificationStatus.SENT,\n-            message_id=\"external-msg-123\"\n-        )\n-        \n+            message_id=\"external-msg-123\",\n+        )\n+\n         assert updated_notification.status == NotificationStatus.SENT\n         assert updated_notification.sent_at is not None\n         assert updated_notification.external_message_id == \"external-msg-123\"\n         assert isinstance(updated_notification.sent_at, datetime)\n-    \n+\n     async def test_update_notification_status_with_error(\n-        self, \n-        notification_service: NotificationService,\n-        sample_template: NotificationTemplate\n+        self,\n+        notification_service: NotificationService,\n+        sample_template: NotificationTemplate,\n     ):\n         \"\"\"Test updating notification status with error\"\"\"\n         # Create notification\n         notification = await notification_service.create_notification(\n             user_id=uuid.uuid4(),\n             template_id=sample_template.id,\n             recipient=\"test@example.com\",\n-            data={\"name\": \"Test User\", \"action\": \"test\"}\n-        )\n-        \n+            data={\"name\": \"Test User\", \"action\": \"test\"},\n+        )\n+\n         # Update to failed with error message\n         error_message = \"SMTP server unavailable\"\n         updated_notification = await notification_service.update_notification_status(\n             notification_id=notification.id,\n             status=NotificationStatus.FAILED,\n-            error_message=error_message\n-        )\n-        \n+            error_message=error_message,\n+        )\n+\n         assert updated_notification.status == NotificationStatus.FAILED\n         assert updated_notification.error_message == error_message\n         assert updated_notification.sent_at is None  # Should not be set for failed\n-    \n+\n     async def test_get_unread_notifications_count(\n-        self, \n-        notification_service: NotificationService,\n-        sample_category: NotificationCategory\n+        self,\n+        notification_service: NotificationService,\n+        sample_category: NotificationCategory,\n     ):\n         \"\"\"Test getting unread notifications count for user\"\"\"\n         user_id = uuid.uuid4()\n-        \n+\n         # Create multiple notifications\n         for i in range(5):\n             await notification_service.create_notification(\n                 user_id=user_id,\n                 category_id=sample_category.id,\n                 channel=NotificationChannel.IN_APP,\n                 subject=f\"Notification {i}\",\n                 content=f\"Test notification {i}\",\n-                recipient=\"in-app\"\n+                recipient=\"in-app\",\n             )\n-        \n+\n         # Mark some as read\n         notifications = await notification_service.get_user_notifications(user_id)\n         for i in range(2):  # Mark first 2 as read\n             await notification_service.update_notification_status(\n-                notification_id=notifications[i].id,\n-                status=NotificationStatus.READ\n+                notification_id=notifications[i].id, status=NotificationStatus.READ\n             )\n-        \n+\n         # Get unread count\n-        unread_count = await notification_service.get_unread_notifications_count(user_id)\n-        \n+        unread_count = await notification_service.get_unread_notifications_count(\n+            user_id\n+        )\n+\n         assert unread_count == 3  # 5 total - 2 read = 3 unread\n-    \n+\n     async def test_mark_notifications_as_read(\n-        self, \n-        notification_service: NotificationService,\n-        sample_category: NotificationCategory\n+        self,\n+        notification_service: NotificationService,\n+        sample_category: NotificationCategory,\n     ):\n         \"\"\"Test marking multiple notifications as read\"\"\"\n         user_id = uuid.uuid4()\n-        \n+\n         # Create notifications\n         notification_ids = []\n         for i in range(3):\n             notification = await notification_service.create_notification(\n                 user_id=user_id,\n                 category_id=sample_category.id,\n                 channel=NotificationChannel.IN_APP,\n                 subject=f\"Notification {i}\",\n                 content=f\"Test notification {i}\",\n-                recipient=\"in-app\"\n+                recipient=\"in-app\",\n             )\n             notification_ids.append(notification.id)\n-        \n+\n         # Mark all as read\n         marked_count = await notification_service.mark_notifications_as_read(\n-            user_id=user_id,\n-            notification_ids=notification_ids\n-        )\n-        \n+            user_id=user_id, notification_ids=notification_ids\n+        )\n+\n         assert marked_count == 3\n-        \n+\n         # Verify they are marked as read\n         for notification_id in notification_ids:\n-            notification = await notification_service.get_notification_by_id(notification_id)\n+            notification = await notification_service.get_notification_by_id(\n+                notification_id\n+            )\n             assert notification.status == NotificationStatus.READ\n-    \n-    @patch('services.notification_service.TemplateEngine')\n+\n+    @patch(\"services.notification_service.TemplateEngine\")\n     async def test_template_rendering_error_handling(\n-        self, \n+        self,\n         mock_template_engine,\n         notification_service: NotificationService,\n-        sample_template: NotificationTemplate\n+        sample_template: NotificationTemplate,\n     ):\n         \"\"\"Test handling template rendering errors\"\"\"\n         # Mock template engine to raise error\n         mock_engine_instance = MagicMock()\n         mock_engine_instance.render.side_effect = Exception(\"Template rendering failed\")\n         mock_template_engine.return_value = mock_engine_instance\n-        \n+\n         # Should handle template error gracefully\n         with pytest.raises(Exception, match=\"Template rendering failed\"):\n             await notification_service.create_notification(\n                 user_id=uuid.uuid4(),\n                 template_id=sample_template.id,\n                 recipient=\"test@example.com\",\n-                data={\"name\": \"Test User\", \"action\": \"test\"}\n+                data={\"name\": \"Test User\", \"action\": \"test\"},\n             )\n \n \n @pytest.mark.unit\n @pytest.mark.asyncio\n class TestTemplateEngine:\n     \"\"\"Unit tests for TemplateEngine\"\"\"\n-    \n+\n     @pytest.fixture\n     def template_engine(self):\n         \"\"\"Create TemplateEngine instance\"\"\"\n         return TemplateEngine()\n-    \n+\n     def test_render_simple_template(self, template_engine: TemplateEngine):\n         \"\"\"Test rendering simple template\"\"\"\n         template = \"Hello {{name}}, welcome to {{platform}}!\"\n         variables = {\"name\": \"John\", \"platform\": \"Our Service\"}\n-        \n+\n         result = template_engine.render(template, variables)\n-        \n+\n         assert result == \"Hello John, welcome to Our Service!\"\n-    \n-    def test_render_template_with_missing_variable(self, template_engine: TemplateEngine):\n+\n+    def test_render_template_with_missing_variable(\n+        self, template_engine: TemplateEngine\n+    ):\n         \"\"\"Test rendering template with missing variable\"\"\"\n         template = \"Hello {{name}}, your {{action}} was successful.\"\n         variables = {\"name\": \"John\"}  # Missing 'action' variable\n-        \n+\n         # Should handle missing variable gracefully\n         result = template_engine.render(template, variables)\n-        \n+\n         # Result should contain the placeholder or empty string\n         assert \"John\" in result\n         assert \"{{action}}\" not in result or result.count(\"{{\") == 0\n-    \n+\n     def test_render_template_with_nested_objects(self, template_engine: TemplateEngine):\n         \"\"\"Test rendering template with nested object variables\"\"\"\n         template = \"Hello {{user.name}}, you have {{stats.unread}} unread messages.\"\n         variables = {\n             \"user\": {\"name\": \"John Doe\", \"email\": \"john@example.com\"},\n-            \"stats\": {\"unread\": 5, \"total\": 20}\n+            \"stats\": {\"unread\": 5, \"total\": 20},\n         }\n-        \n+\n         result = template_engine.render(template, variables)\n-        \n+\n         assert \"John Doe\" in result\n         assert \"5\" in result or \"5 unread\" in result\n-    \n+\n     def test_validate_template_syntax(self, template_engine: TemplateEngine):\n         \"\"\"Test template syntax validation\"\"\"\n         valid_template = \"Hello {{name}}, welcome!\"\n         invalid_template = \"Hello {{name}, welcome!\"  # Missing closing brace\n-        \n+\n         assert template_engine.validate_template(valid_template) is True\n         assert template_engine.validate_template(invalid_template) is False\n-    \n+\n     def test_extract_template_variables(self, template_engine: TemplateEngine):\n         \"\"\"Test extracting variables from template\"\"\"\n         template = \"Hello {{name}}, your {{action}} was successful. Visit {{url}}.\"\n-        \n+\n         variables = template_engine.extract_variables(template)\n-        \n+\n         expected_variables = [\"name\", \"action\", \"url\"]\n         assert set(variables) == set(expected_variables)\n-    \n+\n     def test_render_conditional_template(self, template_engine: TemplateEngine):\n         \"\"\"Test rendering template with conditional logic\"\"\"\n         template = \"Hello {{name}}{% if urgent %}, URGENT: {% endif %}{{message}}\"\n-        \n+\n         # With urgent flag\n-        variables_urgent = {\"name\": \"John\", \"urgent\": True, \"message\": \"Action required\"}\n+        variables_urgent = {\n+            \"name\": \"John\",\n+            \"urgent\": True,\n+            \"message\": \"Action required\",\n+        }\n         result_urgent = template_engine.render(template, variables_urgent)\n         assert \"URGENT\" in result_urgent\n-        \n+\n         # Without urgent flag\n         variables_normal = {\"name\": \"John\", \"urgent\": False, \"message\": \"Info message\"}\n         result_normal = template_engine.render(template, variables_normal)\n         assert \"URGENT\" not in result_normal\n \n \n @pytest.mark.unit\n-@pytest.mark.asyncio  \n+@pytest.mark.asyncio\n class TestQueueManager:\n     \"\"\"Unit tests for QueueManager\"\"\"\n-    \n+\n     @pytest.fixture\n     def queue_manager(self, mock_redis):\n         \"\"\"Create QueueManager instance with mocked Redis\"\"\"\n         return QueueManager(redis_client=mock_redis)\n-    \n+\n     async def test_queue_notification(self, queue_manager: QueueManager, mock_redis):\n         \"\"\"Test queuing notification for processing\"\"\"\n         notification_data = {\n             \"notification_id\": str(uuid.uuid4()),\n             \"user_id\": str(uuid.uuid4()),\n             \"channel\": \"email\",\n-            \"priority\": \"normal\"\n+            \"priority\": \"normal\",\n         }\n-        \n+\n         # Mock Redis lpush to return success\n         mock_redis.lpush.return_value = 1\n-        \n+\n         result = await queue_manager.queue_notification(notification_data)\n-        \n+\n         assert result is True\n         mock_redis.lpush.assert_called_once()\n         # Verify the correct queue was used based on priority\n         call_args = mock_redis.lpush.call_args\n         assert \"normal\" in str(call_args) or \"notifications\" in str(call_args)\n-    \n+\n     async def test_queue_high_priority_notification(\n-        self, \n-        queue_manager: QueueManager, \n-        mock_redis\n+        self, queue_manager: QueueManager, mock_redis\n     ):\n         \"\"\"Test queuing high priority notification\"\"\"\n         notification_data = {\n             \"notification_id\": str(uuid.uuid4()),\n             \"user_id\": str(uuid.uuid4()),\n             \"channel\": \"sms\",\n-            \"priority\": \"high\"\n+            \"priority\": \"high\",\n         }\n-        \n+\n         mock_redis.lpush.return_value = 1\n-        \n+\n         result = await queue_manager.queue_notification(notification_data)\n-        \n+\n         assert result is True\n         mock_redis.lpush.assert_called_once()\n         # High priority should use priority queue\n         call_args = mock_redis.lpush.call_args\n         assert \"high\" in str(call_args) or \"priority\" in str(call_args)\n-    \n+\n     async def test_get_queue_status(self, queue_manager: QueueManager, mock_redis):\n         \"\"\"Test getting queue status\"\"\"\n         # Mock Redis llen to return queue lengths\n         mock_redis.llen.side_effect = [5, 2, 1]  # normal, high, urgent queues\n-        \n+\n         status = await queue_manager.get_queue_status()\n-        \n+\n         assert \"normal\" in status or \"pending\" in status\n         assert isinstance(status, dict)\n         # Should have called llen multiple times for different queues\n         assert mock_redis.llen.call_count >= 1\n-    \n+\n     async def test_dequeue_notification(self, queue_manager: QueueManager, mock_redis):\n         \"\"\"Test dequeuing notification from queue\"\"\"\n-        notification_data = {\n-            \"notification_id\": str(uuid.uuid4()),\n-            \"channel\": \"email\"\n-        }\n-        \n+        notification_data = {\"notification_id\": str(uuid.uuid4()), \"channel\": \"email\"}\n+\n         # Mock Redis brpop to return notification data\n         mock_redis.brpop.return_value = (\"queue_name\", str(notification_data).encode())\n-        \n+\n         result = await queue_manager.dequeue_notification()\n-        \n+\n         assert result is not None\n         mock_redis.brpop.assert_called_once()\n-    \n+\n     async def test_queue_redis_error_handling(\n-        self, \n-        queue_manager: QueueManager, \n-        mock_redis\n+        self, queue_manager: QueueManager, mock_redis\n     ):\n         \"\"\"Test queue error handling when Redis fails\"\"\"\n-        notification_data = {\n-            \"notification_id\": str(uuid.uuid4()),\n-            \"channel\": \"email\"\n-        }\n-        \n+        notification_data = {\"notification_id\": str(uuid.uuid4()), \"channel\": \"email\"}\n+\n         # Mock Redis to raise connection error\n         mock_redis.lpush.side_effect = Exception(\"Redis connection failed\")\n-        \n+\n         result = await queue_manager.queue_notification(notification_data)\n-        \n+\n         assert result is False  # Should return False on error\n-    \n+\n     async def test_queue_notification_with_delay(\n-        self, \n-        queue_manager: QueueManager, \n-        mock_redis\n+        self, queue_manager: QueueManager, mock_redis\n     ):\n         \"\"\"Test queuing notification with delay\"\"\"\n         notification_data = {\n             \"notification_id\": str(uuid.uuid4()),\n             \"channel\": \"email\",\n-            \"delay\": 300  # 5 minutes delay\n+            \"delay\": 300,  # 5 minutes delay\n         }\n-        \n+\n         mock_redis.zadd.return_value = 1  # For delayed queue (sorted set)\n-        \n+\n         result = await queue_manager.queue_notification_with_delay(\n-            notification_data, \n-            delay=300\n-        )\n-        \n+            notification_data, delay=300\n+        )\n+\n         assert result is True\n         mock_redis.zadd.assert_called_once()\n \n \n @pytest.mark.unit\n class TestServiceUtilities:\n     \"\"\"Test utility functions and helpers\"\"\"\n-    \n+\n     def test_notification_priority_ordering(self):\n         \"\"\"Test notification priority enum ordering\"\"\"\n         priorities = [\n             NotificationPriority.LOW,\n-            NotificationPriority.NORMAL, \n+            NotificationPriority.NORMAL,\n             NotificationPriority.HIGH,\n-            NotificationPriority.URGENT\n+            NotificationPriority.URGENT,\n         ]\n-        \n+\n         # Verify priority values can be compared\n         assert NotificationPriority.LOW.value == \"low\"\n         assert NotificationPriority.URGENT.value == \"urgent\"\n-        \n+\n         # Test that we can sort by priority (if implemented)\n         priority_values = [p.value for p in priorities]\n         assert \"low\" in priority_values\n         assert \"urgent\" in priority_values\n-    \n+\n     def test_notification_channel_types(self):\n         \"\"\"Test all notification channel types\"\"\"\n         channels = [\n             NotificationChannel.EMAIL,\n             NotificationChannel.SMS,\n             NotificationChannel.PUSH,\n-            NotificationChannel.IN_APP\n+            NotificationChannel.IN_APP,\n         ]\n-        \n+\n         channel_values = [c.value for c in channels]\n         expected_channels = [\"email\", \"sms\", \"push\", \"in_app\"]\n-        \n+\n         assert set(channel_values) == set(expected_channels)\n-    \n+\n     def test_notification_status_workflow(self):\n         \"\"\"Test notification status workflow\"\"\"\n         # Define expected status flow\n         status_flow = [\n             NotificationStatus.PENDING,\n             NotificationStatus.SENT,\n             NotificationStatus.DELIVERED,\n-            NotificationStatus.READ\n+            NotificationStatus.READ,\n         ]\n-        \n+\n         # Alternative flow to FAILED\n-        failed_flow = [\n-            NotificationStatus.PENDING,\n-            NotificationStatus.FAILED\n-        ]\n-        \n+        failed_flow = [NotificationStatus.PENDING, NotificationStatus.FAILED]\n+\n         # Verify all statuses exist\n         for status in status_flow + failed_flow:\n             assert hasattr(NotificationStatus, status.name)\n             assert isinstance(status.value, str)\n-    \n+\n     @pytest.mark.asyncio\n     async def test_service_error_handling_patterns(self):\n         \"\"\"Test common service error handling patterns\"\"\"\n         # Test with None parameters\n         service = NotificationService(db_session=None, cache=None)\n-        \n+\n         # Should handle gracefully or raise appropriate exceptions\n         with pytest.raises((AttributeError, TypeError, ValueError)):\n-            await service.get_notification_by_id(None)\n\\ No newline at end of file\n+            await service.get_notification_by_id(None)\n"
    }
  },
  "recommendations": [
    "Run 'black .' to fix formatting issues"
  ]
}